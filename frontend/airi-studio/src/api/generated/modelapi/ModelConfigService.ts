/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "@creditkarma/thrift-server-core";
import * as GetBasicConfigurationReq from "./GetBasicConfigurationReq";
import * as GetBasicConfigurationResp from "./GetBasicConfigurationResp";
import * as SaveBasicConfigurationReq from "./SaveBasicConfigurationReq";
import * as SaveBasicConfigurationResp from "./SaveBasicConfigurationResp";
import * as GetKnowledgeConfigReq from "./GetKnowledgeConfigReq";
import * as GetKnowledgeConfigResp from "./GetKnowledgeConfigResp";
import * as UpdateKnowledgeConfigReq from "./UpdateKnowledgeConfigReq";
import * as UpdateKnowledgeConfigResp from "./UpdateKnowledgeConfigResp";
import * as GetModelListReq from "./GetModelListReq";
import * as GetModelListResp from "./GetModelListResp";
import * as CreateModelReq from "./CreateModelReq";
import * as CreateModelResp from "./CreateModelResp";
import * as UpdateModelReq from "./UpdateModelReq";
import * as UpdateModelResp from "./UpdateModelResp";
import * as DeleteModelReq from "./DeleteModelReq";
import * as DeleteModelResp from "./DeleteModelResp";
import * as SetDefaultModelReq from "./SetDefaultModelReq";
import * as SetDefaultModelResp from "./SetDefaultModelResp";
export const serviceName: string = "ModelConfigService";
export const annotations: thrift.IThriftAnnotations = {};
export const methodAnnotations: thrift.IMethodAnnotations = {
    GetBasicConfiguration: {
        annotations: {
            'api.get': "/api/admin/basic/get",
            'api.category': "admin"
        },
        fieldAnnotations: {}
    },
    SaveBasicConfiguration: {
        annotations: {
            'api.post': "/api/admin/basic/save",
            'api.category': "admin"
        },
        fieldAnnotations: {}
    },
    GetKnowledgeConfig: {
        annotations: {
            'api.get': "/api/admin/knowledge/get",
            'api.category': "admin"
        },
        fieldAnnotations: {}
    },
    UpdateKnowledgeConfig: {
        annotations: {
            'api.post': "/api/admin/knowledge/save",
            'api.category': "admin"
        },
        fieldAnnotations: {}
    },
    GetModelList: {
        annotations: {
            'api.get': "/api/admin/model/list",
            'api.category': "admin"
        },
        fieldAnnotations: {}
    },
    CreateModel: {
        annotations: {
            'api.post': "/api/admin/model/create",
            'api.category': "admin"
        },
        fieldAnnotations: {}
    },
    UpdateModel: {
        annotations: {
            'api.post': "/api/admin/model/update",
            'api.category': "admin"
        },
        fieldAnnotations: {}
    },
    DeleteModel: {
        annotations: {
            'api.post': "/api/admin/model/delete",
            'api.category': "admin"
        },
        fieldAnnotations: {}
    },
    SetDefaultModel: {
        annotations: {
            'api.post': "/api/admin/model/set_default",
            'api.category': "admin"
        },
        fieldAnnotations: {}
    }
};
export const methodNames: Array<string> = ["GetBasicConfiguration", "SaveBasicConfiguration", "GetKnowledgeConfig", "UpdateKnowledgeConfig", "GetModelList", "CreateModel", "UpdateModel", "DeleteModel", "SetDefaultModel"];
export const methodParameters: {
    [methodName: string]: number;
} = {
    GetBasicConfiguration: 2,
    SaveBasicConfiguration: 2,
    GetKnowledgeConfig: 2,
    UpdateKnowledgeConfig: 2,
    GetModelList: 2,
    CreateModel: 2,
    UpdateModel: 2,
    DeleteModel: 2,
    SetDefaultModel: 2
};
export interface IGetBasicConfiguration__Args {
    req: GetBasicConfigurationReq.IGetBasicConfigurationReq;
}
export interface IGetBasicConfiguration__ArgsArgs {
    req: GetBasicConfigurationReq.IGetBasicConfigurationReqArgs;
}
export const GetBasicConfiguration__ArgsCodec: thrift.IStructCodec<IGetBasicConfiguration__ArgsArgs, IGetBasicConfiguration__Args> = {
    encode(args: IGetBasicConfiguration__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("GetBasicConfiguration__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            GetBasicConfigurationReq.GetBasicConfigurationReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetBasicConfiguration__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_1: GetBasicConfigurationReq.IGetBasicConfigurationReq = GetBasicConfigurationReq.GetBasicConfigurationReqCodec.decode(input);
                        _args.req = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetBasicConfiguration__Args from input");
        }
    }
};
export class GetBasicConfiguration__Args extends thrift.StructLike implements IGetBasicConfiguration__Args {
    public req: GetBasicConfigurationReq.IGetBasicConfigurationReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetBasicConfiguration__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_2: GetBasicConfigurationReq.IGetBasicConfigurationReq = new GetBasicConfigurationReq.GetBasicConfigurationReq(args.req);
            this.req = value_2;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetBasicConfiguration__Args {
        return new GetBasicConfiguration__Args(GetBasicConfiguration__ArgsCodec.decode(input));
    }
    public static write(args: IGetBasicConfiguration__ArgsArgs, output: thrift.TProtocol): void {
        return GetBasicConfiguration__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetBasicConfiguration__ArgsCodec.encode(this, output);
    }
}
export interface ISaveBasicConfiguration__Args {
    req: SaveBasicConfigurationReq.ISaveBasicConfigurationReq;
}
export interface ISaveBasicConfiguration__ArgsArgs {
    req: SaveBasicConfigurationReq.ISaveBasicConfigurationReqArgs;
}
export const SaveBasicConfiguration__ArgsCodec: thrift.IStructCodec<ISaveBasicConfiguration__ArgsArgs, ISaveBasicConfiguration__Args> = {
    encode(args: ISaveBasicConfiguration__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("SaveBasicConfiguration__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            SaveBasicConfigurationReq.SaveBasicConfigurationReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ISaveBasicConfiguration__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_3: SaveBasicConfigurationReq.ISaveBasicConfigurationReq = SaveBasicConfigurationReq.SaveBasicConfigurationReqCodec.decode(input);
                        _args.req = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SaveBasicConfiguration__Args from input");
        }
    }
};
export class SaveBasicConfiguration__Args extends thrift.StructLike implements ISaveBasicConfiguration__Args {
    public req: SaveBasicConfigurationReq.ISaveBasicConfigurationReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ISaveBasicConfiguration__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_4: SaveBasicConfigurationReq.ISaveBasicConfigurationReq = new SaveBasicConfigurationReq.SaveBasicConfigurationReq(args.req);
            this.req = value_4;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): SaveBasicConfiguration__Args {
        return new SaveBasicConfiguration__Args(SaveBasicConfiguration__ArgsCodec.decode(input));
    }
    public static write(args: ISaveBasicConfiguration__ArgsArgs, output: thrift.TProtocol): void {
        return SaveBasicConfiguration__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return SaveBasicConfiguration__ArgsCodec.encode(this, output);
    }
}
export interface IGetKnowledgeConfig__Args {
    req: GetKnowledgeConfigReq.IGetKnowledgeConfigReq;
}
export interface IGetKnowledgeConfig__ArgsArgs {
    req: GetKnowledgeConfigReq.IGetKnowledgeConfigReqArgs;
}
export const GetKnowledgeConfig__ArgsCodec: thrift.IStructCodec<IGetKnowledgeConfig__ArgsArgs, IGetKnowledgeConfig__Args> = {
    encode(args: IGetKnowledgeConfig__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("GetKnowledgeConfig__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            GetKnowledgeConfigReq.GetKnowledgeConfigReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetKnowledgeConfig__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_5: GetKnowledgeConfigReq.IGetKnowledgeConfigReq = GetKnowledgeConfigReq.GetKnowledgeConfigReqCodec.decode(input);
                        _args.req = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetKnowledgeConfig__Args from input");
        }
    }
};
export class GetKnowledgeConfig__Args extends thrift.StructLike implements IGetKnowledgeConfig__Args {
    public req: GetKnowledgeConfigReq.IGetKnowledgeConfigReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetKnowledgeConfig__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_6: GetKnowledgeConfigReq.IGetKnowledgeConfigReq = new GetKnowledgeConfigReq.GetKnowledgeConfigReq(args.req);
            this.req = value_6;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetKnowledgeConfig__Args {
        return new GetKnowledgeConfig__Args(GetKnowledgeConfig__ArgsCodec.decode(input));
    }
    public static write(args: IGetKnowledgeConfig__ArgsArgs, output: thrift.TProtocol): void {
        return GetKnowledgeConfig__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetKnowledgeConfig__ArgsCodec.encode(this, output);
    }
}
export interface IUpdateKnowledgeConfig__Args {
    req: UpdateKnowledgeConfigReq.IUpdateKnowledgeConfigReq;
}
export interface IUpdateKnowledgeConfig__ArgsArgs {
    req: UpdateKnowledgeConfigReq.IUpdateKnowledgeConfigReqArgs;
}
export const UpdateKnowledgeConfig__ArgsCodec: thrift.IStructCodec<IUpdateKnowledgeConfig__ArgsArgs, IUpdateKnowledgeConfig__Args> = {
    encode(args: IUpdateKnowledgeConfig__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("UpdateKnowledgeConfig__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            UpdateKnowledgeConfigReq.UpdateKnowledgeConfigReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateKnowledgeConfig__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_7: UpdateKnowledgeConfigReq.IUpdateKnowledgeConfigReq = UpdateKnowledgeConfigReq.UpdateKnowledgeConfigReqCodec.decode(input);
                        _args.req = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateKnowledgeConfig__Args from input");
        }
    }
};
export class UpdateKnowledgeConfig__Args extends thrift.StructLike implements IUpdateKnowledgeConfig__Args {
    public req: UpdateKnowledgeConfigReq.IUpdateKnowledgeConfigReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateKnowledgeConfig__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_8: UpdateKnowledgeConfigReq.IUpdateKnowledgeConfigReq = new UpdateKnowledgeConfigReq.UpdateKnowledgeConfigReq(args.req);
            this.req = value_8;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): UpdateKnowledgeConfig__Args {
        return new UpdateKnowledgeConfig__Args(UpdateKnowledgeConfig__ArgsCodec.decode(input));
    }
    public static write(args: IUpdateKnowledgeConfig__ArgsArgs, output: thrift.TProtocol): void {
        return UpdateKnowledgeConfig__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateKnowledgeConfig__ArgsCodec.encode(this, output);
    }
}
export interface IGetModelList__Args {
    req: GetModelListReq.IGetModelListReq;
}
export interface IGetModelList__ArgsArgs {
    req: GetModelListReq.IGetModelListReqArgs;
}
export const GetModelList__ArgsCodec: thrift.IStructCodec<IGetModelList__ArgsArgs, IGetModelList__Args> = {
    encode(args: IGetModelList__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("GetModelList__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            GetModelListReq.GetModelListReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetModelList__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_9: GetModelListReq.IGetModelListReq = GetModelListReq.GetModelListReqCodec.decode(input);
                        _args.req = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetModelList__Args from input");
        }
    }
};
export class GetModelList__Args extends thrift.StructLike implements IGetModelList__Args {
    public req: GetModelListReq.IGetModelListReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetModelList__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_10: GetModelListReq.IGetModelListReq = new GetModelListReq.GetModelListReq(args.req);
            this.req = value_10;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetModelList__Args {
        return new GetModelList__Args(GetModelList__ArgsCodec.decode(input));
    }
    public static write(args: IGetModelList__ArgsArgs, output: thrift.TProtocol): void {
        return GetModelList__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetModelList__ArgsCodec.encode(this, output);
    }
}
export interface ICreateModel__Args {
    req: CreateModelReq.ICreateModelReq;
}
export interface ICreateModel__ArgsArgs {
    req: CreateModelReq.ICreateModelReqArgs;
}
export const CreateModel__ArgsCodec: thrift.IStructCodec<ICreateModel__ArgsArgs, ICreateModel__Args> = {
    encode(args: ICreateModel__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("CreateModel__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            CreateModelReq.CreateModelReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICreateModel__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_11: CreateModelReq.ICreateModelReq = CreateModelReq.CreateModelReqCodec.decode(input);
                        _args.req = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateModel__Args from input");
        }
    }
};
export class CreateModel__Args extends thrift.StructLike implements ICreateModel__Args {
    public req: CreateModelReq.ICreateModelReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ICreateModel__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_12: CreateModelReq.ICreateModelReq = new CreateModelReq.CreateModelReq(args.req);
            this.req = value_12;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): CreateModel__Args {
        return new CreateModel__Args(CreateModel__ArgsCodec.decode(input));
    }
    public static write(args: ICreateModel__ArgsArgs, output: thrift.TProtocol): void {
        return CreateModel__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CreateModel__ArgsCodec.encode(this, output);
    }
}
export interface IUpdateModel__Args {
    req: UpdateModelReq.IUpdateModelReq;
}
export interface IUpdateModel__ArgsArgs {
    req: UpdateModelReq.IUpdateModelReqArgs;
}
export const UpdateModel__ArgsCodec: thrift.IStructCodec<IUpdateModel__ArgsArgs, IUpdateModel__Args> = {
    encode(args: IUpdateModel__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("UpdateModel__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            UpdateModelReq.UpdateModelReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateModel__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_13: UpdateModelReq.IUpdateModelReq = UpdateModelReq.UpdateModelReqCodec.decode(input);
                        _args.req = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateModel__Args from input");
        }
    }
};
export class UpdateModel__Args extends thrift.StructLike implements IUpdateModel__Args {
    public req: UpdateModelReq.IUpdateModelReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateModel__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_14: UpdateModelReq.IUpdateModelReq = new UpdateModelReq.UpdateModelReq(args.req);
            this.req = value_14;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): UpdateModel__Args {
        return new UpdateModel__Args(UpdateModel__ArgsCodec.decode(input));
    }
    public static write(args: IUpdateModel__ArgsArgs, output: thrift.TProtocol): void {
        return UpdateModel__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateModel__ArgsCodec.encode(this, output);
    }
}
export interface IDeleteModel__Args {
    req: DeleteModelReq.IDeleteModelReq;
}
export interface IDeleteModel__ArgsArgs {
    req: DeleteModelReq.IDeleteModelReqArgs;
}
export const DeleteModel__ArgsCodec: thrift.IStructCodec<IDeleteModel__ArgsArgs, IDeleteModel__Args> = {
    encode(args: IDeleteModel__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("DeleteModel__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            DeleteModelReq.DeleteModelReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDeleteModel__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_15: DeleteModelReq.IDeleteModelReq = DeleteModelReq.DeleteModelReqCodec.decode(input);
                        _args.req = value_15;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteModel__Args from input");
        }
    }
};
export class DeleteModel__Args extends thrift.StructLike implements IDeleteModel__Args {
    public req: DeleteModelReq.IDeleteModelReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDeleteModel__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_16: DeleteModelReq.IDeleteModelReq = new DeleteModelReq.DeleteModelReq(args.req);
            this.req = value_16;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): DeleteModel__Args {
        return new DeleteModel__Args(DeleteModel__ArgsCodec.decode(input));
    }
    public static write(args: IDeleteModel__ArgsArgs, output: thrift.TProtocol): void {
        return DeleteModel__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DeleteModel__ArgsCodec.encode(this, output);
    }
}
export interface ISetDefaultModel__Args {
    req: SetDefaultModelReq.ISetDefaultModelReq;
}
export interface ISetDefaultModel__ArgsArgs {
    req: SetDefaultModelReq.ISetDefaultModelReqArgs;
}
export const SetDefaultModel__ArgsCodec: thrift.IStructCodec<ISetDefaultModel__ArgsArgs, ISetDefaultModel__Args> = {
    encode(args: ISetDefaultModel__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("SetDefaultModel__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            SetDefaultModelReq.SetDefaultModelReqCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ISetDefaultModel__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_17: SetDefaultModelReq.ISetDefaultModelReq = SetDefaultModelReq.SetDefaultModelReqCodec.decode(input);
                        _args.req = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetDefaultModel__Args from input");
        }
    }
};
export class SetDefaultModel__Args extends thrift.StructLike implements ISetDefaultModel__Args {
    public req: SetDefaultModelReq.ISetDefaultModelReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ISetDefaultModel__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_18: SetDefaultModelReq.ISetDefaultModelReq = new SetDefaultModelReq.SetDefaultModelReq(args.req);
            this.req = value_18;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): SetDefaultModel__Args {
        return new SetDefaultModel__Args(SetDefaultModel__ArgsCodec.decode(input));
    }
    public static write(args: ISetDefaultModel__ArgsArgs, output: thrift.TProtocol): void {
        return SetDefaultModel__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return SetDefaultModel__ArgsCodec.encode(this, output);
    }
}
export interface IGetBasicConfiguration__Result {
    success?: GetBasicConfigurationResp.IGetBasicConfigurationResp;
}
export interface IGetBasicConfiguration__ResultArgs {
    success?: GetBasicConfigurationResp.IGetBasicConfigurationRespArgs;
}
export const GetBasicConfiguration__ResultCodec: thrift.IStructCodec<IGetBasicConfiguration__ResultArgs, IGetBasicConfiguration__Result> = {
    encode(args: IGetBasicConfiguration__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetBasicConfiguration__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetBasicConfigurationResp.GetBasicConfigurationRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetBasicConfiguration__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_19: GetBasicConfigurationResp.IGetBasicConfigurationResp = GetBasicConfigurationResp.GetBasicConfigurationRespCodec.decode(input);
                        _args.success = value_19;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetBasicConfiguration__Result extends thrift.StructLike implements IGetBasicConfiguration__Result {
    public success?: GetBasicConfigurationResp.IGetBasicConfigurationResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetBasicConfiguration__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_20: GetBasicConfigurationResp.IGetBasicConfigurationResp = new GetBasicConfigurationResp.GetBasicConfigurationResp(args.success);
            this.success = value_20;
        }
    }
    public static read(input: thrift.TProtocol): GetBasicConfiguration__Result {
        return new GetBasicConfiguration__Result(GetBasicConfiguration__ResultCodec.decode(input));
    }
    public static write(args: IGetBasicConfiguration__ResultArgs, output: thrift.TProtocol): void {
        return GetBasicConfiguration__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetBasicConfiguration__ResultCodec.encode(this, output);
    }
}
export interface ISaveBasicConfiguration__Result {
    success?: SaveBasicConfigurationResp.ISaveBasicConfigurationResp;
}
export interface ISaveBasicConfiguration__ResultArgs {
    success?: SaveBasicConfigurationResp.ISaveBasicConfigurationRespArgs;
}
export const SaveBasicConfiguration__ResultCodec: thrift.IStructCodec<ISaveBasicConfiguration__ResultArgs, ISaveBasicConfiguration__Result> = {
    encode(args: ISaveBasicConfiguration__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("SaveBasicConfiguration__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            SaveBasicConfigurationResp.SaveBasicConfigurationRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ISaveBasicConfiguration__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_21: SaveBasicConfigurationResp.ISaveBasicConfigurationResp = SaveBasicConfigurationResp.SaveBasicConfigurationRespCodec.decode(input);
                        _args.success = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class SaveBasicConfiguration__Result extends thrift.StructLike implements ISaveBasicConfiguration__Result {
    public success?: SaveBasicConfigurationResp.ISaveBasicConfigurationResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ISaveBasicConfiguration__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_22: SaveBasicConfigurationResp.ISaveBasicConfigurationResp = new SaveBasicConfigurationResp.SaveBasicConfigurationResp(args.success);
            this.success = value_22;
        }
    }
    public static read(input: thrift.TProtocol): SaveBasicConfiguration__Result {
        return new SaveBasicConfiguration__Result(SaveBasicConfiguration__ResultCodec.decode(input));
    }
    public static write(args: ISaveBasicConfiguration__ResultArgs, output: thrift.TProtocol): void {
        return SaveBasicConfiguration__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return SaveBasicConfiguration__ResultCodec.encode(this, output);
    }
}
export interface IGetKnowledgeConfig__Result {
    success?: GetKnowledgeConfigResp.IGetKnowledgeConfigResp;
}
export interface IGetKnowledgeConfig__ResultArgs {
    success?: GetKnowledgeConfigResp.IGetKnowledgeConfigRespArgs;
}
export const GetKnowledgeConfig__ResultCodec: thrift.IStructCodec<IGetKnowledgeConfig__ResultArgs, IGetKnowledgeConfig__Result> = {
    encode(args: IGetKnowledgeConfig__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetKnowledgeConfig__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetKnowledgeConfigResp.GetKnowledgeConfigRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetKnowledgeConfig__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_23: GetKnowledgeConfigResp.IGetKnowledgeConfigResp = GetKnowledgeConfigResp.GetKnowledgeConfigRespCodec.decode(input);
                        _args.success = value_23;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetKnowledgeConfig__Result extends thrift.StructLike implements IGetKnowledgeConfig__Result {
    public success?: GetKnowledgeConfigResp.IGetKnowledgeConfigResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetKnowledgeConfig__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_24: GetKnowledgeConfigResp.IGetKnowledgeConfigResp = new GetKnowledgeConfigResp.GetKnowledgeConfigResp(args.success);
            this.success = value_24;
        }
    }
    public static read(input: thrift.TProtocol): GetKnowledgeConfig__Result {
        return new GetKnowledgeConfig__Result(GetKnowledgeConfig__ResultCodec.decode(input));
    }
    public static write(args: IGetKnowledgeConfig__ResultArgs, output: thrift.TProtocol): void {
        return GetKnowledgeConfig__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetKnowledgeConfig__ResultCodec.encode(this, output);
    }
}
export interface IUpdateKnowledgeConfig__Result {
    success?: UpdateKnowledgeConfigResp.IUpdateKnowledgeConfigResp;
}
export interface IUpdateKnowledgeConfig__ResultArgs {
    success?: UpdateKnowledgeConfigResp.IUpdateKnowledgeConfigRespArgs;
}
export const UpdateKnowledgeConfig__ResultCodec: thrift.IStructCodec<IUpdateKnowledgeConfig__ResultArgs, IUpdateKnowledgeConfig__Result> = {
    encode(args: IUpdateKnowledgeConfig__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("UpdateKnowledgeConfig__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            UpdateKnowledgeConfigResp.UpdateKnowledgeConfigRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateKnowledgeConfig__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_25: UpdateKnowledgeConfigResp.IUpdateKnowledgeConfigResp = UpdateKnowledgeConfigResp.UpdateKnowledgeConfigRespCodec.decode(input);
                        _args.success = value_25;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class UpdateKnowledgeConfig__Result extends thrift.StructLike implements IUpdateKnowledgeConfig__Result {
    public success?: UpdateKnowledgeConfigResp.IUpdateKnowledgeConfigResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateKnowledgeConfig__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_26: UpdateKnowledgeConfigResp.IUpdateKnowledgeConfigResp = new UpdateKnowledgeConfigResp.UpdateKnowledgeConfigResp(args.success);
            this.success = value_26;
        }
    }
    public static read(input: thrift.TProtocol): UpdateKnowledgeConfig__Result {
        return new UpdateKnowledgeConfig__Result(UpdateKnowledgeConfig__ResultCodec.decode(input));
    }
    public static write(args: IUpdateKnowledgeConfig__ResultArgs, output: thrift.TProtocol): void {
        return UpdateKnowledgeConfig__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateKnowledgeConfig__ResultCodec.encode(this, output);
    }
}
export interface IGetModelList__Result {
    success?: GetModelListResp.IGetModelListResp;
}
export interface IGetModelList__ResultArgs {
    success?: GetModelListResp.IGetModelListRespArgs;
}
export const GetModelList__ResultCodec: thrift.IStructCodec<IGetModelList__ResultArgs, IGetModelList__Result> = {
    encode(args: IGetModelList__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetModelList__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetModelListResp.GetModelListRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetModelList__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_27: GetModelListResp.IGetModelListResp = GetModelListResp.GetModelListRespCodec.decode(input);
                        _args.success = value_27;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetModelList__Result extends thrift.StructLike implements IGetModelList__Result {
    public success?: GetModelListResp.IGetModelListResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetModelList__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_28: GetModelListResp.IGetModelListResp = new GetModelListResp.GetModelListResp(args.success);
            this.success = value_28;
        }
    }
    public static read(input: thrift.TProtocol): GetModelList__Result {
        return new GetModelList__Result(GetModelList__ResultCodec.decode(input));
    }
    public static write(args: IGetModelList__ResultArgs, output: thrift.TProtocol): void {
        return GetModelList__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetModelList__ResultCodec.encode(this, output);
    }
}
export interface ICreateModel__Result {
    success?: CreateModelResp.ICreateModelResp;
}
export interface ICreateModel__ResultArgs {
    success?: CreateModelResp.ICreateModelRespArgs;
}
export const CreateModel__ResultCodec: thrift.IStructCodec<ICreateModel__ResultArgs, ICreateModel__Result> = {
    encode(args: ICreateModel__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("CreateModel__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            CreateModelResp.CreateModelRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICreateModel__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_29: CreateModelResp.ICreateModelResp = CreateModelResp.CreateModelRespCodec.decode(input);
                        _args.success = value_29;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class CreateModel__Result extends thrift.StructLike implements ICreateModel__Result {
    public success?: CreateModelResp.ICreateModelResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ICreateModel__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_30: CreateModelResp.ICreateModelResp = new CreateModelResp.CreateModelResp(args.success);
            this.success = value_30;
        }
    }
    public static read(input: thrift.TProtocol): CreateModel__Result {
        return new CreateModel__Result(CreateModel__ResultCodec.decode(input));
    }
    public static write(args: ICreateModel__ResultArgs, output: thrift.TProtocol): void {
        return CreateModel__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CreateModel__ResultCodec.encode(this, output);
    }
}
export interface IUpdateModel__Result {
    success?: UpdateModelResp.IUpdateModelResp;
}
export interface IUpdateModel__ResultArgs {
    success?: UpdateModelResp.IUpdateModelRespArgs;
}
export const UpdateModel__ResultCodec: thrift.IStructCodec<IUpdateModel__ResultArgs, IUpdateModel__Result> = {
    encode(args: IUpdateModel__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("UpdateModel__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            UpdateModelResp.UpdateModelRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateModel__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_31: UpdateModelResp.IUpdateModelResp = UpdateModelResp.UpdateModelRespCodec.decode(input);
                        _args.success = value_31;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class UpdateModel__Result extends thrift.StructLike implements IUpdateModel__Result {
    public success?: UpdateModelResp.IUpdateModelResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateModel__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_32: UpdateModelResp.IUpdateModelResp = new UpdateModelResp.UpdateModelResp(args.success);
            this.success = value_32;
        }
    }
    public static read(input: thrift.TProtocol): UpdateModel__Result {
        return new UpdateModel__Result(UpdateModel__ResultCodec.decode(input));
    }
    public static write(args: IUpdateModel__ResultArgs, output: thrift.TProtocol): void {
        return UpdateModel__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateModel__ResultCodec.encode(this, output);
    }
}
export interface IDeleteModel__Result {
    success?: DeleteModelResp.IDeleteModelResp;
}
export interface IDeleteModel__ResultArgs {
    success?: DeleteModelResp.IDeleteModelRespArgs;
}
export const DeleteModel__ResultCodec: thrift.IStructCodec<IDeleteModel__ResultArgs, IDeleteModel__Result> = {
    encode(args: IDeleteModel__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("DeleteModel__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            DeleteModelResp.DeleteModelRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDeleteModel__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_33: DeleteModelResp.IDeleteModelResp = DeleteModelResp.DeleteModelRespCodec.decode(input);
                        _args.success = value_33;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class DeleteModel__Result extends thrift.StructLike implements IDeleteModel__Result {
    public success?: DeleteModelResp.IDeleteModelResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDeleteModel__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_34: DeleteModelResp.IDeleteModelResp = new DeleteModelResp.DeleteModelResp(args.success);
            this.success = value_34;
        }
    }
    public static read(input: thrift.TProtocol): DeleteModel__Result {
        return new DeleteModel__Result(DeleteModel__ResultCodec.decode(input));
    }
    public static write(args: IDeleteModel__ResultArgs, output: thrift.TProtocol): void {
        return DeleteModel__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DeleteModel__ResultCodec.encode(this, output);
    }
}
export interface ISetDefaultModel__Result {
    success?: SetDefaultModelResp.ISetDefaultModelResp;
}
export interface ISetDefaultModel__ResultArgs {
    success?: SetDefaultModelResp.ISetDefaultModelRespArgs;
}
export const SetDefaultModel__ResultCodec: thrift.IStructCodec<ISetDefaultModel__ResultArgs, ISetDefaultModel__Result> = {
    encode(args: ISetDefaultModel__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("SetDefaultModel__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            SetDefaultModelResp.SetDefaultModelRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ISetDefaultModel__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_35: SetDefaultModelResp.ISetDefaultModelResp = SetDefaultModelResp.SetDefaultModelRespCodec.decode(input);
                        _args.success = value_35;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class SetDefaultModel__Result extends thrift.StructLike implements ISetDefaultModel__Result {
    public success?: SetDefaultModelResp.ISetDefaultModelResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ISetDefaultModel__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_36: SetDefaultModelResp.ISetDefaultModelResp = new SetDefaultModelResp.SetDefaultModelResp(args.success);
            this.success = value_36;
        }
    }
    public static read(input: thrift.TProtocol): SetDefaultModel__Result {
        return new SetDefaultModel__Result(SetDefaultModel__ResultCodec.decode(input));
    }
    public static write(args: ISetDefaultModel__ResultArgs, output: thrift.TProtocol): void {
        return SetDefaultModel__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return SetDefaultModel__ResultCodec.encode(this, output);
    }
}
export class Client<Context = any> extends thrift.ThriftClient<Context> {
    public static readonly serviceName: string = serviceName;
    public static readonly annotations: thrift.IThriftAnnotations = annotations;
    public static readonly methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public static readonly methodNames: Array<string> = methodNames;
    public readonly _serviceName: string = serviceName;
    public readonly _annotations: thrift.IThriftAnnotations = annotations;
    public readonly _methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public readonly _methodNames: Array<string> = methodNames;
    public readonly _methodParameters?: {
        [methodName: string]: number;
    } = methodParameters;
    public GetBasicConfiguration(req: GetBasicConfigurationReq.IGetBasicConfigurationReqArgs, context?: Context): Promise<GetBasicConfigurationResp.IGetBasicConfigurationResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetBasicConfiguration", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetBasicConfiguration__ArgsArgs = { req };
        GetBasicConfiguration__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetBasicConfiguration") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetBasicConfiguration__Result = GetBasicConfiguration__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetBasicConfiguration failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public SaveBasicConfiguration(req: SaveBasicConfigurationReq.ISaveBasicConfigurationReqArgs, context?: Context): Promise<SaveBasicConfigurationResp.ISaveBasicConfigurationResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("SaveBasicConfiguration", thrift.MessageType.CALL, this.increment_request_id());
        const args: ISaveBasicConfiguration__ArgsArgs = { req };
        SaveBasicConfiguration__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "SaveBasicConfiguration") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: ISaveBasicConfiguration__Result = SaveBasicConfiguration__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "SaveBasicConfiguration failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetKnowledgeConfig(req: GetKnowledgeConfigReq.IGetKnowledgeConfigReqArgs, context?: Context): Promise<GetKnowledgeConfigResp.IGetKnowledgeConfigResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetKnowledgeConfig", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetKnowledgeConfig__ArgsArgs = { req };
        GetKnowledgeConfig__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetKnowledgeConfig") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetKnowledgeConfig__Result = GetKnowledgeConfig__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetKnowledgeConfig failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public UpdateKnowledgeConfig(req: UpdateKnowledgeConfigReq.IUpdateKnowledgeConfigReqArgs, context?: Context): Promise<UpdateKnowledgeConfigResp.IUpdateKnowledgeConfigResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("UpdateKnowledgeConfig", thrift.MessageType.CALL, this.increment_request_id());
        const args: IUpdateKnowledgeConfig__ArgsArgs = { req };
        UpdateKnowledgeConfig__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "UpdateKnowledgeConfig") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IUpdateKnowledgeConfig__Result = UpdateKnowledgeConfig__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "UpdateKnowledgeConfig failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetModelList(req: GetModelListReq.IGetModelListReqArgs, context?: Context): Promise<GetModelListResp.IGetModelListResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetModelList", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetModelList__ArgsArgs = { req };
        GetModelList__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetModelList") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetModelList__Result = GetModelList__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetModelList failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public CreateModel(req: CreateModelReq.ICreateModelReqArgs, context?: Context): Promise<CreateModelResp.ICreateModelResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("CreateModel", thrift.MessageType.CALL, this.increment_request_id());
        const args: ICreateModel__ArgsArgs = { req };
        CreateModel__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "CreateModel") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: ICreateModel__Result = CreateModel__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "CreateModel failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public UpdateModel(req: UpdateModelReq.IUpdateModelReqArgs, context?: Context): Promise<UpdateModelResp.IUpdateModelResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("UpdateModel", thrift.MessageType.CALL, this.increment_request_id());
        const args: IUpdateModel__ArgsArgs = { req };
        UpdateModel__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "UpdateModel") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IUpdateModel__Result = UpdateModel__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "UpdateModel failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public DeleteModel(req: DeleteModelReq.IDeleteModelReqArgs, context?: Context): Promise<DeleteModelResp.IDeleteModelResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("DeleteModel", thrift.MessageType.CALL, this.increment_request_id());
        const args: IDeleteModel__ArgsArgs = { req };
        DeleteModel__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "DeleteModel") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IDeleteModel__Result = DeleteModel__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "DeleteModel failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public SetDefaultModel(req: SetDefaultModelReq.ISetDefaultModelReqArgs, context?: Context): Promise<SetDefaultModelResp.ISetDefaultModelResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("SetDefaultModel", thrift.MessageType.CALL, this.increment_request_id());
        const args: ISetDefaultModel__ArgsArgs = { req };
        SetDefaultModel__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "SetDefaultModel") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: ISetDefaultModel__Result = SetDefaultModel__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "SetDefaultModel failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
}
export interface IHandler<Context = any> {
    GetBasicConfiguration(req: GetBasicConfigurationReq.IGetBasicConfigurationReq, context?: Context): GetBasicConfigurationResp.IGetBasicConfigurationRespArgs | Promise<GetBasicConfigurationResp.IGetBasicConfigurationRespArgs>;
    SaveBasicConfiguration(req: SaveBasicConfigurationReq.ISaveBasicConfigurationReq, context?: Context): SaveBasicConfigurationResp.ISaveBasicConfigurationRespArgs | Promise<SaveBasicConfigurationResp.ISaveBasicConfigurationRespArgs>;
    GetKnowledgeConfig(req: GetKnowledgeConfigReq.IGetKnowledgeConfigReq, context?: Context): GetKnowledgeConfigResp.IGetKnowledgeConfigRespArgs | Promise<GetKnowledgeConfigResp.IGetKnowledgeConfigRespArgs>;
    UpdateKnowledgeConfig(req: UpdateKnowledgeConfigReq.IUpdateKnowledgeConfigReq, context?: Context): UpdateKnowledgeConfigResp.IUpdateKnowledgeConfigRespArgs | Promise<UpdateKnowledgeConfigResp.IUpdateKnowledgeConfigRespArgs>;
    GetModelList(req: GetModelListReq.IGetModelListReq, context?: Context): GetModelListResp.IGetModelListRespArgs | Promise<GetModelListResp.IGetModelListRespArgs>;
    CreateModel(req: CreateModelReq.ICreateModelReq, context?: Context): CreateModelResp.ICreateModelRespArgs | Promise<CreateModelResp.ICreateModelRespArgs>;
    UpdateModel(req: UpdateModelReq.IUpdateModelReq, context?: Context): UpdateModelResp.IUpdateModelRespArgs | Promise<UpdateModelResp.IUpdateModelRespArgs>;
    DeleteModel(req: DeleteModelReq.IDeleteModelReq, context?: Context): DeleteModelResp.IDeleteModelRespArgs | Promise<DeleteModelResp.IDeleteModelRespArgs>;
    SetDefaultModel(req: SetDefaultModelReq.ISetDefaultModelReq, context?: Context): SetDefaultModelResp.ISetDefaultModelRespArgs | Promise<SetDefaultModelResp.ISetDefaultModelRespArgs>;
}
export class Processor<Context = any> extends thrift.ThriftProcessor<Context, IHandler<Context>> {
    protected readonly _handler: IHandler<Context>;
    public static readonly serviceName: string = serviceName;
    public static readonly annotations: thrift.IThriftAnnotations = annotations;
    public static readonly methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public static readonly methodNames: Array<string> = methodNames;
    public readonly _serviceName: string = serviceName;
    public readonly _annotations: thrift.IThriftAnnotations = annotations;
    public readonly _methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public readonly _methodNames: Array<string> = methodNames;
    constructor(handler: IHandler<Context>) {
        super();
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<Buffer>((resolve, reject): void => {
            const metadata: thrift.IThriftMessage = input.readMessageBegin();
            const fieldName: string = metadata.fieldName;
            const requestId: number = metadata.requestId;
            const methodName: string = "process_" + fieldName;
            switch (methodName) {
                case "process_GetBasicConfiguration": {
                    resolve(this.process__get_basic_configuration(requestId, input, output, context));
                    break;
                }
                case "process_SaveBasicConfiguration": {
                    resolve(this.process__save_basic_configuration(requestId, input, output, context));
                    break;
                }
                case "process_GetKnowledgeConfig": {
                    resolve(this.process__get_knowledge_config(requestId, input, output, context));
                    break;
                }
                case "process_UpdateKnowledgeConfig": {
                    resolve(this.process__update_knowledge_config(requestId, input, output, context));
                    break;
                }
                case "process_GetModelList": {
                    resolve(this.process__get_model_list(requestId, input, output, context));
                    break;
                }
                case "process_CreateModel": {
                    resolve(this.process__create_model(requestId, input, output, context));
                    break;
                }
                case "process_UpdateModel": {
                    resolve(this.process__update_model(requestId, input, output, context));
                    break;
                }
                case "process_DeleteModel": {
                    resolve(this.process__delete_model(requestId, input, output, context));
                    break;
                }
                case "process_SetDefaultModel": {
                    resolve(this.process__set_default_model(requestId, input, output, context));
                    break;
                }
                default: {
                    input.skip(thrift.TType.STRUCT);
                    input.readMessageEnd();
                    const errMessage = "Unknown function " + fieldName;
                    const err = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                    output.writeMessageBegin(fieldName, thrift.MessageType.EXCEPTION, requestId);
                    thrift.TApplicationExceptionCodec.encode(err, output);
                    output.writeMessageEnd();
                    resolve(output.flush());
                    break;
                }
            }
        });
    }
    public process_GetBasicConfiguration(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetBasicConfigurationResp.IGetBasicConfigurationRespArgs>((resolve, reject): void => {
            try {
                const args: IGetBasicConfiguration__Args = GetBasicConfiguration__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetBasicConfiguration(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetBasicConfigurationResp.IGetBasicConfigurationRespArgs): Buffer => {
            const result: IGetBasicConfiguration__ResultArgs = { success: data };
            output.writeMessageBegin("GetBasicConfiguration", thrift.MessageType.REPLY, requestId);
            GetBasicConfiguration__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetBasicConfiguration", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_SaveBasicConfiguration(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<SaveBasicConfigurationResp.ISaveBasicConfigurationRespArgs>((resolve, reject): void => {
            try {
                const args: ISaveBasicConfiguration__Args = SaveBasicConfiguration__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.SaveBasicConfiguration(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: SaveBasicConfigurationResp.ISaveBasicConfigurationRespArgs): Buffer => {
            const result: ISaveBasicConfiguration__ResultArgs = { success: data };
            output.writeMessageBegin("SaveBasicConfiguration", thrift.MessageType.REPLY, requestId);
            SaveBasicConfiguration__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("SaveBasicConfiguration", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetKnowledgeConfig(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetKnowledgeConfigResp.IGetKnowledgeConfigRespArgs>((resolve, reject): void => {
            try {
                const args: IGetKnowledgeConfig__Args = GetKnowledgeConfig__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetKnowledgeConfig(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetKnowledgeConfigResp.IGetKnowledgeConfigRespArgs): Buffer => {
            const result: IGetKnowledgeConfig__ResultArgs = { success: data };
            output.writeMessageBegin("GetKnowledgeConfig", thrift.MessageType.REPLY, requestId);
            GetKnowledgeConfig__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetKnowledgeConfig", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_UpdateKnowledgeConfig(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<UpdateKnowledgeConfigResp.IUpdateKnowledgeConfigRespArgs>((resolve, reject): void => {
            try {
                const args: IUpdateKnowledgeConfig__Args = UpdateKnowledgeConfig__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.UpdateKnowledgeConfig(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: UpdateKnowledgeConfigResp.IUpdateKnowledgeConfigRespArgs): Buffer => {
            const result: IUpdateKnowledgeConfig__ResultArgs = { success: data };
            output.writeMessageBegin("UpdateKnowledgeConfig", thrift.MessageType.REPLY, requestId);
            UpdateKnowledgeConfig__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("UpdateKnowledgeConfig", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetModelList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetModelListResp.IGetModelListRespArgs>((resolve, reject): void => {
            try {
                const args: IGetModelList__Args = GetModelList__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetModelList(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetModelListResp.IGetModelListRespArgs): Buffer => {
            const result: IGetModelList__ResultArgs = { success: data };
            output.writeMessageBegin("GetModelList", thrift.MessageType.REPLY, requestId);
            GetModelList__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetModelList", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_CreateModel(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<CreateModelResp.ICreateModelRespArgs>((resolve, reject): void => {
            try {
                const args: ICreateModel__Args = CreateModel__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.CreateModel(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: CreateModelResp.ICreateModelRespArgs): Buffer => {
            const result: ICreateModel__ResultArgs = { success: data };
            output.writeMessageBegin("CreateModel", thrift.MessageType.REPLY, requestId);
            CreateModel__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("CreateModel", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_UpdateModel(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<UpdateModelResp.IUpdateModelRespArgs>((resolve, reject): void => {
            try {
                const args: IUpdateModel__Args = UpdateModel__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.UpdateModel(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: UpdateModelResp.IUpdateModelRespArgs): Buffer => {
            const result: IUpdateModel__ResultArgs = { success: data };
            output.writeMessageBegin("UpdateModel", thrift.MessageType.REPLY, requestId);
            UpdateModel__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("UpdateModel", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_DeleteModel(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<DeleteModelResp.IDeleteModelRespArgs>((resolve, reject): void => {
            try {
                const args: IDeleteModel__Args = DeleteModel__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.DeleteModel(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DeleteModelResp.IDeleteModelRespArgs): Buffer => {
            const result: IDeleteModel__ResultArgs = { success: data };
            output.writeMessageBegin("DeleteModel", thrift.MessageType.REPLY, requestId);
            DeleteModel__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("DeleteModel", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_SetDefaultModel(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<SetDefaultModelResp.ISetDefaultModelRespArgs>((resolve, reject): void => {
            try {
                const args: ISetDefaultModel__Args = SetDefaultModel__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.SetDefaultModel(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: SetDefaultModelResp.ISetDefaultModelRespArgs): Buffer => {
            const result: ISetDefaultModel__ResultArgs = { success: data };
            output.writeMessageBegin("SetDefaultModel", thrift.MessageType.REPLY, requestId);
            SetDefaultModel__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("SetDefaultModel", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
}
