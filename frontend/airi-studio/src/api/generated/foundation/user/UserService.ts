/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "@creditkarma/thrift-server-core";
import * as UserRegisterRequest from "./UserRegisterRequest";
import * as UserRegisterResponse from "./UserRegisterResponse";
import * as ResetPasswordRequest from "./ResetPasswordRequest";
import * as ResetPasswordResponse from "./ResetPasswordResponse";
import * as LoginByPasswordRequest from "./LoginByPasswordRequest";
import * as LoginByPasswordResponse from "./LoginByPasswordResponse";
import * as LogoutRequest from "./LogoutRequest";
import * as LogoutResponse from "./LogoutResponse";
import * as ModifyUserProfileRequest from "./ModifyUserProfileRequest";
import * as ModifyUserProfileResponse from "./ModifyUserProfileResponse";
import * as UserUpdateAvatarRequest from "./UserUpdateAvatarRequest";
import * as UserUpdateAvatarResponse from "./UserUpdateAvatarResponse";
import * as GetUserInfoByTokenRequest from "./GetUserInfoByTokenRequest";
import * as GetUserInfoByTokenResponse from "./GetUserInfoByTokenResponse";
import * as GetUserInfoRequest from "./GetUserInfoRequest";
import * as GetUserInfoResponse from "./GetUserInfoResponse";
import * as MGetUserInfoRequest from "./MGetUserInfoRequest";
import * as MGetUserInfoResponse from "./MGetUserInfoResponse";
export const serviceName: string = "UserService";
export const annotations: thrift.IThriftAnnotations = {};
export const methodAnnotations: thrift.IMethodAnnotations = {
    WebAccountRegister: {
        annotations: {
            'api.post': "/api/foundation/v1/users/register"
        },
        fieldAnnotations: {}
    },
    WebAccountPasswordReset: {
        annotations: {
            'api.post': "/api/foundation/v1/users/reset_password"
        },
        fieldAnnotations: {}
    },
    WebAccountLoginByPassword: {
        annotations: {
            'api.post': "/api/foundation/v1/users/login"
        },
        fieldAnnotations: {}
    },
    WebLogout: {
        annotations: {
            'api.post': "/api/foundation/v1/users/logout"
        },
        fieldAnnotations: {}
    },
    ModifyUserProfile: {
        annotations: {
            'api.put': "/api/foundation/v1/users/:user_id/update_profile"
        },
        fieldAnnotations: {}
    },
    UserUpdateAvatar: {
        annotations: {
            'api.post': "/api/foundation/v1/users/:user_id:/upload_avatar/",
            'api.serializer': "form"
        },
        fieldAnnotations: {}
    },
    GetUserInfoByToken: {
        annotations: {
            'api.get': "/api/foundation/v1/users/session"
        },
        fieldAnnotations: {}
    },
    GetUserInfo: {
        annotations: {
            'api.get': "/api/foundation/v1/users/:user_id"
        },
        fieldAnnotations: {}
    },
    MGetUserInfo: {
        annotations: {
            'api.get': "/api/foundation/v1/users/mget"
        },
        fieldAnnotations: {}
    }
};
export const methodNames: Array<string> = ["WebAccountRegister", "WebAccountPasswordReset", "WebAccountLoginByPassword", "WebLogout", "ModifyUserProfile", "UserUpdateAvatar", "GetUserInfoByToken", "GetUserInfo", "MGetUserInfo"];
export const methodParameters: {
    [methodName: string]: number;
} = {
    WebAccountRegister: 2,
    WebAccountPasswordReset: 2,
    WebAccountLoginByPassword: 2,
    WebLogout: 2,
    ModifyUserProfile: 2,
    UserUpdateAvatar: 2,
    GetUserInfoByToken: 2,
    GetUserInfo: 2,
    MGetUserInfo: 2
};
export interface IWebAccountRegister__Args {
    request: UserRegisterRequest.IUserRegisterRequest;
}
export interface IWebAccountRegister__ArgsArgs {
    request: UserRegisterRequest.IUserRegisterRequestArgs;
}
export const WebAccountRegister__ArgsCodec: thrift.IStructCodec<IWebAccountRegister__ArgsArgs, IWebAccountRegister__Args> = {
    encode(args: IWebAccountRegister__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("WebAccountRegister__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            UserRegisterRequest.UserRegisterRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IWebAccountRegister__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_1: UserRegisterRequest.IUserRegisterRequest = UserRegisterRequest.UserRegisterRequestCodec.decode(input);
                        _args.request = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read WebAccountRegister__Args from input");
        }
    }
};
export class WebAccountRegister__Args extends thrift.StructLike implements IWebAccountRegister__Args {
    public request: UserRegisterRequest.IUserRegisterRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IWebAccountRegister__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_2: UserRegisterRequest.IUserRegisterRequest = new UserRegisterRequest.UserRegisterRequest(args.request);
            this.request = value_2;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): WebAccountRegister__Args {
        return new WebAccountRegister__Args(WebAccountRegister__ArgsCodec.decode(input));
    }
    public static write(args: IWebAccountRegister__ArgsArgs, output: thrift.TProtocol): void {
        return WebAccountRegister__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return WebAccountRegister__ArgsCodec.encode(this, output);
    }
}
export interface IWebAccountPasswordReset__Args {
    request: ResetPasswordRequest.IResetPasswordRequest;
}
export interface IWebAccountPasswordReset__ArgsArgs {
    request: ResetPasswordRequest.IResetPasswordRequestArgs;
}
export const WebAccountPasswordReset__ArgsCodec: thrift.IStructCodec<IWebAccountPasswordReset__ArgsArgs, IWebAccountPasswordReset__Args> = {
    encode(args: IWebAccountPasswordReset__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("WebAccountPasswordReset__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            ResetPasswordRequest.ResetPasswordRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IWebAccountPasswordReset__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_3: ResetPasswordRequest.IResetPasswordRequest = ResetPasswordRequest.ResetPasswordRequestCodec.decode(input);
                        _args.request = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read WebAccountPasswordReset__Args from input");
        }
    }
};
export class WebAccountPasswordReset__Args extends thrift.StructLike implements IWebAccountPasswordReset__Args {
    public request: ResetPasswordRequest.IResetPasswordRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IWebAccountPasswordReset__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_4: ResetPasswordRequest.IResetPasswordRequest = new ResetPasswordRequest.ResetPasswordRequest(args.request);
            this.request = value_4;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): WebAccountPasswordReset__Args {
        return new WebAccountPasswordReset__Args(WebAccountPasswordReset__ArgsCodec.decode(input));
    }
    public static write(args: IWebAccountPasswordReset__ArgsArgs, output: thrift.TProtocol): void {
        return WebAccountPasswordReset__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return WebAccountPasswordReset__ArgsCodec.encode(this, output);
    }
}
export interface IWebAccountLoginByPassword__Args {
    request: LoginByPasswordRequest.ILoginByPasswordRequest;
}
export interface IWebAccountLoginByPassword__ArgsArgs {
    request: LoginByPasswordRequest.ILoginByPasswordRequestArgs;
}
export const WebAccountLoginByPassword__ArgsCodec: thrift.IStructCodec<IWebAccountLoginByPassword__ArgsArgs, IWebAccountLoginByPassword__Args> = {
    encode(args: IWebAccountLoginByPassword__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("WebAccountLoginByPassword__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            LoginByPasswordRequest.LoginByPasswordRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IWebAccountLoginByPassword__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_5: LoginByPasswordRequest.ILoginByPasswordRequest = LoginByPasswordRequest.LoginByPasswordRequestCodec.decode(input);
                        _args.request = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read WebAccountLoginByPassword__Args from input");
        }
    }
};
export class WebAccountLoginByPassword__Args extends thrift.StructLike implements IWebAccountLoginByPassword__Args {
    public request: LoginByPasswordRequest.ILoginByPasswordRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IWebAccountLoginByPassword__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_6: LoginByPasswordRequest.ILoginByPasswordRequest = new LoginByPasswordRequest.LoginByPasswordRequest(args.request);
            this.request = value_6;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): WebAccountLoginByPassword__Args {
        return new WebAccountLoginByPassword__Args(WebAccountLoginByPassword__ArgsCodec.decode(input));
    }
    public static write(args: IWebAccountLoginByPassword__ArgsArgs, output: thrift.TProtocol): void {
        return WebAccountLoginByPassword__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return WebAccountLoginByPassword__ArgsCodec.encode(this, output);
    }
}
export interface IWebLogout__Args {
    request: LogoutRequest.ILogoutRequest;
}
export interface IWebLogout__ArgsArgs {
    request: LogoutRequest.ILogoutRequestArgs;
}
export const WebLogout__ArgsCodec: thrift.IStructCodec<IWebLogout__ArgsArgs, IWebLogout__Args> = {
    encode(args: IWebLogout__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("WebLogout__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            LogoutRequest.LogoutRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IWebLogout__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_7: LogoutRequest.ILogoutRequest = LogoutRequest.LogoutRequestCodec.decode(input);
                        _args.request = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read WebLogout__Args from input");
        }
    }
};
export class WebLogout__Args extends thrift.StructLike implements IWebLogout__Args {
    public request: LogoutRequest.ILogoutRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IWebLogout__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_8: LogoutRequest.ILogoutRequest = new LogoutRequest.LogoutRequest(args.request);
            this.request = value_8;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): WebLogout__Args {
        return new WebLogout__Args(WebLogout__ArgsCodec.decode(input));
    }
    public static write(args: IWebLogout__ArgsArgs, output: thrift.TProtocol): void {
        return WebLogout__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return WebLogout__ArgsCodec.encode(this, output);
    }
}
export interface IModifyUserProfile__Args {
    request: ModifyUserProfileRequest.IModifyUserProfileRequest;
}
export interface IModifyUserProfile__ArgsArgs {
    request: ModifyUserProfileRequest.IModifyUserProfileRequestArgs;
}
export const ModifyUserProfile__ArgsCodec: thrift.IStructCodec<IModifyUserProfile__ArgsArgs, IModifyUserProfile__Args> = {
    encode(args: IModifyUserProfile__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("ModifyUserProfile__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            ModifyUserProfileRequest.ModifyUserProfileRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IModifyUserProfile__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_9: ModifyUserProfileRequest.IModifyUserProfileRequest = ModifyUserProfileRequest.ModifyUserProfileRequestCodec.decode(input);
                        _args.request = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ModifyUserProfile__Args from input");
        }
    }
};
export class ModifyUserProfile__Args extends thrift.StructLike implements IModifyUserProfile__Args {
    public request: ModifyUserProfileRequest.IModifyUserProfileRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IModifyUserProfile__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_10: ModifyUserProfileRequest.IModifyUserProfileRequest = new ModifyUserProfileRequest.ModifyUserProfileRequest(args.request);
            this.request = value_10;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): ModifyUserProfile__Args {
        return new ModifyUserProfile__Args(ModifyUserProfile__ArgsCodec.decode(input));
    }
    public static write(args: IModifyUserProfile__ArgsArgs, output: thrift.TProtocol): void {
        return ModifyUserProfile__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ModifyUserProfile__ArgsCodec.encode(this, output);
    }
}
export interface IUserUpdateAvatar__Args {
    req: UserUpdateAvatarRequest.IUserUpdateAvatarRequest;
}
export interface IUserUpdateAvatar__ArgsArgs {
    req: UserUpdateAvatarRequest.IUserUpdateAvatarRequestArgs;
}
export const UserUpdateAvatar__ArgsCodec: thrift.IStructCodec<IUserUpdateAvatar__ArgsArgs, IUserUpdateAvatar__Args> = {
    encode(args: IUserUpdateAvatar__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("UserUpdateAvatar__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            UserUpdateAvatarRequest.UserUpdateAvatarRequestCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUserUpdateAvatar__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_11: UserUpdateAvatarRequest.IUserUpdateAvatarRequest = UserUpdateAvatarRequest.UserUpdateAvatarRequestCodec.decode(input);
                        _args.req = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UserUpdateAvatar__Args from input");
        }
    }
};
export class UserUpdateAvatar__Args extends thrift.StructLike implements IUserUpdateAvatar__Args {
    public req: UserUpdateAvatarRequest.IUserUpdateAvatarRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUserUpdateAvatar__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_12: UserUpdateAvatarRequest.IUserUpdateAvatarRequest = new UserUpdateAvatarRequest.UserUpdateAvatarRequest(args.req);
            this.req = value_12;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): UserUpdateAvatar__Args {
        return new UserUpdateAvatar__Args(UserUpdateAvatar__ArgsCodec.decode(input));
    }
    public static write(args: IUserUpdateAvatar__ArgsArgs, output: thrift.TProtocol): void {
        return UserUpdateAvatar__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UserUpdateAvatar__ArgsCodec.encode(this, output);
    }
}
export interface IGetUserInfoByToken__Args {
    request: GetUserInfoByTokenRequest.IGetUserInfoByTokenRequest;
}
export interface IGetUserInfoByToken__ArgsArgs {
    request: GetUserInfoByTokenRequest.IGetUserInfoByTokenRequestArgs;
}
export const GetUserInfoByToken__ArgsCodec: thrift.IStructCodec<IGetUserInfoByToken__ArgsArgs, IGetUserInfoByToken__Args> = {
    encode(args: IGetUserInfoByToken__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetUserInfoByToken__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetUserInfoByTokenRequest.GetUserInfoByTokenRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetUserInfoByToken__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_13: GetUserInfoByTokenRequest.IGetUserInfoByTokenRequest = GetUserInfoByTokenRequest.GetUserInfoByTokenRequestCodec.decode(input);
                        _args.request = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetUserInfoByToken__Args from input");
        }
    }
};
export class GetUserInfoByToken__Args extends thrift.StructLike implements IGetUserInfoByToken__Args {
    public request: GetUserInfoByTokenRequest.IGetUserInfoByTokenRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetUserInfoByToken__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_14: GetUserInfoByTokenRequest.IGetUserInfoByTokenRequest = new GetUserInfoByTokenRequest.GetUserInfoByTokenRequest(args.request);
            this.request = value_14;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetUserInfoByToken__Args {
        return new GetUserInfoByToken__Args(GetUserInfoByToken__ArgsCodec.decode(input));
    }
    public static write(args: IGetUserInfoByToken__ArgsArgs, output: thrift.TProtocol): void {
        return GetUserInfoByToken__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetUserInfoByToken__ArgsCodec.encode(this, output);
    }
}
export interface IGetUserInfo__Args {
    request: GetUserInfoRequest.IGetUserInfoRequest;
}
export interface IGetUserInfo__ArgsArgs {
    request: GetUserInfoRequest.IGetUserInfoRequestArgs;
}
export const GetUserInfo__ArgsCodec: thrift.IStructCodec<IGetUserInfo__ArgsArgs, IGetUserInfo__Args> = {
    encode(args: IGetUserInfo__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetUserInfo__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetUserInfoRequest.GetUserInfoRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetUserInfo__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_15: GetUserInfoRequest.IGetUserInfoRequest = GetUserInfoRequest.GetUserInfoRequestCodec.decode(input);
                        _args.request = value_15;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetUserInfo__Args from input");
        }
    }
};
export class GetUserInfo__Args extends thrift.StructLike implements IGetUserInfo__Args {
    public request: GetUserInfoRequest.IGetUserInfoRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetUserInfo__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_16: GetUserInfoRequest.IGetUserInfoRequest = new GetUserInfoRequest.GetUserInfoRequest(args.request);
            this.request = value_16;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetUserInfo__Args {
        return new GetUserInfo__Args(GetUserInfo__ArgsCodec.decode(input));
    }
    public static write(args: IGetUserInfo__ArgsArgs, output: thrift.TProtocol): void {
        return GetUserInfo__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetUserInfo__ArgsCodec.encode(this, output);
    }
}
export interface IMGetUserInfo__Args {
    request: MGetUserInfoRequest.IMGetUserInfoRequest;
}
export interface IMGetUserInfo__ArgsArgs {
    request: MGetUserInfoRequest.IMGetUserInfoRequestArgs;
}
export const MGetUserInfo__ArgsCodec: thrift.IStructCodec<IMGetUserInfo__ArgsArgs, IMGetUserInfo__Args> = {
    encode(args: IMGetUserInfo__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("MGetUserInfo__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            MGetUserInfoRequest.MGetUserInfoRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IMGetUserInfo__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_17: MGetUserInfoRequest.IMGetUserInfoRequest = MGetUserInfoRequest.MGetUserInfoRequestCodec.decode(input);
                        _args.request = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read MGetUserInfo__Args from input");
        }
    }
};
export class MGetUserInfo__Args extends thrift.StructLike implements IMGetUserInfo__Args {
    public request: MGetUserInfoRequest.IMGetUserInfoRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IMGetUserInfo__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_18: MGetUserInfoRequest.IMGetUserInfoRequest = new MGetUserInfoRequest.MGetUserInfoRequest(args.request);
            this.request = value_18;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): MGetUserInfo__Args {
        return new MGetUserInfo__Args(MGetUserInfo__ArgsCodec.decode(input));
    }
    public static write(args: IMGetUserInfo__ArgsArgs, output: thrift.TProtocol): void {
        return MGetUserInfo__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return MGetUserInfo__ArgsCodec.encode(this, output);
    }
}
export interface IWebAccountRegister__Result {
    success?: UserRegisterResponse.IUserRegisterResponse;
}
export interface IWebAccountRegister__ResultArgs {
    success?: UserRegisterResponse.IUserRegisterResponseArgs;
}
export const WebAccountRegister__ResultCodec: thrift.IStructCodec<IWebAccountRegister__ResultArgs, IWebAccountRegister__Result> = {
    encode(args: IWebAccountRegister__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("WebAccountRegister__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            UserRegisterResponse.UserRegisterResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IWebAccountRegister__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_19: UserRegisterResponse.IUserRegisterResponse = UserRegisterResponse.UserRegisterResponseCodec.decode(input);
                        _args.success = value_19;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class WebAccountRegister__Result extends thrift.StructLike implements IWebAccountRegister__Result {
    public success?: UserRegisterResponse.IUserRegisterResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IWebAccountRegister__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_20: UserRegisterResponse.IUserRegisterResponse = new UserRegisterResponse.UserRegisterResponse(args.success);
            this.success = value_20;
        }
    }
    public static read(input: thrift.TProtocol): WebAccountRegister__Result {
        return new WebAccountRegister__Result(WebAccountRegister__ResultCodec.decode(input));
    }
    public static write(args: IWebAccountRegister__ResultArgs, output: thrift.TProtocol): void {
        return WebAccountRegister__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return WebAccountRegister__ResultCodec.encode(this, output);
    }
}
export interface IWebAccountPasswordReset__Result {
    success?: ResetPasswordResponse.IResetPasswordResponse;
}
export interface IWebAccountPasswordReset__ResultArgs {
    success?: ResetPasswordResponse.IResetPasswordResponseArgs;
}
export const WebAccountPasswordReset__ResultCodec: thrift.IStructCodec<IWebAccountPasswordReset__ResultArgs, IWebAccountPasswordReset__Result> = {
    encode(args: IWebAccountPasswordReset__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("WebAccountPasswordReset__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            ResetPasswordResponse.ResetPasswordResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IWebAccountPasswordReset__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_21: ResetPasswordResponse.IResetPasswordResponse = ResetPasswordResponse.ResetPasswordResponseCodec.decode(input);
                        _args.success = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class WebAccountPasswordReset__Result extends thrift.StructLike implements IWebAccountPasswordReset__Result {
    public success?: ResetPasswordResponse.IResetPasswordResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IWebAccountPasswordReset__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_22: ResetPasswordResponse.IResetPasswordResponse = new ResetPasswordResponse.ResetPasswordResponse(args.success);
            this.success = value_22;
        }
    }
    public static read(input: thrift.TProtocol): WebAccountPasswordReset__Result {
        return new WebAccountPasswordReset__Result(WebAccountPasswordReset__ResultCodec.decode(input));
    }
    public static write(args: IWebAccountPasswordReset__ResultArgs, output: thrift.TProtocol): void {
        return WebAccountPasswordReset__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return WebAccountPasswordReset__ResultCodec.encode(this, output);
    }
}
export interface IWebAccountLoginByPassword__Result {
    success?: LoginByPasswordResponse.ILoginByPasswordResponse;
}
export interface IWebAccountLoginByPassword__ResultArgs {
    success?: LoginByPasswordResponse.ILoginByPasswordResponseArgs;
}
export const WebAccountLoginByPassword__ResultCodec: thrift.IStructCodec<IWebAccountLoginByPassword__ResultArgs, IWebAccountLoginByPassword__Result> = {
    encode(args: IWebAccountLoginByPassword__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("WebAccountLoginByPassword__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            LoginByPasswordResponse.LoginByPasswordResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IWebAccountLoginByPassword__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_23: LoginByPasswordResponse.ILoginByPasswordResponse = LoginByPasswordResponse.LoginByPasswordResponseCodec.decode(input);
                        _args.success = value_23;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class WebAccountLoginByPassword__Result extends thrift.StructLike implements IWebAccountLoginByPassword__Result {
    public success?: LoginByPasswordResponse.ILoginByPasswordResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IWebAccountLoginByPassword__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_24: LoginByPasswordResponse.ILoginByPasswordResponse = new LoginByPasswordResponse.LoginByPasswordResponse(args.success);
            this.success = value_24;
        }
    }
    public static read(input: thrift.TProtocol): WebAccountLoginByPassword__Result {
        return new WebAccountLoginByPassword__Result(WebAccountLoginByPassword__ResultCodec.decode(input));
    }
    public static write(args: IWebAccountLoginByPassword__ResultArgs, output: thrift.TProtocol): void {
        return WebAccountLoginByPassword__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return WebAccountLoginByPassword__ResultCodec.encode(this, output);
    }
}
export interface IWebLogout__Result {
    success?: LogoutResponse.ILogoutResponse;
}
export interface IWebLogout__ResultArgs {
    success?: LogoutResponse.ILogoutResponseArgs;
}
export const WebLogout__ResultCodec: thrift.IStructCodec<IWebLogout__ResultArgs, IWebLogout__Result> = {
    encode(args: IWebLogout__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("WebLogout__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            LogoutResponse.LogoutResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IWebLogout__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_25: LogoutResponse.ILogoutResponse = LogoutResponse.LogoutResponseCodec.decode(input);
                        _args.success = value_25;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class WebLogout__Result extends thrift.StructLike implements IWebLogout__Result {
    public success?: LogoutResponse.ILogoutResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IWebLogout__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_26: LogoutResponse.ILogoutResponse = new LogoutResponse.LogoutResponse(args.success);
            this.success = value_26;
        }
    }
    public static read(input: thrift.TProtocol): WebLogout__Result {
        return new WebLogout__Result(WebLogout__ResultCodec.decode(input));
    }
    public static write(args: IWebLogout__ResultArgs, output: thrift.TProtocol): void {
        return WebLogout__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return WebLogout__ResultCodec.encode(this, output);
    }
}
export interface IModifyUserProfile__Result {
    success?: ModifyUserProfileResponse.IModifyUserProfileResponse;
}
export interface IModifyUserProfile__ResultArgs {
    success?: ModifyUserProfileResponse.IModifyUserProfileResponseArgs;
}
export const ModifyUserProfile__ResultCodec: thrift.IStructCodec<IModifyUserProfile__ResultArgs, IModifyUserProfile__Result> = {
    encode(args: IModifyUserProfile__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("ModifyUserProfile__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            ModifyUserProfileResponse.ModifyUserProfileResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IModifyUserProfile__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_27: ModifyUserProfileResponse.IModifyUserProfileResponse = ModifyUserProfileResponse.ModifyUserProfileResponseCodec.decode(input);
                        _args.success = value_27;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class ModifyUserProfile__Result extends thrift.StructLike implements IModifyUserProfile__Result {
    public success?: ModifyUserProfileResponse.IModifyUserProfileResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IModifyUserProfile__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_28: ModifyUserProfileResponse.IModifyUserProfileResponse = new ModifyUserProfileResponse.ModifyUserProfileResponse(args.success);
            this.success = value_28;
        }
    }
    public static read(input: thrift.TProtocol): ModifyUserProfile__Result {
        return new ModifyUserProfile__Result(ModifyUserProfile__ResultCodec.decode(input));
    }
    public static write(args: IModifyUserProfile__ResultArgs, output: thrift.TProtocol): void {
        return ModifyUserProfile__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ModifyUserProfile__ResultCodec.encode(this, output);
    }
}
export interface IUserUpdateAvatar__Result {
    success?: UserUpdateAvatarResponse.IUserUpdateAvatarResponse;
}
export interface IUserUpdateAvatar__ResultArgs {
    success?: UserUpdateAvatarResponse.IUserUpdateAvatarResponseArgs;
}
export const UserUpdateAvatar__ResultCodec: thrift.IStructCodec<IUserUpdateAvatar__ResultArgs, IUserUpdateAvatar__Result> = {
    encode(args: IUserUpdateAvatar__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("UserUpdateAvatar__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            UserUpdateAvatarResponse.UserUpdateAvatarResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUserUpdateAvatar__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_29: UserUpdateAvatarResponse.IUserUpdateAvatarResponse = UserUpdateAvatarResponse.UserUpdateAvatarResponseCodec.decode(input);
                        _args.success = value_29;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class UserUpdateAvatar__Result extends thrift.StructLike implements IUserUpdateAvatar__Result {
    public success?: UserUpdateAvatarResponse.IUserUpdateAvatarResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUserUpdateAvatar__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_30: UserUpdateAvatarResponse.IUserUpdateAvatarResponse = new UserUpdateAvatarResponse.UserUpdateAvatarResponse(args.success);
            this.success = value_30;
        }
    }
    public static read(input: thrift.TProtocol): UserUpdateAvatar__Result {
        return new UserUpdateAvatar__Result(UserUpdateAvatar__ResultCodec.decode(input));
    }
    public static write(args: IUserUpdateAvatar__ResultArgs, output: thrift.TProtocol): void {
        return UserUpdateAvatar__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UserUpdateAvatar__ResultCodec.encode(this, output);
    }
}
export interface IGetUserInfoByToken__Result {
    success?: GetUserInfoByTokenResponse.IGetUserInfoByTokenResponse;
}
export interface IGetUserInfoByToken__ResultArgs {
    success?: GetUserInfoByTokenResponse.IGetUserInfoByTokenResponseArgs;
}
export const GetUserInfoByToken__ResultCodec: thrift.IStructCodec<IGetUserInfoByToken__ResultArgs, IGetUserInfoByToken__Result> = {
    encode(args: IGetUserInfoByToken__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetUserInfoByToken__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetUserInfoByTokenResponse.GetUserInfoByTokenResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetUserInfoByToken__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_31: GetUserInfoByTokenResponse.IGetUserInfoByTokenResponse = GetUserInfoByTokenResponse.GetUserInfoByTokenResponseCodec.decode(input);
                        _args.success = value_31;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetUserInfoByToken__Result extends thrift.StructLike implements IGetUserInfoByToken__Result {
    public success?: GetUserInfoByTokenResponse.IGetUserInfoByTokenResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetUserInfoByToken__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_32: GetUserInfoByTokenResponse.IGetUserInfoByTokenResponse = new GetUserInfoByTokenResponse.GetUserInfoByTokenResponse(args.success);
            this.success = value_32;
        }
    }
    public static read(input: thrift.TProtocol): GetUserInfoByToken__Result {
        return new GetUserInfoByToken__Result(GetUserInfoByToken__ResultCodec.decode(input));
    }
    public static write(args: IGetUserInfoByToken__ResultArgs, output: thrift.TProtocol): void {
        return GetUserInfoByToken__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetUserInfoByToken__ResultCodec.encode(this, output);
    }
}
export interface IGetUserInfo__Result {
    success?: GetUserInfoResponse.IGetUserInfoResponse;
}
export interface IGetUserInfo__ResultArgs {
    success?: GetUserInfoResponse.IGetUserInfoResponseArgs;
}
export const GetUserInfo__ResultCodec: thrift.IStructCodec<IGetUserInfo__ResultArgs, IGetUserInfo__Result> = {
    encode(args: IGetUserInfo__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetUserInfo__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetUserInfoResponse.GetUserInfoResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetUserInfo__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_33: GetUserInfoResponse.IGetUserInfoResponse = GetUserInfoResponse.GetUserInfoResponseCodec.decode(input);
                        _args.success = value_33;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetUserInfo__Result extends thrift.StructLike implements IGetUserInfo__Result {
    public success?: GetUserInfoResponse.IGetUserInfoResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetUserInfo__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_34: GetUserInfoResponse.IGetUserInfoResponse = new GetUserInfoResponse.GetUserInfoResponse(args.success);
            this.success = value_34;
        }
    }
    public static read(input: thrift.TProtocol): GetUserInfo__Result {
        return new GetUserInfo__Result(GetUserInfo__ResultCodec.decode(input));
    }
    public static write(args: IGetUserInfo__ResultArgs, output: thrift.TProtocol): void {
        return GetUserInfo__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetUserInfo__ResultCodec.encode(this, output);
    }
}
export interface IMGetUserInfo__Result {
    success?: MGetUserInfoResponse.IMGetUserInfoResponse;
}
export interface IMGetUserInfo__ResultArgs {
    success?: MGetUserInfoResponse.IMGetUserInfoResponseArgs;
}
export const MGetUserInfo__ResultCodec: thrift.IStructCodec<IMGetUserInfo__ResultArgs, IMGetUserInfo__Result> = {
    encode(args: IMGetUserInfo__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("MGetUserInfo__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            MGetUserInfoResponse.MGetUserInfoResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IMGetUserInfo__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_35: MGetUserInfoResponse.IMGetUserInfoResponse = MGetUserInfoResponse.MGetUserInfoResponseCodec.decode(input);
                        _args.success = value_35;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class MGetUserInfo__Result extends thrift.StructLike implements IMGetUserInfo__Result {
    public success?: MGetUserInfoResponse.IMGetUserInfoResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IMGetUserInfo__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_36: MGetUserInfoResponse.IMGetUserInfoResponse = new MGetUserInfoResponse.MGetUserInfoResponse(args.success);
            this.success = value_36;
        }
    }
    public static read(input: thrift.TProtocol): MGetUserInfo__Result {
        return new MGetUserInfo__Result(MGetUserInfo__ResultCodec.decode(input));
    }
    public static write(args: IMGetUserInfo__ResultArgs, output: thrift.TProtocol): void {
        return MGetUserInfo__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return MGetUserInfo__ResultCodec.encode(this, output);
    }
}
export class Client<Context = any> extends thrift.ThriftClient<Context> {
    public static readonly serviceName: string = serviceName;
    public static readonly annotations: thrift.IThriftAnnotations = annotations;
    public static readonly methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public static readonly methodNames: Array<string> = methodNames;
    public readonly _serviceName: string = serviceName;
    public readonly _annotations: thrift.IThriftAnnotations = annotations;
    public readonly _methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public readonly _methodNames: Array<string> = methodNames;
    public readonly _methodParameters?: {
        [methodName: string]: number;
    } = methodParameters;
    public WebAccountRegister(request: UserRegisterRequest.IUserRegisterRequestArgs, context?: Context): Promise<UserRegisterResponse.IUserRegisterResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("WebAccountRegister", thrift.MessageType.CALL, this.increment_request_id());
        const args: IWebAccountRegister__ArgsArgs = { request };
        WebAccountRegister__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "WebAccountRegister") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IWebAccountRegister__Result = WebAccountRegister__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "WebAccountRegister failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public WebAccountPasswordReset(request: ResetPasswordRequest.IResetPasswordRequestArgs, context?: Context): Promise<ResetPasswordResponse.IResetPasswordResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("WebAccountPasswordReset", thrift.MessageType.CALL, this.increment_request_id());
        const args: IWebAccountPasswordReset__ArgsArgs = { request };
        WebAccountPasswordReset__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "WebAccountPasswordReset") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IWebAccountPasswordReset__Result = WebAccountPasswordReset__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "WebAccountPasswordReset failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public WebAccountLoginByPassword(request: LoginByPasswordRequest.ILoginByPasswordRequestArgs, context?: Context): Promise<LoginByPasswordResponse.ILoginByPasswordResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("WebAccountLoginByPassword", thrift.MessageType.CALL, this.increment_request_id());
        const args: IWebAccountLoginByPassword__ArgsArgs = { request };
        WebAccountLoginByPassword__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "WebAccountLoginByPassword") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IWebAccountLoginByPassword__Result = WebAccountLoginByPassword__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "WebAccountLoginByPassword failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public WebLogout(request: LogoutRequest.ILogoutRequestArgs, context?: Context): Promise<LogoutResponse.ILogoutResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("WebLogout", thrift.MessageType.CALL, this.increment_request_id());
        const args: IWebLogout__ArgsArgs = { request };
        WebLogout__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "WebLogout") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IWebLogout__Result = WebLogout__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "WebLogout failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public ModifyUserProfile(request: ModifyUserProfileRequest.IModifyUserProfileRequestArgs, context?: Context): Promise<ModifyUserProfileResponse.IModifyUserProfileResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("ModifyUserProfile", thrift.MessageType.CALL, this.increment_request_id());
        const args: IModifyUserProfile__ArgsArgs = { request };
        ModifyUserProfile__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "ModifyUserProfile") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IModifyUserProfile__Result = ModifyUserProfile__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "ModifyUserProfile failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public UserUpdateAvatar(req: UserUpdateAvatarRequest.IUserUpdateAvatarRequestArgs, context?: Context): Promise<UserUpdateAvatarResponse.IUserUpdateAvatarResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("UserUpdateAvatar", thrift.MessageType.CALL, this.increment_request_id());
        const args: IUserUpdateAvatar__ArgsArgs = { req };
        UserUpdateAvatar__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "UserUpdateAvatar") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IUserUpdateAvatar__Result = UserUpdateAvatar__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "UserUpdateAvatar failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetUserInfoByToken(request: GetUserInfoByTokenRequest.IGetUserInfoByTokenRequestArgs, context?: Context): Promise<GetUserInfoByTokenResponse.IGetUserInfoByTokenResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetUserInfoByToken", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetUserInfoByToken__ArgsArgs = { request };
        GetUserInfoByToken__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetUserInfoByToken") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetUserInfoByToken__Result = GetUserInfoByToken__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetUserInfoByToken failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetUserInfo(request: GetUserInfoRequest.IGetUserInfoRequestArgs, context?: Context): Promise<GetUserInfoResponse.IGetUserInfoResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetUserInfo", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetUserInfo__ArgsArgs = { request };
        GetUserInfo__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetUserInfo") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetUserInfo__Result = GetUserInfo__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetUserInfo failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public MGetUserInfo(request: MGetUserInfoRequest.IMGetUserInfoRequestArgs, context?: Context): Promise<MGetUserInfoResponse.IMGetUserInfoResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("MGetUserInfo", thrift.MessageType.CALL, this.increment_request_id());
        const args: IMGetUserInfo__ArgsArgs = { request };
        MGetUserInfo__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "MGetUserInfo") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IMGetUserInfo__Result = MGetUserInfo__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "MGetUserInfo failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
}
export interface IHandler<Context = any> {
    WebAccountRegister(request: UserRegisterRequest.IUserRegisterRequest, context?: Context): UserRegisterResponse.IUserRegisterResponseArgs | Promise<UserRegisterResponse.IUserRegisterResponseArgs>;
    WebAccountPasswordReset(request: ResetPasswordRequest.IResetPasswordRequest, context?: Context): ResetPasswordResponse.IResetPasswordResponseArgs | Promise<ResetPasswordResponse.IResetPasswordResponseArgs>;
    WebAccountLoginByPassword(request: LoginByPasswordRequest.ILoginByPasswordRequest, context?: Context): LoginByPasswordResponse.ILoginByPasswordResponseArgs | Promise<LoginByPasswordResponse.ILoginByPasswordResponseArgs>;
    WebLogout(request: LogoutRequest.ILogoutRequest, context?: Context): LogoutResponse.ILogoutResponseArgs | Promise<LogoutResponse.ILogoutResponseArgs>;
    ModifyUserProfile(request: ModifyUserProfileRequest.IModifyUserProfileRequest, context?: Context): ModifyUserProfileResponse.IModifyUserProfileResponseArgs | Promise<ModifyUserProfileResponse.IModifyUserProfileResponseArgs>;
    UserUpdateAvatar(req: UserUpdateAvatarRequest.IUserUpdateAvatarRequest, context?: Context): UserUpdateAvatarResponse.IUserUpdateAvatarResponseArgs | Promise<UserUpdateAvatarResponse.IUserUpdateAvatarResponseArgs>;
    GetUserInfoByToken(request: GetUserInfoByTokenRequest.IGetUserInfoByTokenRequest, context?: Context): GetUserInfoByTokenResponse.IGetUserInfoByTokenResponseArgs | Promise<GetUserInfoByTokenResponse.IGetUserInfoByTokenResponseArgs>;
    GetUserInfo(request: GetUserInfoRequest.IGetUserInfoRequest, context?: Context): GetUserInfoResponse.IGetUserInfoResponseArgs | Promise<GetUserInfoResponse.IGetUserInfoResponseArgs>;
    MGetUserInfo(request: MGetUserInfoRequest.IMGetUserInfoRequest, context?: Context): MGetUserInfoResponse.IMGetUserInfoResponseArgs | Promise<MGetUserInfoResponse.IMGetUserInfoResponseArgs>;
}
export class Processor<Context = any> extends thrift.ThriftProcessor<Context, IHandler<Context>> {
    protected readonly _handler: IHandler<Context>;
    public static readonly serviceName: string = serviceName;
    public static readonly annotations: thrift.IThriftAnnotations = annotations;
    public static readonly methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public static readonly methodNames: Array<string> = methodNames;
    public readonly _serviceName: string = serviceName;
    public readonly _annotations: thrift.IThriftAnnotations = annotations;
    public readonly _methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public readonly _methodNames: Array<string> = methodNames;
    constructor(handler: IHandler<Context>) {
        super();
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<Buffer>((resolve, reject): void => {
            const metadata: thrift.IThriftMessage = input.readMessageBegin();
            const fieldName: string = metadata.fieldName;
            const requestId: number = metadata.requestId;
            const methodName: string = "process_" + fieldName;
            switch (methodName) {
                case "process_WebAccountRegister": {
                    resolve(this.process__web_account_register(requestId, input, output, context));
                    break;
                }
                case "process_WebAccountPasswordReset": {
                    resolve(this.process__web_account_password_reset(requestId, input, output, context));
                    break;
                }
                case "process_WebAccountLoginByPassword": {
                    resolve(this.process__web_account_login_by_password(requestId, input, output, context));
                    break;
                }
                case "process_WebLogout": {
                    resolve(this.process__web_logout(requestId, input, output, context));
                    break;
                }
                case "process_ModifyUserProfile": {
                    resolve(this.process__modify_user_profile(requestId, input, output, context));
                    break;
                }
                case "process_UserUpdateAvatar": {
                    resolve(this.process__user_update_avatar(requestId, input, output, context));
                    break;
                }
                case "process_GetUserInfoByToken": {
                    resolve(this.process__get_user_info_by_token(requestId, input, output, context));
                    break;
                }
                case "process_GetUserInfo": {
                    resolve(this.process__get_user_info(requestId, input, output, context));
                    break;
                }
                case "process_MGetUserInfo": {
                    resolve(this.process__m_get_user_info(requestId, input, output, context));
                    break;
                }
                default: {
                    input.skip(thrift.TType.STRUCT);
                    input.readMessageEnd();
                    const errMessage = "Unknown function " + fieldName;
                    const err = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                    output.writeMessageBegin(fieldName, thrift.MessageType.EXCEPTION, requestId);
                    thrift.TApplicationExceptionCodec.encode(err, output);
                    output.writeMessageEnd();
                    resolve(output.flush());
                    break;
                }
            }
        });
    }
    public process_WebAccountRegister(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<UserRegisterResponse.IUserRegisterResponseArgs>((resolve, reject): void => {
            try {
                const args: IWebAccountRegister__Args = WebAccountRegister__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.WebAccountRegister(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: UserRegisterResponse.IUserRegisterResponseArgs): Buffer => {
            const result: IWebAccountRegister__ResultArgs = { success: data };
            output.writeMessageBegin("WebAccountRegister", thrift.MessageType.REPLY, requestId);
            WebAccountRegister__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("WebAccountRegister", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_WebAccountPasswordReset(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<ResetPasswordResponse.IResetPasswordResponseArgs>((resolve, reject): void => {
            try {
                const args: IWebAccountPasswordReset__Args = WebAccountPasswordReset__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.WebAccountPasswordReset(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ResetPasswordResponse.IResetPasswordResponseArgs): Buffer => {
            const result: IWebAccountPasswordReset__ResultArgs = { success: data };
            output.writeMessageBegin("WebAccountPasswordReset", thrift.MessageType.REPLY, requestId);
            WebAccountPasswordReset__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("WebAccountPasswordReset", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_WebAccountLoginByPassword(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<LoginByPasswordResponse.ILoginByPasswordResponseArgs>((resolve, reject): void => {
            try {
                const args: IWebAccountLoginByPassword__Args = WebAccountLoginByPassword__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.WebAccountLoginByPassword(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: LoginByPasswordResponse.ILoginByPasswordResponseArgs): Buffer => {
            const result: IWebAccountLoginByPassword__ResultArgs = { success: data };
            output.writeMessageBegin("WebAccountLoginByPassword", thrift.MessageType.REPLY, requestId);
            WebAccountLoginByPassword__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("WebAccountLoginByPassword", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_WebLogout(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<LogoutResponse.ILogoutResponseArgs>((resolve, reject): void => {
            try {
                const args: IWebLogout__Args = WebLogout__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.WebLogout(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: LogoutResponse.ILogoutResponseArgs): Buffer => {
            const result: IWebLogout__ResultArgs = { success: data };
            output.writeMessageBegin("WebLogout", thrift.MessageType.REPLY, requestId);
            WebLogout__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("WebLogout", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_ModifyUserProfile(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<ModifyUserProfileResponse.IModifyUserProfileResponseArgs>((resolve, reject): void => {
            try {
                const args: IModifyUserProfile__Args = ModifyUserProfile__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.ModifyUserProfile(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ModifyUserProfileResponse.IModifyUserProfileResponseArgs): Buffer => {
            const result: IModifyUserProfile__ResultArgs = { success: data };
            output.writeMessageBegin("ModifyUserProfile", thrift.MessageType.REPLY, requestId);
            ModifyUserProfile__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("ModifyUserProfile", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_UserUpdateAvatar(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<UserUpdateAvatarResponse.IUserUpdateAvatarResponseArgs>((resolve, reject): void => {
            try {
                const args: IUserUpdateAvatar__Args = UserUpdateAvatar__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.UserUpdateAvatar(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: UserUpdateAvatarResponse.IUserUpdateAvatarResponseArgs): Buffer => {
            const result: IUserUpdateAvatar__ResultArgs = { success: data };
            output.writeMessageBegin("UserUpdateAvatar", thrift.MessageType.REPLY, requestId);
            UserUpdateAvatar__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("UserUpdateAvatar", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetUserInfoByToken(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetUserInfoByTokenResponse.IGetUserInfoByTokenResponseArgs>((resolve, reject): void => {
            try {
                const args: IGetUserInfoByToken__Args = GetUserInfoByToken__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetUserInfoByToken(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetUserInfoByTokenResponse.IGetUserInfoByTokenResponseArgs): Buffer => {
            const result: IGetUserInfoByToken__ResultArgs = { success: data };
            output.writeMessageBegin("GetUserInfoByToken", thrift.MessageType.REPLY, requestId);
            GetUserInfoByToken__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetUserInfoByToken", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetUserInfo(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetUserInfoResponse.IGetUserInfoResponseArgs>((resolve, reject): void => {
            try {
                const args: IGetUserInfo__Args = GetUserInfo__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetUserInfo(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetUserInfoResponse.IGetUserInfoResponseArgs): Buffer => {
            const result: IGetUserInfo__ResultArgs = { success: data };
            output.writeMessageBegin("GetUserInfo", thrift.MessageType.REPLY, requestId);
            GetUserInfo__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetUserInfo", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_MGetUserInfo(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<MGetUserInfoResponse.IMGetUserInfoResponseArgs>((resolve, reject): void => {
            try {
                const args: IMGetUserInfo__Args = MGetUserInfo__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.MGetUserInfo(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: MGetUserInfoResponse.IMGetUserInfoResponseArgs): Buffer => {
            const result: IMGetUserInfo__ResultArgs = { success: data };
            output.writeMessageBegin("MGetUserInfo", thrift.MessageType.REPLY, requestId);
            MGetUserInfo__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("MGetUserInfo", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
}
