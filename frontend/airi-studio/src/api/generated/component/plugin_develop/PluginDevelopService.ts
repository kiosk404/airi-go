/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "@creditkarma/thrift-server-core";
import * as GetOAuthSchemaRequest from "./GetOAuthSchemaRequest";
import * as GetOAuthSchemaResponse from "./GetOAuthSchemaResponse";
import * as GetPlaygroundPluginListRequest from "./GetPlaygroundPluginListRequest";
import * as GetPlaygroundPluginListResponse from "./GetPlaygroundPluginListResponse";
import * as RegisterPluginRequest from "./RegisterPluginRequest";
import * as RegisterPluginResponse from "./RegisterPluginResponse";
import * as RegisterPluginMetaRequest from "./RegisterPluginMetaRequest";
import * as RegisterPluginMetaResponse from "./RegisterPluginMetaResponse";
import * as GetPluginAPIsRequest from "./GetPluginAPIsRequest";
import * as GetPluginAPIsResponse from "./GetPluginAPIsResponse";
import * as GetPluginInfoRequest from "./GetPluginInfoRequest";
import * as GetPluginInfoResponse from "./GetPluginInfoResponse";
import * as GetUpdatedAPIsRequest from "./GetUpdatedAPIsRequest";
import * as GetUpdatedAPIsResponse from "./GetUpdatedAPIsResponse";
import * as GetOAuthStatusRequest from "./GetOAuthStatusRequest";
import * as GetOAuthStatusResponse from "./GetOAuthStatusResponse";
import * as CheckAndLockPluginEditRequest from "./CheckAndLockPluginEditRequest";
import * as CheckAndLockPluginEditResponse from "./CheckAndLockPluginEditResponse";
import * as UnlockPluginEditRequest from "./UnlockPluginEditRequest";
import * as UnlockPluginEditResponse from "./UnlockPluginEditResponse";
import * as UpdatePluginRequest from "./UpdatePluginRequest";
import * as UpdatePluginResponse from "./UpdatePluginResponse";
import * as DeleteAPIRequest from "./DeleteAPIRequest";
import * as DeleteAPIResponse from "./DeleteAPIResponse";
import * as DelPluginRequest from "./DelPluginRequest";
import * as DelPluginResponse from "./DelPluginResponse";
import * as PublishPluginRequest from "./PublishPluginRequest";
import * as PublishPluginResponse from "./PublishPluginResponse";
import * as UpdatePluginMetaRequest from "./UpdatePluginMetaRequest";
import * as UpdatePluginMetaResponse from "./UpdatePluginMetaResponse";
import * as GetBotDefaultParamsRequest from "./GetBotDefaultParamsRequest";
import * as GetBotDefaultParamsResponse from "./GetBotDefaultParamsResponse";
import * as UpdateBotDefaultParamsRequest from "./UpdateBotDefaultParamsRequest";
import * as UpdateBotDefaultParamsResponse from "./UpdateBotDefaultParamsResponse";
import * as CreateAPIRequest from "./CreateAPIRequest";
import * as CreateAPIResponse from "./CreateAPIResponse";
import * as UpdateAPIRequest from "./UpdateAPIRequest";
import * as UpdateAPIResponse from "./UpdateAPIResponse";
import * as GetUserAuthorityRequest from "./GetUserAuthorityRequest";
import * as GetUserAuthorityResponse from "./GetUserAuthorityResponse";
import * as DebugAPIRequest from "./DebugAPIRequest";
import * as DebugAPIResponse from "./DebugAPIResponse";
import * as GetPluginNextVersionRequest from "./GetPluginNextVersionRequest";
import * as GetPluginNextVersionResponse from "./GetPluginNextVersionResponse";
import * as GetDevPluginListRequest from "./GetDevPluginListRequest";
import * as GetDevPluginListResponse from "./GetDevPluginListResponse";
import * as Convert2OpenAPIRequest from "./Convert2OpenAPIRequest";
import * as Convert2OpenAPIResponse from "./Convert2OpenAPIResponse";
import * as BatchCreateAPIRequest from "./BatchCreateAPIRequest";
import * as BatchCreateAPIResponse from "./BatchCreateAPIResponse";
import * as RevokeAuthTokenRequest from "./RevokeAuthTokenRequest";
import * as RevokeAuthTokenResponse from "./RevokeAuthTokenResponse";
import * as GetQueriedOAuthPluginListRequest from "./GetQueriedOAuthPluginListRequest";
import * as GetQueriedOAuthPluginListResponse from "./GetQueriedOAuthPluginListResponse";
export const serviceName: string = "PluginDevelopService";
export const annotations: thrift.IThriftAnnotations = {};
export const methodAnnotations: thrift.IMethodAnnotations = {
    GetOAuthSchema: {
        annotations: {
            'api.post': "/api/plugin/get_oauth_schema",
            'api.category': "plugin",
            'api.gen_path': "plugin"
        },
        fieldAnnotations: {}
    },
    GetOAuthSchemaAPI: {
        annotations: {
            'api.post': "/api/plugin_api/get_oauth_schema",
            'api.category': "plugin",
            'api.gen_path': "plugin"
        },
        fieldAnnotations: {}
    },
    GetPlaygroundPluginList: {
        annotations: {
            'api.post': "/api/plugin_api/get_playground_plugin_list",
            'api.category': "plugin"
        },
        fieldAnnotations: {}
    },
    RegisterPlugin: {
        annotations: {
            'api.post': "/api/plugin_api/register",
            'api.category': "plugin",
            'api.gen_path': "plugin",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    },
    RegisterPluginMeta: {
        annotations: {
            'api.post': "/api/plugin_api/register_plugin_meta",
            'api.category': "plugin"
        },
        fieldAnnotations: {}
    },
    GetPluginAPIs: {
        annotations: {
            'api.post': "/api/plugin_api/get_plugin_apis",
            'api.category': "plugin"
        },
        fieldAnnotations: {}
    },
    GetPluginInfo: {
        annotations: {
            'api.post': "/api/plugin_api/get_plugin_info",
            'api.category': "plugin"
        },
        fieldAnnotations: {}
    },
    GetUpdatedAPIs: {
        annotations: {
            'api.post': "/api/plugin_api/get_updated_apis",
            'api.category': "plugin"
        },
        fieldAnnotations: {}
    },
    GetOAuthStatus: {
        annotations: {
            'api.post': "/api/plugin_api/get_oauth_status",
            'api.category': "plugin",
            'api.gen_path': "plugin"
        },
        fieldAnnotations: {}
    },
    CheckAndLockPluginEdit: {
        annotations: {
            'api.post': "/api/plugin_api/check_and_lock_plugin_edit",
            'api.category': "plugin",
            'api.gen_path': "plugin"
        },
        fieldAnnotations: {}
    },
    UnlockPluginEdit: {
        annotations: {
            'api.post': "/api/plugin_api/unlock_plugin_edit",
            'api.category': "plugin",
            'api.gen_path': "plugin"
        },
        fieldAnnotations: {}
    },
    UpdatePlugin: {
        annotations: {
            'api.post': "/api/plugin_api/update",
            'api.category': "plugin"
        },
        fieldAnnotations: {}
    },
    DeleteAPI: {
        annotations: {
            'api.post': "/api/plugin_api/delete_api",
            'api.category': "plugin",
            'api.gen_path': "plugin"
        },
        fieldAnnotations: {}
    },
    DelPlugin: {
        annotations: {
            'api.post': "/api/plugin_api/del_plugin",
            'api.category': "plugin",
            'api.gen_path': "plugin"
        },
        fieldAnnotations: {}
    },
    PublishPlugin: {
        annotations: {
            'api.post': "/api/plugin_api/publish_plugin",
            'api.category': "plugin"
        },
        fieldAnnotations: {}
    },
    UpdatePluginMeta: {
        annotations: {
            'api.post': "/api/plugin_api/update_plugin_meta",
            'api.category': "plugin"
        },
        fieldAnnotations: {}
    },
    GetBotDefaultParams: {
        annotations: {
            'api.post': "/api/plugin_api/get_bot_default_params",
            'api.category': "plugin"
        },
        fieldAnnotations: {}
    },
    UpdateBotDefaultParams: {
        annotations: {
            'api.post': "/api/plugin_api/update_bot_default_params",
            'api.category': "plugin"
        },
        fieldAnnotations: {}
    },
    CreateAPI: {
        annotations: {
            'api.post': "/api/plugin_api/create_api",
            'api.category': "plugin",
            'api.gen_path': "plugin"
        },
        fieldAnnotations: {}
    },
    UpdateAPI: {
        annotations: {
            'api.post': "/api/plugin_api/update_api",
            'api.category': "plugin",
            'api.gen_path': "plugin"
        },
        fieldAnnotations: {}
    },
    GetUserAuthority: {
        annotations: {
            'api.post': "/api/plugin_api/get_user_authority",
            'api.category': "plugin",
            'api.gen_path': "plugin"
        },
        fieldAnnotations: {}
    },
    DebugAPI: {
        annotations: {
            'api.post': "/api/plugin_api/debug_api",
            'api.category': "plugin",
            'api.gen_path': "plugin"
        },
        fieldAnnotations: {}
    },
    GetPluginNextVersion: {
        annotations: {
            'api.post': "/api/plugin_api/get_plugin_next_version",
            'api.category': "plugin",
            'api.gen_path': "plugin"
        },
        fieldAnnotations: {}
    },
    GetDevPluginList: {
        annotations: {
            'api.post': "/api/plugin_api/get_dev_plugin_list",
            'api.category': "plugin",
            'api.gen_path': "plugin",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    },
    Convert2OpenAPI: {
        annotations: {
            'api.post': "/api/plugin_api/convert_to_openapi",
            'api.category': "plugin",
            'api.gen_path': "plugin",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    },
    BatchCreateAPI: {
        annotations: {
            'api.post': "/api/plugin_api/batch_create_api",
            'api.category': "plugin",
            'api.gen_path': "plugin",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    },
    RevokeAuthToken: {
        annotations: {
            'api.post': "/api/plugin_api/revoke_auth_token",
            'api.category': "plugin",
            'api.gen_path': "plugin",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    },
    GetQueriedOAuthPluginList: {
        annotations: {
            'api.post': "/api/plugin_api/get_queried_oauth_plugins",
            'api.category': "plugin",
            'api.gen_path': "plugin",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    }
};
export const methodNames: Array<string> = ["GetOAuthSchema", "GetOAuthSchemaAPI", "GetPlaygroundPluginList", "RegisterPlugin", "RegisterPluginMeta", "GetPluginAPIs", "GetPluginInfo", "GetUpdatedAPIs", "GetOAuthStatus", "CheckAndLockPluginEdit", "UnlockPluginEdit", "UpdatePlugin", "DeleteAPI", "DelPlugin", "PublishPlugin", "UpdatePluginMeta", "GetBotDefaultParams", "UpdateBotDefaultParams", "CreateAPI", "UpdateAPI", "GetUserAuthority", "DebugAPI", "GetPluginNextVersion", "GetDevPluginList", "Convert2OpenAPI", "BatchCreateAPI", "RevokeAuthToken", "GetQueriedOAuthPluginList"];
export const methodParameters: {
    [methodName: string]: number;
} = {
    GetOAuthSchema: 2,
    GetOAuthSchemaAPI: 2,
    GetPlaygroundPluginList: 2,
    RegisterPlugin: 2,
    RegisterPluginMeta: 2,
    GetPluginAPIs: 2,
    GetPluginInfo: 2,
    GetUpdatedAPIs: 2,
    GetOAuthStatus: 2,
    CheckAndLockPluginEdit: 2,
    UnlockPluginEdit: 2,
    UpdatePlugin: 2,
    DeleteAPI: 2,
    DelPlugin: 2,
    PublishPlugin: 2,
    UpdatePluginMeta: 2,
    GetBotDefaultParams: 2,
    UpdateBotDefaultParams: 2,
    CreateAPI: 2,
    UpdateAPI: 2,
    GetUserAuthority: 2,
    DebugAPI: 2,
    GetPluginNextVersion: 2,
    GetDevPluginList: 2,
    Convert2OpenAPI: 2,
    BatchCreateAPI: 2,
    RevokeAuthToken: 2,
    GetQueriedOAuthPluginList: 2
};
export interface IGetOAuthSchema__Args {
    request: GetOAuthSchemaRequest.IGetOAuthSchemaRequest;
}
export interface IGetOAuthSchema__ArgsArgs {
    request: GetOAuthSchemaRequest.IGetOAuthSchemaRequestArgs;
}
export const GetOAuthSchema__ArgsCodec: thrift.IStructCodec<IGetOAuthSchema__ArgsArgs, IGetOAuthSchema__Args> = {
    encode(args: IGetOAuthSchema__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetOAuthSchema__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetOAuthSchemaRequest.GetOAuthSchemaRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetOAuthSchema__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_1: GetOAuthSchemaRequest.IGetOAuthSchemaRequest = GetOAuthSchemaRequest.GetOAuthSchemaRequestCodec.decode(input);
                        _args.request = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetOAuthSchema__Args from input");
        }
    }
};
export class GetOAuthSchema__Args extends thrift.StructLike implements IGetOAuthSchema__Args {
    public request: GetOAuthSchemaRequest.IGetOAuthSchemaRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetOAuthSchema__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_2: GetOAuthSchemaRequest.IGetOAuthSchemaRequest = new GetOAuthSchemaRequest.GetOAuthSchemaRequest(args.request);
            this.request = value_2;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetOAuthSchema__Args {
        return new GetOAuthSchema__Args(GetOAuthSchema__ArgsCodec.decode(input));
    }
    public static write(args: IGetOAuthSchema__ArgsArgs, output: thrift.TProtocol): void {
        return GetOAuthSchema__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetOAuthSchema__ArgsCodec.encode(this, output);
    }
}
export interface IGetOAuthSchemaAPI__Args {
    request: GetOAuthSchemaRequest.IGetOAuthSchemaRequest;
}
export interface IGetOAuthSchemaAPI__ArgsArgs {
    request: GetOAuthSchemaRequest.IGetOAuthSchemaRequestArgs;
}
export const GetOAuthSchemaAPI__ArgsCodec: thrift.IStructCodec<IGetOAuthSchemaAPI__ArgsArgs, IGetOAuthSchemaAPI__Args> = {
    encode(args: IGetOAuthSchemaAPI__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetOAuthSchemaAPI__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetOAuthSchemaRequest.GetOAuthSchemaRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetOAuthSchemaAPI__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_3: GetOAuthSchemaRequest.IGetOAuthSchemaRequest = GetOAuthSchemaRequest.GetOAuthSchemaRequestCodec.decode(input);
                        _args.request = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetOAuthSchemaAPI__Args from input");
        }
    }
};
export class GetOAuthSchemaAPI__Args extends thrift.StructLike implements IGetOAuthSchemaAPI__Args {
    public request: GetOAuthSchemaRequest.IGetOAuthSchemaRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetOAuthSchemaAPI__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_4: GetOAuthSchemaRequest.IGetOAuthSchemaRequest = new GetOAuthSchemaRequest.GetOAuthSchemaRequest(args.request);
            this.request = value_4;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetOAuthSchemaAPI__Args {
        return new GetOAuthSchemaAPI__Args(GetOAuthSchemaAPI__ArgsCodec.decode(input));
    }
    public static write(args: IGetOAuthSchemaAPI__ArgsArgs, output: thrift.TProtocol): void {
        return GetOAuthSchemaAPI__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetOAuthSchemaAPI__ArgsCodec.encode(this, output);
    }
}
export interface IGetPlaygroundPluginList__Args {
    request: GetPlaygroundPluginListRequest.IGetPlaygroundPluginListRequest;
}
export interface IGetPlaygroundPluginList__ArgsArgs {
    request: GetPlaygroundPluginListRequest.IGetPlaygroundPluginListRequestArgs;
}
export const GetPlaygroundPluginList__ArgsCodec: thrift.IStructCodec<IGetPlaygroundPluginList__ArgsArgs, IGetPlaygroundPluginList__Args> = {
    encode(args: IGetPlaygroundPluginList__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetPlaygroundPluginList__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetPlaygroundPluginListRequest.GetPlaygroundPluginListRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetPlaygroundPluginList__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_5: GetPlaygroundPluginListRequest.IGetPlaygroundPluginListRequest = GetPlaygroundPluginListRequest.GetPlaygroundPluginListRequestCodec.decode(input);
                        _args.request = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetPlaygroundPluginList__Args from input");
        }
    }
};
export class GetPlaygroundPluginList__Args extends thrift.StructLike implements IGetPlaygroundPluginList__Args {
    public request: GetPlaygroundPluginListRequest.IGetPlaygroundPluginListRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetPlaygroundPluginList__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_6: GetPlaygroundPluginListRequest.IGetPlaygroundPluginListRequest = new GetPlaygroundPluginListRequest.GetPlaygroundPluginListRequest(args.request);
            this.request = value_6;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetPlaygroundPluginList__Args {
        return new GetPlaygroundPluginList__Args(GetPlaygroundPluginList__ArgsCodec.decode(input));
    }
    public static write(args: IGetPlaygroundPluginList__ArgsArgs, output: thrift.TProtocol): void {
        return GetPlaygroundPluginList__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetPlaygroundPluginList__ArgsCodec.encode(this, output);
    }
}
export interface IRegisterPlugin__Args {
    request: RegisterPluginRequest.IRegisterPluginRequest;
}
export interface IRegisterPlugin__ArgsArgs {
    request: RegisterPluginRequest.IRegisterPluginRequestArgs;
}
export const RegisterPlugin__ArgsCodec: thrift.IStructCodec<IRegisterPlugin__ArgsArgs, IRegisterPlugin__Args> = {
    encode(args: IRegisterPlugin__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("RegisterPlugin__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            RegisterPluginRequest.RegisterPluginRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IRegisterPlugin__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_7: RegisterPluginRequest.IRegisterPluginRequest = RegisterPluginRequest.RegisterPluginRequestCodec.decode(input);
                        _args.request = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RegisterPlugin__Args from input");
        }
    }
};
export class RegisterPlugin__Args extends thrift.StructLike implements IRegisterPlugin__Args {
    public request: RegisterPluginRequest.IRegisterPluginRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IRegisterPlugin__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_8: RegisterPluginRequest.IRegisterPluginRequest = new RegisterPluginRequest.RegisterPluginRequest(args.request);
            this.request = value_8;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): RegisterPlugin__Args {
        return new RegisterPlugin__Args(RegisterPlugin__ArgsCodec.decode(input));
    }
    public static write(args: IRegisterPlugin__ArgsArgs, output: thrift.TProtocol): void {
        return RegisterPlugin__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return RegisterPlugin__ArgsCodec.encode(this, output);
    }
}
export interface IRegisterPluginMeta__Args {
    request: RegisterPluginMetaRequest.IRegisterPluginMetaRequest;
}
export interface IRegisterPluginMeta__ArgsArgs {
    request: RegisterPluginMetaRequest.IRegisterPluginMetaRequestArgs;
}
export const RegisterPluginMeta__ArgsCodec: thrift.IStructCodec<IRegisterPluginMeta__ArgsArgs, IRegisterPluginMeta__Args> = {
    encode(args: IRegisterPluginMeta__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("RegisterPluginMeta__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            RegisterPluginMetaRequest.RegisterPluginMetaRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IRegisterPluginMeta__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_9: RegisterPluginMetaRequest.IRegisterPluginMetaRequest = RegisterPluginMetaRequest.RegisterPluginMetaRequestCodec.decode(input);
                        _args.request = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RegisterPluginMeta__Args from input");
        }
    }
};
export class RegisterPluginMeta__Args extends thrift.StructLike implements IRegisterPluginMeta__Args {
    public request: RegisterPluginMetaRequest.IRegisterPluginMetaRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IRegisterPluginMeta__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_10: RegisterPluginMetaRequest.IRegisterPluginMetaRequest = new RegisterPluginMetaRequest.RegisterPluginMetaRequest(args.request);
            this.request = value_10;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): RegisterPluginMeta__Args {
        return new RegisterPluginMeta__Args(RegisterPluginMeta__ArgsCodec.decode(input));
    }
    public static write(args: IRegisterPluginMeta__ArgsArgs, output: thrift.TProtocol): void {
        return RegisterPluginMeta__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return RegisterPluginMeta__ArgsCodec.encode(this, output);
    }
}
export interface IGetPluginAPIs__Args {
    request: GetPluginAPIsRequest.IGetPluginAPIsRequest;
}
export interface IGetPluginAPIs__ArgsArgs {
    request: GetPluginAPIsRequest.IGetPluginAPIsRequestArgs;
}
export const GetPluginAPIs__ArgsCodec: thrift.IStructCodec<IGetPluginAPIs__ArgsArgs, IGetPluginAPIs__Args> = {
    encode(args: IGetPluginAPIs__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetPluginAPIs__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetPluginAPIsRequest.GetPluginAPIsRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetPluginAPIs__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_11: GetPluginAPIsRequest.IGetPluginAPIsRequest = GetPluginAPIsRequest.GetPluginAPIsRequestCodec.decode(input);
                        _args.request = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetPluginAPIs__Args from input");
        }
    }
};
export class GetPluginAPIs__Args extends thrift.StructLike implements IGetPluginAPIs__Args {
    public request: GetPluginAPIsRequest.IGetPluginAPIsRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetPluginAPIs__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_12: GetPluginAPIsRequest.IGetPluginAPIsRequest = new GetPluginAPIsRequest.GetPluginAPIsRequest(args.request);
            this.request = value_12;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetPluginAPIs__Args {
        return new GetPluginAPIs__Args(GetPluginAPIs__ArgsCodec.decode(input));
    }
    public static write(args: IGetPluginAPIs__ArgsArgs, output: thrift.TProtocol): void {
        return GetPluginAPIs__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetPluginAPIs__ArgsCodec.encode(this, output);
    }
}
export interface IGetPluginInfo__Args {
    request: GetPluginInfoRequest.IGetPluginInfoRequest;
}
export interface IGetPluginInfo__ArgsArgs {
    request: GetPluginInfoRequest.IGetPluginInfoRequestArgs;
}
export const GetPluginInfo__ArgsCodec: thrift.IStructCodec<IGetPluginInfo__ArgsArgs, IGetPluginInfo__Args> = {
    encode(args: IGetPluginInfo__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetPluginInfo__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetPluginInfoRequest.GetPluginInfoRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetPluginInfo__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_13: GetPluginInfoRequest.IGetPluginInfoRequest = GetPluginInfoRequest.GetPluginInfoRequestCodec.decode(input);
                        _args.request = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetPluginInfo__Args from input");
        }
    }
};
export class GetPluginInfo__Args extends thrift.StructLike implements IGetPluginInfo__Args {
    public request: GetPluginInfoRequest.IGetPluginInfoRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetPluginInfo__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_14: GetPluginInfoRequest.IGetPluginInfoRequest = new GetPluginInfoRequest.GetPluginInfoRequest(args.request);
            this.request = value_14;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetPluginInfo__Args {
        return new GetPluginInfo__Args(GetPluginInfo__ArgsCodec.decode(input));
    }
    public static write(args: IGetPluginInfo__ArgsArgs, output: thrift.TProtocol): void {
        return GetPluginInfo__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetPluginInfo__ArgsCodec.encode(this, output);
    }
}
export interface IGetUpdatedAPIs__Args {
    request: GetUpdatedAPIsRequest.IGetUpdatedAPIsRequest;
}
export interface IGetUpdatedAPIs__ArgsArgs {
    request: GetUpdatedAPIsRequest.IGetUpdatedAPIsRequestArgs;
}
export const GetUpdatedAPIs__ArgsCodec: thrift.IStructCodec<IGetUpdatedAPIs__ArgsArgs, IGetUpdatedAPIs__Args> = {
    encode(args: IGetUpdatedAPIs__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetUpdatedAPIs__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetUpdatedAPIsRequest.GetUpdatedAPIsRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetUpdatedAPIs__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_15: GetUpdatedAPIsRequest.IGetUpdatedAPIsRequest = GetUpdatedAPIsRequest.GetUpdatedAPIsRequestCodec.decode(input);
                        _args.request = value_15;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetUpdatedAPIs__Args from input");
        }
    }
};
export class GetUpdatedAPIs__Args extends thrift.StructLike implements IGetUpdatedAPIs__Args {
    public request: GetUpdatedAPIsRequest.IGetUpdatedAPIsRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetUpdatedAPIs__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_16: GetUpdatedAPIsRequest.IGetUpdatedAPIsRequest = new GetUpdatedAPIsRequest.GetUpdatedAPIsRequest(args.request);
            this.request = value_16;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetUpdatedAPIs__Args {
        return new GetUpdatedAPIs__Args(GetUpdatedAPIs__ArgsCodec.decode(input));
    }
    public static write(args: IGetUpdatedAPIs__ArgsArgs, output: thrift.TProtocol): void {
        return GetUpdatedAPIs__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetUpdatedAPIs__ArgsCodec.encode(this, output);
    }
}
export interface IGetOAuthStatus__Args {
    request: GetOAuthStatusRequest.IGetOAuthStatusRequest;
}
export interface IGetOAuthStatus__ArgsArgs {
    request: GetOAuthStatusRequest.IGetOAuthStatusRequestArgs;
}
export const GetOAuthStatus__ArgsCodec: thrift.IStructCodec<IGetOAuthStatus__ArgsArgs, IGetOAuthStatus__Args> = {
    encode(args: IGetOAuthStatus__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetOAuthStatus__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetOAuthStatusRequest.GetOAuthStatusRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetOAuthStatus__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_17: GetOAuthStatusRequest.IGetOAuthStatusRequest = GetOAuthStatusRequest.GetOAuthStatusRequestCodec.decode(input);
                        _args.request = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetOAuthStatus__Args from input");
        }
    }
};
export class GetOAuthStatus__Args extends thrift.StructLike implements IGetOAuthStatus__Args {
    public request: GetOAuthStatusRequest.IGetOAuthStatusRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetOAuthStatus__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_18: GetOAuthStatusRequest.IGetOAuthStatusRequest = new GetOAuthStatusRequest.GetOAuthStatusRequest(args.request);
            this.request = value_18;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetOAuthStatus__Args {
        return new GetOAuthStatus__Args(GetOAuthStatus__ArgsCodec.decode(input));
    }
    public static write(args: IGetOAuthStatus__ArgsArgs, output: thrift.TProtocol): void {
        return GetOAuthStatus__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetOAuthStatus__ArgsCodec.encode(this, output);
    }
}
export interface ICheckAndLockPluginEdit__Args {
    request: CheckAndLockPluginEditRequest.ICheckAndLockPluginEditRequest;
}
export interface ICheckAndLockPluginEdit__ArgsArgs {
    request: CheckAndLockPluginEditRequest.ICheckAndLockPluginEditRequestArgs;
}
export const CheckAndLockPluginEdit__ArgsCodec: thrift.IStructCodec<ICheckAndLockPluginEdit__ArgsArgs, ICheckAndLockPluginEdit__Args> = {
    encode(args: ICheckAndLockPluginEdit__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("CheckAndLockPluginEdit__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            CheckAndLockPluginEditRequest.CheckAndLockPluginEditRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICheckAndLockPluginEdit__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_19: CheckAndLockPluginEditRequest.ICheckAndLockPluginEditRequest = CheckAndLockPluginEditRequest.CheckAndLockPluginEditRequestCodec.decode(input);
                        _args.request = value_19;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CheckAndLockPluginEdit__Args from input");
        }
    }
};
export class CheckAndLockPluginEdit__Args extends thrift.StructLike implements ICheckAndLockPluginEdit__Args {
    public request: CheckAndLockPluginEditRequest.ICheckAndLockPluginEditRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ICheckAndLockPluginEdit__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_20: CheckAndLockPluginEditRequest.ICheckAndLockPluginEditRequest = new CheckAndLockPluginEditRequest.CheckAndLockPluginEditRequest(args.request);
            this.request = value_20;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): CheckAndLockPluginEdit__Args {
        return new CheckAndLockPluginEdit__Args(CheckAndLockPluginEdit__ArgsCodec.decode(input));
    }
    public static write(args: ICheckAndLockPluginEdit__ArgsArgs, output: thrift.TProtocol): void {
        return CheckAndLockPluginEdit__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CheckAndLockPluginEdit__ArgsCodec.encode(this, output);
    }
}
export interface IUnlockPluginEdit__Args {
    request: UnlockPluginEditRequest.IUnlockPluginEditRequest;
}
export interface IUnlockPluginEdit__ArgsArgs {
    request: UnlockPluginEditRequest.IUnlockPluginEditRequestArgs;
}
export const UnlockPluginEdit__ArgsCodec: thrift.IStructCodec<IUnlockPluginEdit__ArgsArgs, IUnlockPluginEdit__Args> = {
    encode(args: IUnlockPluginEdit__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("UnlockPluginEdit__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            UnlockPluginEditRequest.UnlockPluginEditRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUnlockPluginEdit__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_21: UnlockPluginEditRequest.IUnlockPluginEditRequest = UnlockPluginEditRequest.UnlockPluginEditRequestCodec.decode(input);
                        _args.request = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UnlockPluginEdit__Args from input");
        }
    }
};
export class UnlockPluginEdit__Args extends thrift.StructLike implements IUnlockPluginEdit__Args {
    public request: UnlockPluginEditRequest.IUnlockPluginEditRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUnlockPluginEdit__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_22: UnlockPluginEditRequest.IUnlockPluginEditRequest = new UnlockPluginEditRequest.UnlockPluginEditRequest(args.request);
            this.request = value_22;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): UnlockPluginEdit__Args {
        return new UnlockPluginEdit__Args(UnlockPluginEdit__ArgsCodec.decode(input));
    }
    public static write(args: IUnlockPluginEdit__ArgsArgs, output: thrift.TProtocol): void {
        return UnlockPluginEdit__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UnlockPluginEdit__ArgsCodec.encode(this, output);
    }
}
export interface IUpdatePlugin__Args {
    request: UpdatePluginRequest.IUpdatePluginRequest;
}
export interface IUpdatePlugin__ArgsArgs {
    request: UpdatePluginRequest.IUpdatePluginRequestArgs;
}
export const UpdatePlugin__ArgsCodec: thrift.IStructCodec<IUpdatePlugin__ArgsArgs, IUpdatePlugin__Args> = {
    encode(args: IUpdatePlugin__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("UpdatePlugin__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            UpdatePluginRequest.UpdatePluginRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdatePlugin__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_23: UpdatePluginRequest.IUpdatePluginRequest = UpdatePluginRequest.UpdatePluginRequestCodec.decode(input);
                        _args.request = value_23;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdatePlugin__Args from input");
        }
    }
};
export class UpdatePlugin__Args extends thrift.StructLike implements IUpdatePlugin__Args {
    public request: UpdatePluginRequest.IUpdatePluginRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdatePlugin__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_24: UpdatePluginRequest.IUpdatePluginRequest = new UpdatePluginRequest.UpdatePluginRequest(args.request);
            this.request = value_24;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): UpdatePlugin__Args {
        return new UpdatePlugin__Args(UpdatePlugin__ArgsCodec.decode(input));
    }
    public static write(args: IUpdatePlugin__ArgsArgs, output: thrift.TProtocol): void {
        return UpdatePlugin__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdatePlugin__ArgsCodec.encode(this, output);
    }
}
export interface IDeleteAPI__Args {
    request: DeleteAPIRequest.IDeleteAPIRequest;
}
export interface IDeleteAPI__ArgsArgs {
    request: DeleteAPIRequest.IDeleteAPIRequestArgs;
}
export const DeleteAPI__ArgsCodec: thrift.IStructCodec<IDeleteAPI__ArgsArgs, IDeleteAPI__Args> = {
    encode(args: IDeleteAPI__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("DeleteAPI__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            DeleteAPIRequest.DeleteAPIRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDeleteAPI__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_25: DeleteAPIRequest.IDeleteAPIRequest = DeleteAPIRequest.DeleteAPIRequestCodec.decode(input);
                        _args.request = value_25;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteAPI__Args from input");
        }
    }
};
export class DeleteAPI__Args extends thrift.StructLike implements IDeleteAPI__Args {
    public request: DeleteAPIRequest.IDeleteAPIRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDeleteAPI__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_26: DeleteAPIRequest.IDeleteAPIRequest = new DeleteAPIRequest.DeleteAPIRequest(args.request);
            this.request = value_26;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): DeleteAPI__Args {
        return new DeleteAPI__Args(DeleteAPI__ArgsCodec.decode(input));
    }
    public static write(args: IDeleteAPI__ArgsArgs, output: thrift.TProtocol): void {
        return DeleteAPI__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DeleteAPI__ArgsCodec.encode(this, output);
    }
}
export interface IDelPlugin__Args {
    request: DelPluginRequest.IDelPluginRequest;
}
export interface IDelPlugin__ArgsArgs {
    request: DelPluginRequest.IDelPluginRequestArgs;
}
export const DelPlugin__ArgsCodec: thrift.IStructCodec<IDelPlugin__ArgsArgs, IDelPlugin__Args> = {
    encode(args: IDelPlugin__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("DelPlugin__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            DelPluginRequest.DelPluginRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDelPlugin__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_27: DelPluginRequest.IDelPluginRequest = DelPluginRequest.DelPluginRequestCodec.decode(input);
                        _args.request = value_27;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DelPlugin__Args from input");
        }
    }
};
export class DelPlugin__Args extends thrift.StructLike implements IDelPlugin__Args {
    public request: DelPluginRequest.IDelPluginRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDelPlugin__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_28: DelPluginRequest.IDelPluginRequest = new DelPluginRequest.DelPluginRequest(args.request);
            this.request = value_28;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): DelPlugin__Args {
        return new DelPlugin__Args(DelPlugin__ArgsCodec.decode(input));
    }
    public static write(args: IDelPlugin__ArgsArgs, output: thrift.TProtocol): void {
        return DelPlugin__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DelPlugin__ArgsCodec.encode(this, output);
    }
}
export interface IPublishPlugin__Args {
    request: PublishPluginRequest.IPublishPluginRequest;
}
export interface IPublishPlugin__ArgsArgs {
    request: PublishPluginRequest.IPublishPluginRequestArgs;
}
export const PublishPlugin__ArgsCodec: thrift.IStructCodec<IPublishPlugin__ArgsArgs, IPublishPlugin__Args> = {
    encode(args: IPublishPlugin__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("PublishPlugin__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            PublishPluginRequest.PublishPluginRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IPublishPlugin__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_29: PublishPluginRequest.IPublishPluginRequest = PublishPluginRequest.PublishPluginRequestCodec.decode(input);
                        _args.request = value_29;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PublishPlugin__Args from input");
        }
    }
};
export class PublishPlugin__Args extends thrift.StructLike implements IPublishPlugin__Args {
    public request: PublishPluginRequest.IPublishPluginRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IPublishPlugin__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_30: PublishPluginRequest.IPublishPluginRequest = new PublishPluginRequest.PublishPluginRequest(args.request);
            this.request = value_30;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): PublishPlugin__Args {
        return new PublishPlugin__Args(PublishPlugin__ArgsCodec.decode(input));
    }
    public static write(args: IPublishPlugin__ArgsArgs, output: thrift.TProtocol): void {
        return PublishPlugin__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return PublishPlugin__ArgsCodec.encode(this, output);
    }
}
export interface IUpdatePluginMeta__Args {
    request: UpdatePluginMetaRequest.IUpdatePluginMetaRequest;
}
export interface IUpdatePluginMeta__ArgsArgs {
    request: UpdatePluginMetaRequest.IUpdatePluginMetaRequestArgs;
}
export const UpdatePluginMeta__ArgsCodec: thrift.IStructCodec<IUpdatePluginMeta__ArgsArgs, IUpdatePluginMeta__Args> = {
    encode(args: IUpdatePluginMeta__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("UpdatePluginMeta__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            UpdatePluginMetaRequest.UpdatePluginMetaRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdatePluginMeta__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_31: UpdatePluginMetaRequest.IUpdatePluginMetaRequest = UpdatePluginMetaRequest.UpdatePluginMetaRequestCodec.decode(input);
                        _args.request = value_31;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdatePluginMeta__Args from input");
        }
    }
};
export class UpdatePluginMeta__Args extends thrift.StructLike implements IUpdatePluginMeta__Args {
    public request: UpdatePluginMetaRequest.IUpdatePluginMetaRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdatePluginMeta__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_32: UpdatePluginMetaRequest.IUpdatePluginMetaRequest = new UpdatePluginMetaRequest.UpdatePluginMetaRequest(args.request);
            this.request = value_32;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): UpdatePluginMeta__Args {
        return new UpdatePluginMeta__Args(UpdatePluginMeta__ArgsCodec.decode(input));
    }
    public static write(args: IUpdatePluginMeta__ArgsArgs, output: thrift.TProtocol): void {
        return UpdatePluginMeta__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdatePluginMeta__ArgsCodec.encode(this, output);
    }
}
export interface IGetBotDefaultParams__Args {
    request: GetBotDefaultParamsRequest.IGetBotDefaultParamsRequest;
}
export interface IGetBotDefaultParams__ArgsArgs {
    request: GetBotDefaultParamsRequest.IGetBotDefaultParamsRequestArgs;
}
export const GetBotDefaultParams__ArgsCodec: thrift.IStructCodec<IGetBotDefaultParams__ArgsArgs, IGetBotDefaultParams__Args> = {
    encode(args: IGetBotDefaultParams__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetBotDefaultParams__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetBotDefaultParamsRequest.GetBotDefaultParamsRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetBotDefaultParams__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_33: GetBotDefaultParamsRequest.IGetBotDefaultParamsRequest = GetBotDefaultParamsRequest.GetBotDefaultParamsRequestCodec.decode(input);
                        _args.request = value_33;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetBotDefaultParams__Args from input");
        }
    }
};
export class GetBotDefaultParams__Args extends thrift.StructLike implements IGetBotDefaultParams__Args {
    public request: GetBotDefaultParamsRequest.IGetBotDefaultParamsRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetBotDefaultParams__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_34: GetBotDefaultParamsRequest.IGetBotDefaultParamsRequest = new GetBotDefaultParamsRequest.GetBotDefaultParamsRequest(args.request);
            this.request = value_34;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetBotDefaultParams__Args {
        return new GetBotDefaultParams__Args(GetBotDefaultParams__ArgsCodec.decode(input));
    }
    public static write(args: IGetBotDefaultParams__ArgsArgs, output: thrift.TProtocol): void {
        return GetBotDefaultParams__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetBotDefaultParams__ArgsCodec.encode(this, output);
    }
}
export interface IUpdateBotDefaultParams__Args {
    request: UpdateBotDefaultParamsRequest.IUpdateBotDefaultParamsRequest;
}
export interface IUpdateBotDefaultParams__ArgsArgs {
    request: UpdateBotDefaultParamsRequest.IUpdateBotDefaultParamsRequestArgs;
}
export const UpdateBotDefaultParams__ArgsCodec: thrift.IStructCodec<IUpdateBotDefaultParams__ArgsArgs, IUpdateBotDefaultParams__Args> = {
    encode(args: IUpdateBotDefaultParams__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("UpdateBotDefaultParams__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            UpdateBotDefaultParamsRequest.UpdateBotDefaultParamsRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateBotDefaultParams__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_35: UpdateBotDefaultParamsRequest.IUpdateBotDefaultParamsRequest = UpdateBotDefaultParamsRequest.UpdateBotDefaultParamsRequestCodec.decode(input);
                        _args.request = value_35;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateBotDefaultParams__Args from input");
        }
    }
};
export class UpdateBotDefaultParams__Args extends thrift.StructLike implements IUpdateBotDefaultParams__Args {
    public request: UpdateBotDefaultParamsRequest.IUpdateBotDefaultParamsRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateBotDefaultParams__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_36: UpdateBotDefaultParamsRequest.IUpdateBotDefaultParamsRequest = new UpdateBotDefaultParamsRequest.UpdateBotDefaultParamsRequest(args.request);
            this.request = value_36;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): UpdateBotDefaultParams__Args {
        return new UpdateBotDefaultParams__Args(UpdateBotDefaultParams__ArgsCodec.decode(input));
    }
    public static write(args: IUpdateBotDefaultParams__ArgsArgs, output: thrift.TProtocol): void {
        return UpdateBotDefaultParams__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateBotDefaultParams__ArgsCodec.encode(this, output);
    }
}
export interface ICreateAPI__Args {
    request: CreateAPIRequest.ICreateAPIRequest;
}
export interface ICreateAPI__ArgsArgs {
    request: CreateAPIRequest.ICreateAPIRequestArgs;
}
export const CreateAPI__ArgsCodec: thrift.IStructCodec<ICreateAPI__ArgsArgs, ICreateAPI__Args> = {
    encode(args: ICreateAPI__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("CreateAPI__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            CreateAPIRequest.CreateAPIRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICreateAPI__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_37: CreateAPIRequest.ICreateAPIRequest = CreateAPIRequest.CreateAPIRequestCodec.decode(input);
                        _args.request = value_37;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateAPI__Args from input");
        }
    }
};
export class CreateAPI__Args extends thrift.StructLike implements ICreateAPI__Args {
    public request: CreateAPIRequest.ICreateAPIRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ICreateAPI__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_38: CreateAPIRequest.ICreateAPIRequest = new CreateAPIRequest.CreateAPIRequest(args.request);
            this.request = value_38;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): CreateAPI__Args {
        return new CreateAPI__Args(CreateAPI__ArgsCodec.decode(input));
    }
    public static write(args: ICreateAPI__ArgsArgs, output: thrift.TProtocol): void {
        return CreateAPI__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CreateAPI__ArgsCodec.encode(this, output);
    }
}
export interface IUpdateAPI__Args {
    request: UpdateAPIRequest.IUpdateAPIRequest;
}
export interface IUpdateAPI__ArgsArgs {
    request: UpdateAPIRequest.IUpdateAPIRequestArgs;
}
export const UpdateAPI__ArgsCodec: thrift.IStructCodec<IUpdateAPI__ArgsArgs, IUpdateAPI__Args> = {
    encode(args: IUpdateAPI__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("UpdateAPI__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            UpdateAPIRequest.UpdateAPIRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateAPI__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_39: UpdateAPIRequest.IUpdateAPIRequest = UpdateAPIRequest.UpdateAPIRequestCodec.decode(input);
                        _args.request = value_39;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateAPI__Args from input");
        }
    }
};
export class UpdateAPI__Args extends thrift.StructLike implements IUpdateAPI__Args {
    public request: UpdateAPIRequest.IUpdateAPIRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateAPI__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_40: UpdateAPIRequest.IUpdateAPIRequest = new UpdateAPIRequest.UpdateAPIRequest(args.request);
            this.request = value_40;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): UpdateAPI__Args {
        return new UpdateAPI__Args(UpdateAPI__ArgsCodec.decode(input));
    }
    public static write(args: IUpdateAPI__ArgsArgs, output: thrift.TProtocol): void {
        return UpdateAPI__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateAPI__ArgsCodec.encode(this, output);
    }
}
export interface IGetUserAuthority__Args {
    request: GetUserAuthorityRequest.IGetUserAuthorityRequest;
}
export interface IGetUserAuthority__ArgsArgs {
    request: GetUserAuthorityRequest.IGetUserAuthorityRequestArgs;
}
export const GetUserAuthority__ArgsCodec: thrift.IStructCodec<IGetUserAuthority__ArgsArgs, IGetUserAuthority__Args> = {
    encode(args: IGetUserAuthority__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetUserAuthority__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetUserAuthorityRequest.GetUserAuthorityRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetUserAuthority__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_41: GetUserAuthorityRequest.IGetUserAuthorityRequest = GetUserAuthorityRequest.GetUserAuthorityRequestCodec.decode(input);
                        _args.request = value_41;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetUserAuthority__Args from input");
        }
    }
};
export class GetUserAuthority__Args extends thrift.StructLike implements IGetUserAuthority__Args {
    public request: GetUserAuthorityRequest.IGetUserAuthorityRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetUserAuthority__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_42: GetUserAuthorityRequest.IGetUserAuthorityRequest = new GetUserAuthorityRequest.GetUserAuthorityRequest(args.request);
            this.request = value_42;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetUserAuthority__Args {
        return new GetUserAuthority__Args(GetUserAuthority__ArgsCodec.decode(input));
    }
    public static write(args: IGetUserAuthority__ArgsArgs, output: thrift.TProtocol): void {
        return GetUserAuthority__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetUserAuthority__ArgsCodec.encode(this, output);
    }
}
export interface IDebugAPI__Args {
    request: DebugAPIRequest.IDebugAPIRequest;
}
export interface IDebugAPI__ArgsArgs {
    request: DebugAPIRequest.IDebugAPIRequestArgs;
}
export const DebugAPI__ArgsCodec: thrift.IStructCodec<IDebugAPI__ArgsArgs, IDebugAPI__Args> = {
    encode(args: IDebugAPI__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("DebugAPI__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            DebugAPIRequest.DebugAPIRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDebugAPI__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_43: DebugAPIRequest.IDebugAPIRequest = DebugAPIRequest.DebugAPIRequestCodec.decode(input);
                        _args.request = value_43;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DebugAPI__Args from input");
        }
    }
};
export class DebugAPI__Args extends thrift.StructLike implements IDebugAPI__Args {
    public request: DebugAPIRequest.IDebugAPIRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDebugAPI__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_44: DebugAPIRequest.IDebugAPIRequest = new DebugAPIRequest.DebugAPIRequest(args.request);
            this.request = value_44;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): DebugAPI__Args {
        return new DebugAPI__Args(DebugAPI__ArgsCodec.decode(input));
    }
    public static write(args: IDebugAPI__ArgsArgs, output: thrift.TProtocol): void {
        return DebugAPI__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DebugAPI__ArgsCodec.encode(this, output);
    }
}
export interface IGetPluginNextVersion__Args {
    request: GetPluginNextVersionRequest.IGetPluginNextVersionRequest;
}
export interface IGetPluginNextVersion__ArgsArgs {
    request: GetPluginNextVersionRequest.IGetPluginNextVersionRequestArgs;
}
export const GetPluginNextVersion__ArgsCodec: thrift.IStructCodec<IGetPluginNextVersion__ArgsArgs, IGetPluginNextVersion__Args> = {
    encode(args: IGetPluginNextVersion__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetPluginNextVersion__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetPluginNextVersionRequest.GetPluginNextVersionRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetPluginNextVersion__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_45: GetPluginNextVersionRequest.IGetPluginNextVersionRequest = GetPluginNextVersionRequest.GetPluginNextVersionRequestCodec.decode(input);
                        _args.request = value_45;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetPluginNextVersion__Args from input");
        }
    }
};
export class GetPluginNextVersion__Args extends thrift.StructLike implements IGetPluginNextVersion__Args {
    public request: GetPluginNextVersionRequest.IGetPluginNextVersionRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetPluginNextVersion__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_46: GetPluginNextVersionRequest.IGetPluginNextVersionRequest = new GetPluginNextVersionRequest.GetPluginNextVersionRequest(args.request);
            this.request = value_46;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetPluginNextVersion__Args {
        return new GetPluginNextVersion__Args(GetPluginNextVersion__ArgsCodec.decode(input));
    }
    public static write(args: IGetPluginNextVersion__ArgsArgs, output: thrift.TProtocol): void {
        return GetPluginNextVersion__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetPluginNextVersion__ArgsCodec.encode(this, output);
    }
}
export interface IGetDevPluginList__Args {
    request: GetDevPluginListRequest.IGetDevPluginListRequest;
}
export interface IGetDevPluginList__ArgsArgs {
    request: GetDevPluginListRequest.IGetDevPluginListRequestArgs;
}
export const GetDevPluginList__ArgsCodec: thrift.IStructCodec<IGetDevPluginList__ArgsArgs, IGetDevPluginList__Args> = {
    encode(args: IGetDevPluginList__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetDevPluginList__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetDevPluginListRequest.GetDevPluginListRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetDevPluginList__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_47: GetDevPluginListRequest.IGetDevPluginListRequest = GetDevPluginListRequest.GetDevPluginListRequestCodec.decode(input);
                        _args.request = value_47;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDevPluginList__Args from input");
        }
    }
};
export class GetDevPluginList__Args extends thrift.StructLike implements IGetDevPluginList__Args {
    public request: GetDevPluginListRequest.IGetDevPluginListRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetDevPluginList__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_48: GetDevPluginListRequest.IGetDevPluginListRequest = new GetDevPluginListRequest.GetDevPluginListRequest(args.request);
            this.request = value_48;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetDevPluginList__Args {
        return new GetDevPluginList__Args(GetDevPluginList__ArgsCodec.decode(input));
    }
    public static write(args: IGetDevPluginList__ArgsArgs, output: thrift.TProtocol): void {
        return GetDevPluginList__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetDevPluginList__ArgsCodec.encode(this, output);
    }
}
export interface IConvert2OpenAPI__Args {
    request: Convert2OpenAPIRequest.IConvert2OpenAPIRequest;
}
export interface IConvert2OpenAPI__ArgsArgs {
    request: Convert2OpenAPIRequest.IConvert2OpenAPIRequestArgs;
}
export const Convert2OpenAPI__ArgsCodec: thrift.IStructCodec<IConvert2OpenAPI__ArgsArgs, IConvert2OpenAPI__Args> = {
    encode(args: IConvert2OpenAPI__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("Convert2OpenAPI__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            Convert2OpenAPIRequest.Convert2OpenAPIRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IConvert2OpenAPI__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_49: Convert2OpenAPIRequest.IConvert2OpenAPIRequest = Convert2OpenAPIRequest.Convert2OpenAPIRequestCodec.decode(input);
                        _args.request = value_49;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read Convert2OpenAPI__Args from input");
        }
    }
};
export class Convert2OpenAPI__Args extends thrift.StructLike implements IConvert2OpenAPI__Args {
    public request: Convert2OpenAPIRequest.IConvert2OpenAPIRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IConvert2OpenAPI__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_50: Convert2OpenAPIRequest.IConvert2OpenAPIRequest = new Convert2OpenAPIRequest.Convert2OpenAPIRequest(args.request);
            this.request = value_50;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): Convert2OpenAPI__Args {
        return new Convert2OpenAPI__Args(Convert2OpenAPI__ArgsCodec.decode(input));
    }
    public static write(args: IConvert2OpenAPI__ArgsArgs, output: thrift.TProtocol): void {
        return Convert2OpenAPI__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return Convert2OpenAPI__ArgsCodec.encode(this, output);
    }
}
export interface IBatchCreateAPI__Args {
    request: BatchCreateAPIRequest.IBatchCreateAPIRequest;
}
export interface IBatchCreateAPI__ArgsArgs {
    request: BatchCreateAPIRequest.IBatchCreateAPIRequestArgs;
}
export const BatchCreateAPI__ArgsCodec: thrift.IStructCodec<IBatchCreateAPI__ArgsArgs, IBatchCreateAPI__Args> = {
    encode(args: IBatchCreateAPI__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("BatchCreateAPI__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            BatchCreateAPIRequest.BatchCreateAPIRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IBatchCreateAPI__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_51: BatchCreateAPIRequest.IBatchCreateAPIRequest = BatchCreateAPIRequest.BatchCreateAPIRequestCodec.decode(input);
                        _args.request = value_51;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read BatchCreateAPI__Args from input");
        }
    }
};
export class BatchCreateAPI__Args extends thrift.StructLike implements IBatchCreateAPI__Args {
    public request: BatchCreateAPIRequest.IBatchCreateAPIRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IBatchCreateAPI__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_52: BatchCreateAPIRequest.IBatchCreateAPIRequest = new BatchCreateAPIRequest.BatchCreateAPIRequest(args.request);
            this.request = value_52;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): BatchCreateAPI__Args {
        return new BatchCreateAPI__Args(BatchCreateAPI__ArgsCodec.decode(input));
    }
    public static write(args: IBatchCreateAPI__ArgsArgs, output: thrift.TProtocol): void {
        return BatchCreateAPI__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return BatchCreateAPI__ArgsCodec.encode(this, output);
    }
}
export interface IRevokeAuthToken__Args {
    request: RevokeAuthTokenRequest.IRevokeAuthTokenRequest;
}
export interface IRevokeAuthToken__ArgsArgs {
    request: RevokeAuthTokenRequest.IRevokeAuthTokenRequestArgs;
}
export const RevokeAuthToken__ArgsCodec: thrift.IStructCodec<IRevokeAuthToken__ArgsArgs, IRevokeAuthToken__Args> = {
    encode(args: IRevokeAuthToken__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("RevokeAuthToken__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            RevokeAuthTokenRequest.RevokeAuthTokenRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IRevokeAuthToken__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_53: RevokeAuthTokenRequest.IRevokeAuthTokenRequest = RevokeAuthTokenRequest.RevokeAuthTokenRequestCodec.decode(input);
                        _args.request = value_53;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RevokeAuthToken__Args from input");
        }
    }
};
export class RevokeAuthToken__Args extends thrift.StructLike implements IRevokeAuthToken__Args {
    public request: RevokeAuthTokenRequest.IRevokeAuthTokenRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IRevokeAuthToken__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_54: RevokeAuthTokenRequest.IRevokeAuthTokenRequest = new RevokeAuthTokenRequest.RevokeAuthTokenRequest(args.request);
            this.request = value_54;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): RevokeAuthToken__Args {
        return new RevokeAuthToken__Args(RevokeAuthToken__ArgsCodec.decode(input));
    }
    public static write(args: IRevokeAuthToken__ArgsArgs, output: thrift.TProtocol): void {
        return RevokeAuthToken__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return RevokeAuthToken__ArgsCodec.encode(this, output);
    }
}
export interface IGetQueriedOAuthPluginList__Args {
    request: GetQueriedOAuthPluginListRequest.IGetQueriedOAuthPluginListRequest;
}
export interface IGetQueriedOAuthPluginList__ArgsArgs {
    request: GetQueriedOAuthPluginListRequest.IGetQueriedOAuthPluginListRequestArgs;
}
export const GetQueriedOAuthPluginList__ArgsCodec: thrift.IStructCodec<IGetQueriedOAuthPluginList__ArgsArgs, IGetQueriedOAuthPluginList__Args> = {
    encode(args: IGetQueriedOAuthPluginList__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetQueriedOAuthPluginList__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetQueriedOAuthPluginListRequest.GetQueriedOAuthPluginListRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetQueriedOAuthPluginList__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_55: GetQueriedOAuthPluginListRequest.IGetQueriedOAuthPluginListRequest = GetQueriedOAuthPluginListRequest.GetQueriedOAuthPluginListRequestCodec.decode(input);
                        _args.request = value_55;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetQueriedOAuthPluginList__Args from input");
        }
    }
};
export class GetQueriedOAuthPluginList__Args extends thrift.StructLike implements IGetQueriedOAuthPluginList__Args {
    public request: GetQueriedOAuthPluginListRequest.IGetQueriedOAuthPluginListRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetQueriedOAuthPluginList__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_56: GetQueriedOAuthPluginListRequest.IGetQueriedOAuthPluginListRequest = new GetQueriedOAuthPluginListRequest.GetQueriedOAuthPluginListRequest(args.request);
            this.request = value_56;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetQueriedOAuthPluginList__Args {
        return new GetQueriedOAuthPluginList__Args(GetQueriedOAuthPluginList__ArgsCodec.decode(input));
    }
    public static write(args: IGetQueriedOAuthPluginList__ArgsArgs, output: thrift.TProtocol): void {
        return GetQueriedOAuthPluginList__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetQueriedOAuthPluginList__ArgsCodec.encode(this, output);
    }
}
export interface IGetOAuthSchema__Result {
    success?: GetOAuthSchemaResponse.IGetOAuthSchemaResponse;
}
export interface IGetOAuthSchema__ResultArgs {
    success?: GetOAuthSchemaResponse.IGetOAuthSchemaResponseArgs;
}
export const GetOAuthSchema__ResultCodec: thrift.IStructCodec<IGetOAuthSchema__ResultArgs, IGetOAuthSchema__Result> = {
    encode(args: IGetOAuthSchema__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetOAuthSchema__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetOAuthSchemaResponse.GetOAuthSchemaResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetOAuthSchema__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_57: GetOAuthSchemaResponse.IGetOAuthSchemaResponse = GetOAuthSchemaResponse.GetOAuthSchemaResponseCodec.decode(input);
                        _args.success = value_57;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetOAuthSchema__Result extends thrift.StructLike implements IGetOAuthSchema__Result {
    public success?: GetOAuthSchemaResponse.IGetOAuthSchemaResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetOAuthSchema__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_58: GetOAuthSchemaResponse.IGetOAuthSchemaResponse = new GetOAuthSchemaResponse.GetOAuthSchemaResponse(args.success);
            this.success = value_58;
        }
    }
    public static read(input: thrift.TProtocol): GetOAuthSchema__Result {
        return new GetOAuthSchema__Result(GetOAuthSchema__ResultCodec.decode(input));
    }
    public static write(args: IGetOAuthSchema__ResultArgs, output: thrift.TProtocol): void {
        return GetOAuthSchema__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetOAuthSchema__ResultCodec.encode(this, output);
    }
}
export interface IGetOAuthSchemaAPI__Result {
    success?: GetOAuthSchemaResponse.IGetOAuthSchemaResponse;
}
export interface IGetOAuthSchemaAPI__ResultArgs {
    success?: GetOAuthSchemaResponse.IGetOAuthSchemaResponseArgs;
}
export const GetOAuthSchemaAPI__ResultCodec: thrift.IStructCodec<IGetOAuthSchemaAPI__ResultArgs, IGetOAuthSchemaAPI__Result> = {
    encode(args: IGetOAuthSchemaAPI__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetOAuthSchemaAPI__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetOAuthSchemaResponse.GetOAuthSchemaResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetOAuthSchemaAPI__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_59: GetOAuthSchemaResponse.IGetOAuthSchemaResponse = GetOAuthSchemaResponse.GetOAuthSchemaResponseCodec.decode(input);
                        _args.success = value_59;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetOAuthSchemaAPI__Result extends thrift.StructLike implements IGetOAuthSchemaAPI__Result {
    public success?: GetOAuthSchemaResponse.IGetOAuthSchemaResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetOAuthSchemaAPI__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_60: GetOAuthSchemaResponse.IGetOAuthSchemaResponse = new GetOAuthSchemaResponse.GetOAuthSchemaResponse(args.success);
            this.success = value_60;
        }
    }
    public static read(input: thrift.TProtocol): GetOAuthSchemaAPI__Result {
        return new GetOAuthSchemaAPI__Result(GetOAuthSchemaAPI__ResultCodec.decode(input));
    }
    public static write(args: IGetOAuthSchemaAPI__ResultArgs, output: thrift.TProtocol): void {
        return GetOAuthSchemaAPI__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetOAuthSchemaAPI__ResultCodec.encode(this, output);
    }
}
export interface IGetPlaygroundPluginList__Result {
    success?: GetPlaygroundPluginListResponse.IGetPlaygroundPluginListResponse;
}
export interface IGetPlaygroundPluginList__ResultArgs {
    success?: GetPlaygroundPluginListResponse.IGetPlaygroundPluginListResponseArgs;
}
export const GetPlaygroundPluginList__ResultCodec: thrift.IStructCodec<IGetPlaygroundPluginList__ResultArgs, IGetPlaygroundPluginList__Result> = {
    encode(args: IGetPlaygroundPluginList__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetPlaygroundPluginList__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetPlaygroundPluginListResponse.GetPlaygroundPluginListResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetPlaygroundPluginList__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_61: GetPlaygroundPluginListResponse.IGetPlaygroundPluginListResponse = GetPlaygroundPluginListResponse.GetPlaygroundPluginListResponseCodec.decode(input);
                        _args.success = value_61;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetPlaygroundPluginList__Result extends thrift.StructLike implements IGetPlaygroundPluginList__Result {
    public success?: GetPlaygroundPluginListResponse.IGetPlaygroundPluginListResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetPlaygroundPluginList__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_62: GetPlaygroundPluginListResponse.IGetPlaygroundPluginListResponse = new GetPlaygroundPluginListResponse.GetPlaygroundPluginListResponse(args.success);
            this.success = value_62;
        }
    }
    public static read(input: thrift.TProtocol): GetPlaygroundPluginList__Result {
        return new GetPlaygroundPluginList__Result(GetPlaygroundPluginList__ResultCodec.decode(input));
    }
    public static write(args: IGetPlaygroundPluginList__ResultArgs, output: thrift.TProtocol): void {
        return GetPlaygroundPluginList__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetPlaygroundPluginList__ResultCodec.encode(this, output);
    }
}
export interface IRegisterPlugin__Result {
    success?: RegisterPluginResponse.IRegisterPluginResponse;
}
export interface IRegisterPlugin__ResultArgs {
    success?: RegisterPluginResponse.IRegisterPluginResponseArgs;
}
export const RegisterPlugin__ResultCodec: thrift.IStructCodec<IRegisterPlugin__ResultArgs, IRegisterPlugin__Result> = {
    encode(args: IRegisterPlugin__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("RegisterPlugin__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            RegisterPluginResponse.RegisterPluginResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IRegisterPlugin__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_63: RegisterPluginResponse.IRegisterPluginResponse = RegisterPluginResponse.RegisterPluginResponseCodec.decode(input);
                        _args.success = value_63;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class RegisterPlugin__Result extends thrift.StructLike implements IRegisterPlugin__Result {
    public success?: RegisterPluginResponse.IRegisterPluginResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IRegisterPlugin__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_64: RegisterPluginResponse.IRegisterPluginResponse = new RegisterPluginResponse.RegisterPluginResponse(args.success);
            this.success = value_64;
        }
    }
    public static read(input: thrift.TProtocol): RegisterPlugin__Result {
        return new RegisterPlugin__Result(RegisterPlugin__ResultCodec.decode(input));
    }
    public static write(args: IRegisterPlugin__ResultArgs, output: thrift.TProtocol): void {
        return RegisterPlugin__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return RegisterPlugin__ResultCodec.encode(this, output);
    }
}
export interface IRegisterPluginMeta__Result {
    success?: RegisterPluginMetaResponse.IRegisterPluginMetaResponse;
}
export interface IRegisterPluginMeta__ResultArgs {
    success?: RegisterPluginMetaResponse.IRegisterPluginMetaResponseArgs;
}
export const RegisterPluginMeta__ResultCodec: thrift.IStructCodec<IRegisterPluginMeta__ResultArgs, IRegisterPluginMeta__Result> = {
    encode(args: IRegisterPluginMeta__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("RegisterPluginMeta__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            RegisterPluginMetaResponse.RegisterPluginMetaResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IRegisterPluginMeta__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_65: RegisterPluginMetaResponse.IRegisterPluginMetaResponse = RegisterPluginMetaResponse.RegisterPluginMetaResponseCodec.decode(input);
                        _args.success = value_65;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class RegisterPluginMeta__Result extends thrift.StructLike implements IRegisterPluginMeta__Result {
    public success?: RegisterPluginMetaResponse.IRegisterPluginMetaResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IRegisterPluginMeta__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_66: RegisterPluginMetaResponse.IRegisterPluginMetaResponse = new RegisterPluginMetaResponse.RegisterPluginMetaResponse(args.success);
            this.success = value_66;
        }
    }
    public static read(input: thrift.TProtocol): RegisterPluginMeta__Result {
        return new RegisterPluginMeta__Result(RegisterPluginMeta__ResultCodec.decode(input));
    }
    public static write(args: IRegisterPluginMeta__ResultArgs, output: thrift.TProtocol): void {
        return RegisterPluginMeta__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return RegisterPluginMeta__ResultCodec.encode(this, output);
    }
}
export interface IGetPluginAPIs__Result {
    success?: GetPluginAPIsResponse.IGetPluginAPIsResponse;
}
export interface IGetPluginAPIs__ResultArgs {
    success?: GetPluginAPIsResponse.IGetPluginAPIsResponseArgs;
}
export const GetPluginAPIs__ResultCodec: thrift.IStructCodec<IGetPluginAPIs__ResultArgs, IGetPluginAPIs__Result> = {
    encode(args: IGetPluginAPIs__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetPluginAPIs__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetPluginAPIsResponse.GetPluginAPIsResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetPluginAPIs__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_67: GetPluginAPIsResponse.IGetPluginAPIsResponse = GetPluginAPIsResponse.GetPluginAPIsResponseCodec.decode(input);
                        _args.success = value_67;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetPluginAPIs__Result extends thrift.StructLike implements IGetPluginAPIs__Result {
    public success?: GetPluginAPIsResponse.IGetPluginAPIsResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetPluginAPIs__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_68: GetPluginAPIsResponse.IGetPluginAPIsResponse = new GetPluginAPIsResponse.GetPluginAPIsResponse(args.success);
            this.success = value_68;
        }
    }
    public static read(input: thrift.TProtocol): GetPluginAPIs__Result {
        return new GetPluginAPIs__Result(GetPluginAPIs__ResultCodec.decode(input));
    }
    public static write(args: IGetPluginAPIs__ResultArgs, output: thrift.TProtocol): void {
        return GetPluginAPIs__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetPluginAPIs__ResultCodec.encode(this, output);
    }
}
export interface IGetPluginInfo__Result {
    success?: GetPluginInfoResponse.IGetPluginInfoResponse;
}
export interface IGetPluginInfo__ResultArgs {
    success?: GetPluginInfoResponse.IGetPluginInfoResponseArgs;
}
export const GetPluginInfo__ResultCodec: thrift.IStructCodec<IGetPluginInfo__ResultArgs, IGetPluginInfo__Result> = {
    encode(args: IGetPluginInfo__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetPluginInfo__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetPluginInfoResponse.GetPluginInfoResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetPluginInfo__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_69: GetPluginInfoResponse.IGetPluginInfoResponse = GetPluginInfoResponse.GetPluginInfoResponseCodec.decode(input);
                        _args.success = value_69;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetPluginInfo__Result extends thrift.StructLike implements IGetPluginInfo__Result {
    public success?: GetPluginInfoResponse.IGetPluginInfoResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetPluginInfo__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_70: GetPluginInfoResponse.IGetPluginInfoResponse = new GetPluginInfoResponse.GetPluginInfoResponse(args.success);
            this.success = value_70;
        }
    }
    public static read(input: thrift.TProtocol): GetPluginInfo__Result {
        return new GetPluginInfo__Result(GetPluginInfo__ResultCodec.decode(input));
    }
    public static write(args: IGetPluginInfo__ResultArgs, output: thrift.TProtocol): void {
        return GetPluginInfo__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetPluginInfo__ResultCodec.encode(this, output);
    }
}
export interface IGetUpdatedAPIs__Result {
    success?: GetUpdatedAPIsResponse.IGetUpdatedAPIsResponse;
}
export interface IGetUpdatedAPIs__ResultArgs {
    success?: GetUpdatedAPIsResponse.IGetUpdatedAPIsResponseArgs;
}
export const GetUpdatedAPIs__ResultCodec: thrift.IStructCodec<IGetUpdatedAPIs__ResultArgs, IGetUpdatedAPIs__Result> = {
    encode(args: IGetUpdatedAPIs__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetUpdatedAPIs__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetUpdatedAPIsResponse.GetUpdatedAPIsResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetUpdatedAPIs__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_71: GetUpdatedAPIsResponse.IGetUpdatedAPIsResponse = GetUpdatedAPIsResponse.GetUpdatedAPIsResponseCodec.decode(input);
                        _args.success = value_71;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetUpdatedAPIs__Result extends thrift.StructLike implements IGetUpdatedAPIs__Result {
    public success?: GetUpdatedAPIsResponse.IGetUpdatedAPIsResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetUpdatedAPIs__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_72: GetUpdatedAPIsResponse.IGetUpdatedAPIsResponse = new GetUpdatedAPIsResponse.GetUpdatedAPIsResponse(args.success);
            this.success = value_72;
        }
    }
    public static read(input: thrift.TProtocol): GetUpdatedAPIs__Result {
        return new GetUpdatedAPIs__Result(GetUpdatedAPIs__ResultCodec.decode(input));
    }
    public static write(args: IGetUpdatedAPIs__ResultArgs, output: thrift.TProtocol): void {
        return GetUpdatedAPIs__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetUpdatedAPIs__ResultCodec.encode(this, output);
    }
}
export interface IGetOAuthStatus__Result {
    success?: GetOAuthStatusResponse.IGetOAuthStatusResponse;
}
export interface IGetOAuthStatus__ResultArgs {
    success?: GetOAuthStatusResponse.IGetOAuthStatusResponseArgs;
}
export const GetOAuthStatus__ResultCodec: thrift.IStructCodec<IGetOAuthStatus__ResultArgs, IGetOAuthStatus__Result> = {
    encode(args: IGetOAuthStatus__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetOAuthStatus__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetOAuthStatusResponse.GetOAuthStatusResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetOAuthStatus__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_73: GetOAuthStatusResponse.IGetOAuthStatusResponse = GetOAuthStatusResponse.GetOAuthStatusResponseCodec.decode(input);
                        _args.success = value_73;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetOAuthStatus__Result extends thrift.StructLike implements IGetOAuthStatus__Result {
    public success?: GetOAuthStatusResponse.IGetOAuthStatusResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetOAuthStatus__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_74: GetOAuthStatusResponse.IGetOAuthStatusResponse = new GetOAuthStatusResponse.GetOAuthStatusResponse(args.success);
            this.success = value_74;
        }
    }
    public static read(input: thrift.TProtocol): GetOAuthStatus__Result {
        return new GetOAuthStatus__Result(GetOAuthStatus__ResultCodec.decode(input));
    }
    public static write(args: IGetOAuthStatus__ResultArgs, output: thrift.TProtocol): void {
        return GetOAuthStatus__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetOAuthStatus__ResultCodec.encode(this, output);
    }
}
export interface ICheckAndLockPluginEdit__Result {
    success?: CheckAndLockPluginEditResponse.ICheckAndLockPluginEditResponse;
}
export interface ICheckAndLockPluginEdit__ResultArgs {
    success?: CheckAndLockPluginEditResponse.ICheckAndLockPluginEditResponseArgs;
}
export const CheckAndLockPluginEdit__ResultCodec: thrift.IStructCodec<ICheckAndLockPluginEdit__ResultArgs, ICheckAndLockPluginEdit__Result> = {
    encode(args: ICheckAndLockPluginEdit__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("CheckAndLockPluginEdit__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            CheckAndLockPluginEditResponse.CheckAndLockPluginEditResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICheckAndLockPluginEdit__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_75: CheckAndLockPluginEditResponse.ICheckAndLockPluginEditResponse = CheckAndLockPluginEditResponse.CheckAndLockPluginEditResponseCodec.decode(input);
                        _args.success = value_75;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class CheckAndLockPluginEdit__Result extends thrift.StructLike implements ICheckAndLockPluginEdit__Result {
    public success?: CheckAndLockPluginEditResponse.ICheckAndLockPluginEditResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ICheckAndLockPluginEdit__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_76: CheckAndLockPluginEditResponse.ICheckAndLockPluginEditResponse = new CheckAndLockPluginEditResponse.CheckAndLockPluginEditResponse(args.success);
            this.success = value_76;
        }
    }
    public static read(input: thrift.TProtocol): CheckAndLockPluginEdit__Result {
        return new CheckAndLockPluginEdit__Result(CheckAndLockPluginEdit__ResultCodec.decode(input));
    }
    public static write(args: ICheckAndLockPluginEdit__ResultArgs, output: thrift.TProtocol): void {
        return CheckAndLockPluginEdit__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CheckAndLockPluginEdit__ResultCodec.encode(this, output);
    }
}
export interface IUnlockPluginEdit__Result {
    success?: UnlockPluginEditResponse.IUnlockPluginEditResponse;
}
export interface IUnlockPluginEdit__ResultArgs {
    success?: UnlockPluginEditResponse.IUnlockPluginEditResponseArgs;
}
export const UnlockPluginEdit__ResultCodec: thrift.IStructCodec<IUnlockPluginEdit__ResultArgs, IUnlockPluginEdit__Result> = {
    encode(args: IUnlockPluginEdit__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("UnlockPluginEdit__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            UnlockPluginEditResponse.UnlockPluginEditResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUnlockPluginEdit__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_77: UnlockPluginEditResponse.IUnlockPluginEditResponse = UnlockPluginEditResponse.UnlockPluginEditResponseCodec.decode(input);
                        _args.success = value_77;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class UnlockPluginEdit__Result extends thrift.StructLike implements IUnlockPluginEdit__Result {
    public success?: UnlockPluginEditResponse.IUnlockPluginEditResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUnlockPluginEdit__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_78: UnlockPluginEditResponse.IUnlockPluginEditResponse = new UnlockPluginEditResponse.UnlockPluginEditResponse(args.success);
            this.success = value_78;
        }
    }
    public static read(input: thrift.TProtocol): UnlockPluginEdit__Result {
        return new UnlockPluginEdit__Result(UnlockPluginEdit__ResultCodec.decode(input));
    }
    public static write(args: IUnlockPluginEdit__ResultArgs, output: thrift.TProtocol): void {
        return UnlockPluginEdit__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UnlockPluginEdit__ResultCodec.encode(this, output);
    }
}
export interface IUpdatePlugin__Result {
    success?: UpdatePluginResponse.IUpdatePluginResponse;
}
export interface IUpdatePlugin__ResultArgs {
    success?: UpdatePluginResponse.IUpdatePluginResponseArgs;
}
export const UpdatePlugin__ResultCodec: thrift.IStructCodec<IUpdatePlugin__ResultArgs, IUpdatePlugin__Result> = {
    encode(args: IUpdatePlugin__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("UpdatePlugin__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            UpdatePluginResponse.UpdatePluginResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdatePlugin__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_79: UpdatePluginResponse.IUpdatePluginResponse = UpdatePluginResponse.UpdatePluginResponseCodec.decode(input);
                        _args.success = value_79;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class UpdatePlugin__Result extends thrift.StructLike implements IUpdatePlugin__Result {
    public success?: UpdatePluginResponse.IUpdatePluginResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdatePlugin__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_80: UpdatePluginResponse.IUpdatePluginResponse = new UpdatePluginResponse.UpdatePluginResponse(args.success);
            this.success = value_80;
        }
    }
    public static read(input: thrift.TProtocol): UpdatePlugin__Result {
        return new UpdatePlugin__Result(UpdatePlugin__ResultCodec.decode(input));
    }
    public static write(args: IUpdatePlugin__ResultArgs, output: thrift.TProtocol): void {
        return UpdatePlugin__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdatePlugin__ResultCodec.encode(this, output);
    }
}
export interface IDeleteAPI__Result {
    success?: DeleteAPIResponse.IDeleteAPIResponse;
}
export interface IDeleteAPI__ResultArgs {
    success?: DeleteAPIResponse.IDeleteAPIResponseArgs;
}
export const DeleteAPI__ResultCodec: thrift.IStructCodec<IDeleteAPI__ResultArgs, IDeleteAPI__Result> = {
    encode(args: IDeleteAPI__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("DeleteAPI__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            DeleteAPIResponse.DeleteAPIResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDeleteAPI__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_81: DeleteAPIResponse.IDeleteAPIResponse = DeleteAPIResponse.DeleteAPIResponseCodec.decode(input);
                        _args.success = value_81;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class DeleteAPI__Result extends thrift.StructLike implements IDeleteAPI__Result {
    public success?: DeleteAPIResponse.IDeleteAPIResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDeleteAPI__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_82: DeleteAPIResponse.IDeleteAPIResponse = new DeleteAPIResponse.DeleteAPIResponse(args.success);
            this.success = value_82;
        }
    }
    public static read(input: thrift.TProtocol): DeleteAPI__Result {
        return new DeleteAPI__Result(DeleteAPI__ResultCodec.decode(input));
    }
    public static write(args: IDeleteAPI__ResultArgs, output: thrift.TProtocol): void {
        return DeleteAPI__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DeleteAPI__ResultCodec.encode(this, output);
    }
}
export interface IDelPlugin__Result {
    success?: DelPluginResponse.IDelPluginResponse;
}
export interface IDelPlugin__ResultArgs {
    success?: DelPluginResponse.IDelPluginResponseArgs;
}
export const DelPlugin__ResultCodec: thrift.IStructCodec<IDelPlugin__ResultArgs, IDelPlugin__Result> = {
    encode(args: IDelPlugin__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("DelPlugin__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            DelPluginResponse.DelPluginResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDelPlugin__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_83: DelPluginResponse.IDelPluginResponse = DelPluginResponse.DelPluginResponseCodec.decode(input);
                        _args.success = value_83;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class DelPlugin__Result extends thrift.StructLike implements IDelPlugin__Result {
    public success?: DelPluginResponse.IDelPluginResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDelPlugin__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_84: DelPluginResponse.IDelPluginResponse = new DelPluginResponse.DelPluginResponse(args.success);
            this.success = value_84;
        }
    }
    public static read(input: thrift.TProtocol): DelPlugin__Result {
        return new DelPlugin__Result(DelPlugin__ResultCodec.decode(input));
    }
    public static write(args: IDelPlugin__ResultArgs, output: thrift.TProtocol): void {
        return DelPlugin__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DelPlugin__ResultCodec.encode(this, output);
    }
}
export interface IPublishPlugin__Result {
    success?: PublishPluginResponse.IPublishPluginResponse;
}
export interface IPublishPlugin__ResultArgs {
    success?: PublishPluginResponse.IPublishPluginResponseArgs;
}
export const PublishPlugin__ResultCodec: thrift.IStructCodec<IPublishPlugin__ResultArgs, IPublishPlugin__Result> = {
    encode(args: IPublishPlugin__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("PublishPlugin__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            PublishPluginResponse.PublishPluginResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IPublishPlugin__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_85: PublishPluginResponse.IPublishPluginResponse = PublishPluginResponse.PublishPluginResponseCodec.decode(input);
                        _args.success = value_85;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class PublishPlugin__Result extends thrift.StructLike implements IPublishPlugin__Result {
    public success?: PublishPluginResponse.IPublishPluginResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IPublishPlugin__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_86: PublishPluginResponse.IPublishPluginResponse = new PublishPluginResponse.PublishPluginResponse(args.success);
            this.success = value_86;
        }
    }
    public static read(input: thrift.TProtocol): PublishPlugin__Result {
        return new PublishPlugin__Result(PublishPlugin__ResultCodec.decode(input));
    }
    public static write(args: IPublishPlugin__ResultArgs, output: thrift.TProtocol): void {
        return PublishPlugin__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return PublishPlugin__ResultCodec.encode(this, output);
    }
}
export interface IUpdatePluginMeta__Result {
    success?: UpdatePluginMetaResponse.IUpdatePluginMetaResponse;
}
export interface IUpdatePluginMeta__ResultArgs {
    success?: UpdatePluginMetaResponse.IUpdatePluginMetaResponseArgs;
}
export const UpdatePluginMeta__ResultCodec: thrift.IStructCodec<IUpdatePluginMeta__ResultArgs, IUpdatePluginMeta__Result> = {
    encode(args: IUpdatePluginMeta__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("UpdatePluginMeta__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            UpdatePluginMetaResponse.UpdatePluginMetaResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdatePluginMeta__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_87: UpdatePluginMetaResponse.IUpdatePluginMetaResponse = UpdatePluginMetaResponse.UpdatePluginMetaResponseCodec.decode(input);
                        _args.success = value_87;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class UpdatePluginMeta__Result extends thrift.StructLike implements IUpdatePluginMeta__Result {
    public success?: UpdatePluginMetaResponse.IUpdatePluginMetaResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdatePluginMeta__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_88: UpdatePluginMetaResponse.IUpdatePluginMetaResponse = new UpdatePluginMetaResponse.UpdatePluginMetaResponse(args.success);
            this.success = value_88;
        }
    }
    public static read(input: thrift.TProtocol): UpdatePluginMeta__Result {
        return new UpdatePluginMeta__Result(UpdatePluginMeta__ResultCodec.decode(input));
    }
    public static write(args: IUpdatePluginMeta__ResultArgs, output: thrift.TProtocol): void {
        return UpdatePluginMeta__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdatePluginMeta__ResultCodec.encode(this, output);
    }
}
export interface IGetBotDefaultParams__Result {
    success?: GetBotDefaultParamsResponse.IGetBotDefaultParamsResponse;
}
export interface IGetBotDefaultParams__ResultArgs {
    success?: GetBotDefaultParamsResponse.IGetBotDefaultParamsResponseArgs;
}
export const GetBotDefaultParams__ResultCodec: thrift.IStructCodec<IGetBotDefaultParams__ResultArgs, IGetBotDefaultParams__Result> = {
    encode(args: IGetBotDefaultParams__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetBotDefaultParams__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetBotDefaultParamsResponse.GetBotDefaultParamsResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetBotDefaultParams__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_89: GetBotDefaultParamsResponse.IGetBotDefaultParamsResponse = GetBotDefaultParamsResponse.GetBotDefaultParamsResponseCodec.decode(input);
                        _args.success = value_89;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetBotDefaultParams__Result extends thrift.StructLike implements IGetBotDefaultParams__Result {
    public success?: GetBotDefaultParamsResponse.IGetBotDefaultParamsResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetBotDefaultParams__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_90: GetBotDefaultParamsResponse.IGetBotDefaultParamsResponse = new GetBotDefaultParamsResponse.GetBotDefaultParamsResponse(args.success);
            this.success = value_90;
        }
    }
    public static read(input: thrift.TProtocol): GetBotDefaultParams__Result {
        return new GetBotDefaultParams__Result(GetBotDefaultParams__ResultCodec.decode(input));
    }
    public static write(args: IGetBotDefaultParams__ResultArgs, output: thrift.TProtocol): void {
        return GetBotDefaultParams__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetBotDefaultParams__ResultCodec.encode(this, output);
    }
}
export interface IUpdateBotDefaultParams__Result {
    success?: UpdateBotDefaultParamsResponse.IUpdateBotDefaultParamsResponse;
}
export interface IUpdateBotDefaultParams__ResultArgs {
    success?: UpdateBotDefaultParamsResponse.IUpdateBotDefaultParamsResponseArgs;
}
export const UpdateBotDefaultParams__ResultCodec: thrift.IStructCodec<IUpdateBotDefaultParams__ResultArgs, IUpdateBotDefaultParams__Result> = {
    encode(args: IUpdateBotDefaultParams__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("UpdateBotDefaultParams__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            UpdateBotDefaultParamsResponse.UpdateBotDefaultParamsResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateBotDefaultParams__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_91: UpdateBotDefaultParamsResponse.IUpdateBotDefaultParamsResponse = UpdateBotDefaultParamsResponse.UpdateBotDefaultParamsResponseCodec.decode(input);
                        _args.success = value_91;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class UpdateBotDefaultParams__Result extends thrift.StructLike implements IUpdateBotDefaultParams__Result {
    public success?: UpdateBotDefaultParamsResponse.IUpdateBotDefaultParamsResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateBotDefaultParams__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_92: UpdateBotDefaultParamsResponse.IUpdateBotDefaultParamsResponse = new UpdateBotDefaultParamsResponse.UpdateBotDefaultParamsResponse(args.success);
            this.success = value_92;
        }
    }
    public static read(input: thrift.TProtocol): UpdateBotDefaultParams__Result {
        return new UpdateBotDefaultParams__Result(UpdateBotDefaultParams__ResultCodec.decode(input));
    }
    public static write(args: IUpdateBotDefaultParams__ResultArgs, output: thrift.TProtocol): void {
        return UpdateBotDefaultParams__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateBotDefaultParams__ResultCodec.encode(this, output);
    }
}
export interface ICreateAPI__Result {
    success?: CreateAPIResponse.ICreateAPIResponse;
}
export interface ICreateAPI__ResultArgs {
    success?: CreateAPIResponse.ICreateAPIResponseArgs;
}
export const CreateAPI__ResultCodec: thrift.IStructCodec<ICreateAPI__ResultArgs, ICreateAPI__Result> = {
    encode(args: ICreateAPI__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("CreateAPI__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            CreateAPIResponse.CreateAPIResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICreateAPI__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_93: CreateAPIResponse.ICreateAPIResponse = CreateAPIResponse.CreateAPIResponseCodec.decode(input);
                        _args.success = value_93;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class CreateAPI__Result extends thrift.StructLike implements ICreateAPI__Result {
    public success?: CreateAPIResponse.ICreateAPIResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ICreateAPI__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_94: CreateAPIResponse.ICreateAPIResponse = new CreateAPIResponse.CreateAPIResponse(args.success);
            this.success = value_94;
        }
    }
    public static read(input: thrift.TProtocol): CreateAPI__Result {
        return new CreateAPI__Result(CreateAPI__ResultCodec.decode(input));
    }
    public static write(args: ICreateAPI__ResultArgs, output: thrift.TProtocol): void {
        return CreateAPI__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CreateAPI__ResultCodec.encode(this, output);
    }
}
export interface IUpdateAPI__Result {
    success?: UpdateAPIResponse.IUpdateAPIResponse;
}
export interface IUpdateAPI__ResultArgs {
    success?: UpdateAPIResponse.IUpdateAPIResponseArgs;
}
export const UpdateAPI__ResultCodec: thrift.IStructCodec<IUpdateAPI__ResultArgs, IUpdateAPI__Result> = {
    encode(args: IUpdateAPI__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("UpdateAPI__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            UpdateAPIResponse.UpdateAPIResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateAPI__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_95: UpdateAPIResponse.IUpdateAPIResponse = UpdateAPIResponse.UpdateAPIResponseCodec.decode(input);
                        _args.success = value_95;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class UpdateAPI__Result extends thrift.StructLike implements IUpdateAPI__Result {
    public success?: UpdateAPIResponse.IUpdateAPIResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateAPI__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_96: UpdateAPIResponse.IUpdateAPIResponse = new UpdateAPIResponse.UpdateAPIResponse(args.success);
            this.success = value_96;
        }
    }
    public static read(input: thrift.TProtocol): UpdateAPI__Result {
        return new UpdateAPI__Result(UpdateAPI__ResultCodec.decode(input));
    }
    public static write(args: IUpdateAPI__ResultArgs, output: thrift.TProtocol): void {
        return UpdateAPI__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateAPI__ResultCodec.encode(this, output);
    }
}
export interface IGetUserAuthority__Result {
    success?: GetUserAuthorityResponse.IGetUserAuthorityResponse;
}
export interface IGetUserAuthority__ResultArgs {
    success?: GetUserAuthorityResponse.IGetUserAuthorityResponseArgs;
}
export const GetUserAuthority__ResultCodec: thrift.IStructCodec<IGetUserAuthority__ResultArgs, IGetUserAuthority__Result> = {
    encode(args: IGetUserAuthority__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetUserAuthority__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetUserAuthorityResponse.GetUserAuthorityResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetUserAuthority__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_97: GetUserAuthorityResponse.IGetUserAuthorityResponse = GetUserAuthorityResponse.GetUserAuthorityResponseCodec.decode(input);
                        _args.success = value_97;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetUserAuthority__Result extends thrift.StructLike implements IGetUserAuthority__Result {
    public success?: GetUserAuthorityResponse.IGetUserAuthorityResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetUserAuthority__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_98: GetUserAuthorityResponse.IGetUserAuthorityResponse = new GetUserAuthorityResponse.GetUserAuthorityResponse(args.success);
            this.success = value_98;
        }
    }
    public static read(input: thrift.TProtocol): GetUserAuthority__Result {
        return new GetUserAuthority__Result(GetUserAuthority__ResultCodec.decode(input));
    }
    public static write(args: IGetUserAuthority__ResultArgs, output: thrift.TProtocol): void {
        return GetUserAuthority__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetUserAuthority__ResultCodec.encode(this, output);
    }
}
export interface IDebugAPI__Result {
    success?: DebugAPIResponse.IDebugAPIResponse;
}
export interface IDebugAPI__ResultArgs {
    success?: DebugAPIResponse.IDebugAPIResponseArgs;
}
export const DebugAPI__ResultCodec: thrift.IStructCodec<IDebugAPI__ResultArgs, IDebugAPI__Result> = {
    encode(args: IDebugAPI__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("DebugAPI__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            DebugAPIResponse.DebugAPIResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDebugAPI__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_99: DebugAPIResponse.IDebugAPIResponse = DebugAPIResponse.DebugAPIResponseCodec.decode(input);
                        _args.success = value_99;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class DebugAPI__Result extends thrift.StructLike implements IDebugAPI__Result {
    public success?: DebugAPIResponse.IDebugAPIResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDebugAPI__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_100: DebugAPIResponse.IDebugAPIResponse = new DebugAPIResponse.DebugAPIResponse(args.success);
            this.success = value_100;
        }
    }
    public static read(input: thrift.TProtocol): DebugAPI__Result {
        return new DebugAPI__Result(DebugAPI__ResultCodec.decode(input));
    }
    public static write(args: IDebugAPI__ResultArgs, output: thrift.TProtocol): void {
        return DebugAPI__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DebugAPI__ResultCodec.encode(this, output);
    }
}
export interface IGetPluginNextVersion__Result {
    success?: GetPluginNextVersionResponse.IGetPluginNextVersionResponse;
}
export interface IGetPluginNextVersion__ResultArgs {
    success?: GetPluginNextVersionResponse.IGetPluginNextVersionResponseArgs;
}
export const GetPluginNextVersion__ResultCodec: thrift.IStructCodec<IGetPluginNextVersion__ResultArgs, IGetPluginNextVersion__Result> = {
    encode(args: IGetPluginNextVersion__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetPluginNextVersion__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetPluginNextVersionResponse.GetPluginNextVersionResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetPluginNextVersion__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_101: GetPluginNextVersionResponse.IGetPluginNextVersionResponse = GetPluginNextVersionResponse.GetPluginNextVersionResponseCodec.decode(input);
                        _args.success = value_101;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetPluginNextVersion__Result extends thrift.StructLike implements IGetPluginNextVersion__Result {
    public success?: GetPluginNextVersionResponse.IGetPluginNextVersionResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetPluginNextVersion__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_102: GetPluginNextVersionResponse.IGetPluginNextVersionResponse = new GetPluginNextVersionResponse.GetPluginNextVersionResponse(args.success);
            this.success = value_102;
        }
    }
    public static read(input: thrift.TProtocol): GetPluginNextVersion__Result {
        return new GetPluginNextVersion__Result(GetPluginNextVersion__ResultCodec.decode(input));
    }
    public static write(args: IGetPluginNextVersion__ResultArgs, output: thrift.TProtocol): void {
        return GetPluginNextVersion__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetPluginNextVersion__ResultCodec.encode(this, output);
    }
}
export interface IGetDevPluginList__Result {
    success?: GetDevPluginListResponse.IGetDevPluginListResponse;
}
export interface IGetDevPluginList__ResultArgs {
    success?: GetDevPluginListResponse.IGetDevPluginListResponseArgs;
}
export const GetDevPluginList__ResultCodec: thrift.IStructCodec<IGetDevPluginList__ResultArgs, IGetDevPluginList__Result> = {
    encode(args: IGetDevPluginList__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetDevPluginList__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetDevPluginListResponse.GetDevPluginListResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetDevPluginList__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_103: GetDevPluginListResponse.IGetDevPluginListResponse = GetDevPluginListResponse.GetDevPluginListResponseCodec.decode(input);
                        _args.success = value_103;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetDevPluginList__Result extends thrift.StructLike implements IGetDevPluginList__Result {
    public success?: GetDevPluginListResponse.IGetDevPluginListResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetDevPluginList__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_104: GetDevPluginListResponse.IGetDevPluginListResponse = new GetDevPluginListResponse.GetDevPluginListResponse(args.success);
            this.success = value_104;
        }
    }
    public static read(input: thrift.TProtocol): GetDevPluginList__Result {
        return new GetDevPluginList__Result(GetDevPluginList__ResultCodec.decode(input));
    }
    public static write(args: IGetDevPluginList__ResultArgs, output: thrift.TProtocol): void {
        return GetDevPluginList__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetDevPluginList__ResultCodec.encode(this, output);
    }
}
export interface IConvert2OpenAPI__Result {
    success?: Convert2OpenAPIResponse.IConvert2OpenAPIResponse;
}
export interface IConvert2OpenAPI__ResultArgs {
    success?: Convert2OpenAPIResponse.IConvert2OpenAPIResponseArgs;
}
export const Convert2OpenAPI__ResultCodec: thrift.IStructCodec<IConvert2OpenAPI__ResultArgs, IConvert2OpenAPI__Result> = {
    encode(args: IConvert2OpenAPI__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("Convert2OpenAPI__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            Convert2OpenAPIResponse.Convert2OpenAPIResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IConvert2OpenAPI__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_105: Convert2OpenAPIResponse.IConvert2OpenAPIResponse = Convert2OpenAPIResponse.Convert2OpenAPIResponseCodec.decode(input);
                        _args.success = value_105;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class Convert2OpenAPI__Result extends thrift.StructLike implements IConvert2OpenAPI__Result {
    public success?: Convert2OpenAPIResponse.IConvert2OpenAPIResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IConvert2OpenAPI__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_106: Convert2OpenAPIResponse.IConvert2OpenAPIResponse = new Convert2OpenAPIResponse.Convert2OpenAPIResponse(args.success);
            this.success = value_106;
        }
    }
    public static read(input: thrift.TProtocol): Convert2OpenAPI__Result {
        return new Convert2OpenAPI__Result(Convert2OpenAPI__ResultCodec.decode(input));
    }
    public static write(args: IConvert2OpenAPI__ResultArgs, output: thrift.TProtocol): void {
        return Convert2OpenAPI__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return Convert2OpenAPI__ResultCodec.encode(this, output);
    }
}
export interface IBatchCreateAPI__Result {
    success?: BatchCreateAPIResponse.IBatchCreateAPIResponse;
}
export interface IBatchCreateAPI__ResultArgs {
    success?: BatchCreateAPIResponse.IBatchCreateAPIResponseArgs;
}
export const BatchCreateAPI__ResultCodec: thrift.IStructCodec<IBatchCreateAPI__ResultArgs, IBatchCreateAPI__Result> = {
    encode(args: IBatchCreateAPI__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("BatchCreateAPI__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            BatchCreateAPIResponse.BatchCreateAPIResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IBatchCreateAPI__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_107: BatchCreateAPIResponse.IBatchCreateAPIResponse = BatchCreateAPIResponse.BatchCreateAPIResponseCodec.decode(input);
                        _args.success = value_107;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class BatchCreateAPI__Result extends thrift.StructLike implements IBatchCreateAPI__Result {
    public success?: BatchCreateAPIResponse.IBatchCreateAPIResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IBatchCreateAPI__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_108: BatchCreateAPIResponse.IBatchCreateAPIResponse = new BatchCreateAPIResponse.BatchCreateAPIResponse(args.success);
            this.success = value_108;
        }
    }
    public static read(input: thrift.TProtocol): BatchCreateAPI__Result {
        return new BatchCreateAPI__Result(BatchCreateAPI__ResultCodec.decode(input));
    }
    public static write(args: IBatchCreateAPI__ResultArgs, output: thrift.TProtocol): void {
        return BatchCreateAPI__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return BatchCreateAPI__ResultCodec.encode(this, output);
    }
}
export interface IRevokeAuthToken__Result {
    success?: RevokeAuthTokenResponse.IRevokeAuthTokenResponse;
}
export interface IRevokeAuthToken__ResultArgs {
    success?: RevokeAuthTokenResponse.IRevokeAuthTokenResponseArgs;
}
export const RevokeAuthToken__ResultCodec: thrift.IStructCodec<IRevokeAuthToken__ResultArgs, IRevokeAuthToken__Result> = {
    encode(args: IRevokeAuthToken__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("RevokeAuthToken__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            RevokeAuthTokenResponse.RevokeAuthTokenResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IRevokeAuthToken__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_109: RevokeAuthTokenResponse.IRevokeAuthTokenResponse = RevokeAuthTokenResponse.RevokeAuthTokenResponseCodec.decode(input);
                        _args.success = value_109;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class RevokeAuthToken__Result extends thrift.StructLike implements IRevokeAuthToken__Result {
    public success?: RevokeAuthTokenResponse.IRevokeAuthTokenResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IRevokeAuthToken__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_110: RevokeAuthTokenResponse.IRevokeAuthTokenResponse = new RevokeAuthTokenResponse.RevokeAuthTokenResponse(args.success);
            this.success = value_110;
        }
    }
    public static read(input: thrift.TProtocol): RevokeAuthToken__Result {
        return new RevokeAuthToken__Result(RevokeAuthToken__ResultCodec.decode(input));
    }
    public static write(args: IRevokeAuthToken__ResultArgs, output: thrift.TProtocol): void {
        return RevokeAuthToken__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return RevokeAuthToken__ResultCodec.encode(this, output);
    }
}
export interface IGetQueriedOAuthPluginList__Result {
    success?: GetQueriedOAuthPluginListResponse.IGetQueriedOAuthPluginListResponse;
}
export interface IGetQueriedOAuthPluginList__ResultArgs {
    success?: GetQueriedOAuthPluginListResponse.IGetQueriedOAuthPluginListResponseArgs;
}
export const GetQueriedOAuthPluginList__ResultCodec: thrift.IStructCodec<IGetQueriedOAuthPluginList__ResultArgs, IGetQueriedOAuthPluginList__Result> = {
    encode(args: IGetQueriedOAuthPluginList__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetQueriedOAuthPluginList__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetQueriedOAuthPluginListResponse.GetQueriedOAuthPluginListResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetQueriedOAuthPluginList__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_111: GetQueriedOAuthPluginListResponse.IGetQueriedOAuthPluginListResponse = GetQueriedOAuthPluginListResponse.GetQueriedOAuthPluginListResponseCodec.decode(input);
                        _args.success = value_111;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetQueriedOAuthPluginList__Result extends thrift.StructLike implements IGetQueriedOAuthPluginList__Result {
    public success?: GetQueriedOAuthPluginListResponse.IGetQueriedOAuthPluginListResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetQueriedOAuthPluginList__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_112: GetQueriedOAuthPluginListResponse.IGetQueriedOAuthPluginListResponse = new GetQueriedOAuthPluginListResponse.GetQueriedOAuthPluginListResponse(args.success);
            this.success = value_112;
        }
    }
    public static read(input: thrift.TProtocol): GetQueriedOAuthPluginList__Result {
        return new GetQueriedOAuthPluginList__Result(GetQueriedOAuthPluginList__ResultCodec.decode(input));
    }
    public static write(args: IGetQueriedOAuthPluginList__ResultArgs, output: thrift.TProtocol): void {
        return GetQueriedOAuthPluginList__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetQueriedOAuthPluginList__ResultCodec.encode(this, output);
    }
}
export class Client<Context = any> extends thrift.ThriftClient<Context> {
    public static readonly serviceName: string = serviceName;
    public static readonly annotations: thrift.IThriftAnnotations = annotations;
    public static readonly methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public static readonly methodNames: Array<string> = methodNames;
    public readonly _serviceName: string = serviceName;
    public readonly _annotations: thrift.IThriftAnnotations = annotations;
    public readonly _methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public readonly _methodNames: Array<string> = methodNames;
    public readonly _methodParameters?: {
        [methodName: string]: number;
    } = methodParameters;
    public GetOAuthSchema(request: GetOAuthSchemaRequest.IGetOAuthSchemaRequestArgs, context?: Context): Promise<GetOAuthSchemaResponse.IGetOAuthSchemaResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetOAuthSchema", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetOAuthSchema__ArgsArgs = { request };
        GetOAuthSchema__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetOAuthSchema") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetOAuthSchema__Result = GetOAuthSchema__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetOAuthSchema failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetOAuthSchemaAPI(request: GetOAuthSchemaRequest.IGetOAuthSchemaRequestArgs, context?: Context): Promise<GetOAuthSchemaResponse.IGetOAuthSchemaResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetOAuthSchemaAPI", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetOAuthSchemaAPI__ArgsArgs = { request };
        GetOAuthSchemaAPI__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetOAuthSchemaAPI") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetOAuthSchemaAPI__Result = GetOAuthSchemaAPI__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetOAuthSchemaAPI failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetPlaygroundPluginList(request: GetPlaygroundPluginListRequest.IGetPlaygroundPluginListRequestArgs, context?: Context): Promise<GetPlaygroundPluginListResponse.IGetPlaygroundPluginListResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetPlaygroundPluginList", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetPlaygroundPluginList__ArgsArgs = { request };
        GetPlaygroundPluginList__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetPlaygroundPluginList") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetPlaygroundPluginList__Result = GetPlaygroundPluginList__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetPlaygroundPluginList failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public RegisterPlugin(request: RegisterPluginRequest.IRegisterPluginRequestArgs, context?: Context): Promise<RegisterPluginResponse.IRegisterPluginResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("RegisterPlugin", thrift.MessageType.CALL, this.increment_request_id());
        const args: IRegisterPlugin__ArgsArgs = { request };
        RegisterPlugin__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "RegisterPlugin") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IRegisterPlugin__Result = RegisterPlugin__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "RegisterPlugin failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public RegisterPluginMeta(request: RegisterPluginMetaRequest.IRegisterPluginMetaRequestArgs, context?: Context): Promise<RegisterPluginMetaResponse.IRegisterPluginMetaResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("RegisterPluginMeta", thrift.MessageType.CALL, this.increment_request_id());
        const args: IRegisterPluginMeta__ArgsArgs = { request };
        RegisterPluginMeta__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "RegisterPluginMeta") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IRegisterPluginMeta__Result = RegisterPluginMeta__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "RegisterPluginMeta failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetPluginAPIs(request: GetPluginAPIsRequest.IGetPluginAPIsRequestArgs, context?: Context): Promise<GetPluginAPIsResponse.IGetPluginAPIsResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetPluginAPIs", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetPluginAPIs__ArgsArgs = { request };
        GetPluginAPIs__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetPluginAPIs") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetPluginAPIs__Result = GetPluginAPIs__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetPluginAPIs failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetPluginInfo(request: GetPluginInfoRequest.IGetPluginInfoRequestArgs, context?: Context): Promise<GetPluginInfoResponse.IGetPluginInfoResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetPluginInfo", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetPluginInfo__ArgsArgs = { request };
        GetPluginInfo__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetPluginInfo") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetPluginInfo__Result = GetPluginInfo__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetPluginInfo failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetUpdatedAPIs(request: GetUpdatedAPIsRequest.IGetUpdatedAPIsRequestArgs, context?: Context): Promise<GetUpdatedAPIsResponse.IGetUpdatedAPIsResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetUpdatedAPIs", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetUpdatedAPIs__ArgsArgs = { request };
        GetUpdatedAPIs__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetUpdatedAPIs") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetUpdatedAPIs__Result = GetUpdatedAPIs__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetUpdatedAPIs failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetOAuthStatus(request: GetOAuthStatusRequest.IGetOAuthStatusRequestArgs, context?: Context): Promise<GetOAuthStatusResponse.IGetOAuthStatusResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetOAuthStatus", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetOAuthStatus__ArgsArgs = { request };
        GetOAuthStatus__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetOAuthStatus") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetOAuthStatus__Result = GetOAuthStatus__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetOAuthStatus failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public CheckAndLockPluginEdit(request: CheckAndLockPluginEditRequest.ICheckAndLockPluginEditRequestArgs, context?: Context): Promise<CheckAndLockPluginEditResponse.ICheckAndLockPluginEditResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("CheckAndLockPluginEdit", thrift.MessageType.CALL, this.increment_request_id());
        const args: ICheckAndLockPluginEdit__ArgsArgs = { request };
        CheckAndLockPluginEdit__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "CheckAndLockPluginEdit") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: ICheckAndLockPluginEdit__Result = CheckAndLockPluginEdit__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "CheckAndLockPluginEdit failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public UnlockPluginEdit(request: UnlockPluginEditRequest.IUnlockPluginEditRequestArgs, context?: Context): Promise<UnlockPluginEditResponse.IUnlockPluginEditResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("UnlockPluginEdit", thrift.MessageType.CALL, this.increment_request_id());
        const args: IUnlockPluginEdit__ArgsArgs = { request };
        UnlockPluginEdit__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "UnlockPluginEdit") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IUnlockPluginEdit__Result = UnlockPluginEdit__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "UnlockPluginEdit failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public UpdatePlugin(request: UpdatePluginRequest.IUpdatePluginRequestArgs, context?: Context): Promise<UpdatePluginResponse.IUpdatePluginResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("UpdatePlugin", thrift.MessageType.CALL, this.increment_request_id());
        const args: IUpdatePlugin__ArgsArgs = { request };
        UpdatePlugin__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "UpdatePlugin") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IUpdatePlugin__Result = UpdatePlugin__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "UpdatePlugin failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public DeleteAPI(request: DeleteAPIRequest.IDeleteAPIRequestArgs, context?: Context): Promise<DeleteAPIResponse.IDeleteAPIResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("DeleteAPI", thrift.MessageType.CALL, this.increment_request_id());
        const args: IDeleteAPI__ArgsArgs = { request };
        DeleteAPI__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "DeleteAPI") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IDeleteAPI__Result = DeleteAPI__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "DeleteAPI failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public DelPlugin(request: DelPluginRequest.IDelPluginRequestArgs, context?: Context): Promise<DelPluginResponse.IDelPluginResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("DelPlugin", thrift.MessageType.CALL, this.increment_request_id());
        const args: IDelPlugin__ArgsArgs = { request };
        DelPlugin__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "DelPlugin") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IDelPlugin__Result = DelPlugin__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "DelPlugin failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public PublishPlugin(request: PublishPluginRequest.IPublishPluginRequestArgs, context?: Context): Promise<PublishPluginResponse.IPublishPluginResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("PublishPlugin", thrift.MessageType.CALL, this.increment_request_id());
        const args: IPublishPlugin__ArgsArgs = { request };
        PublishPlugin__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "PublishPlugin") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IPublishPlugin__Result = PublishPlugin__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "PublishPlugin failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public UpdatePluginMeta(request: UpdatePluginMetaRequest.IUpdatePluginMetaRequestArgs, context?: Context): Promise<UpdatePluginMetaResponse.IUpdatePluginMetaResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("UpdatePluginMeta", thrift.MessageType.CALL, this.increment_request_id());
        const args: IUpdatePluginMeta__ArgsArgs = { request };
        UpdatePluginMeta__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "UpdatePluginMeta") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IUpdatePluginMeta__Result = UpdatePluginMeta__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "UpdatePluginMeta failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetBotDefaultParams(request: GetBotDefaultParamsRequest.IGetBotDefaultParamsRequestArgs, context?: Context): Promise<GetBotDefaultParamsResponse.IGetBotDefaultParamsResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetBotDefaultParams", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetBotDefaultParams__ArgsArgs = { request };
        GetBotDefaultParams__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetBotDefaultParams") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetBotDefaultParams__Result = GetBotDefaultParams__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetBotDefaultParams failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public UpdateBotDefaultParams(request: UpdateBotDefaultParamsRequest.IUpdateBotDefaultParamsRequestArgs, context?: Context): Promise<UpdateBotDefaultParamsResponse.IUpdateBotDefaultParamsResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("UpdateBotDefaultParams", thrift.MessageType.CALL, this.increment_request_id());
        const args: IUpdateBotDefaultParams__ArgsArgs = { request };
        UpdateBotDefaultParams__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "UpdateBotDefaultParams") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IUpdateBotDefaultParams__Result = UpdateBotDefaultParams__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "UpdateBotDefaultParams failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public CreateAPI(request: CreateAPIRequest.ICreateAPIRequestArgs, context?: Context): Promise<CreateAPIResponse.ICreateAPIResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("CreateAPI", thrift.MessageType.CALL, this.increment_request_id());
        const args: ICreateAPI__ArgsArgs = { request };
        CreateAPI__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "CreateAPI") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: ICreateAPI__Result = CreateAPI__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "CreateAPI failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public UpdateAPI(request: UpdateAPIRequest.IUpdateAPIRequestArgs, context?: Context): Promise<UpdateAPIResponse.IUpdateAPIResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("UpdateAPI", thrift.MessageType.CALL, this.increment_request_id());
        const args: IUpdateAPI__ArgsArgs = { request };
        UpdateAPI__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "UpdateAPI") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IUpdateAPI__Result = UpdateAPI__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "UpdateAPI failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetUserAuthority(request: GetUserAuthorityRequest.IGetUserAuthorityRequestArgs, context?: Context): Promise<GetUserAuthorityResponse.IGetUserAuthorityResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetUserAuthority", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetUserAuthority__ArgsArgs = { request };
        GetUserAuthority__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetUserAuthority") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetUserAuthority__Result = GetUserAuthority__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetUserAuthority failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public DebugAPI(request: DebugAPIRequest.IDebugAPIRequestArgs, context?: Context): Promise<DebugAPIResponse.IDebugAPIResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("DebugAPI", thrift.MessageType.CALL, this.increment_request_id());
        const args: IDebugAPI__ArgsArgs = { request };
        DebugAPI__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "DebugAPI") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IDebugAPI__Result = DebugAPI__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "DebugAPI failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetPluginNextVersion(request: GetPluginNextVersionRequest.IGetPluginNextVersionRequestArgs, context?: Context): Promise<GetPluginNextVersionResponse.IGetPluginNextVersionResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetPluginNextVersion", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetPluginNextVersion__ArgsArgs = { request };
        GetPluginNextVersion__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetPluginNextVersion") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetPluginNextVersion__Result = GetPluginNextVersion__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetPluginNextVersion failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetDevPluginList(request: GetDevPluginListRequest.IGetDevPluginListRequestArgs, context?: Context): Promise<GetDevPluginListResponse.IGetDevPluginListResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetDevPluginList", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetDevPluginList__ArgsArgs = { request };
        GetDevPluginList__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetDevPluginList") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetDevPluginList__Result = GetDevPluginList__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetDevPluginList failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public Convert2OpenAPI(request: Convert2OpenAPIRequest.IConvert2OpenAPIRequestArgs, context?: Context): Promise<Convert2OpenAPIResponse.IConvert2OpenAPIResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("Convert2OpenAPI", thrift.MessageType.CALL, this.increment_request_id());
        const args: IConvert2OpenAPI__ArgsArgs = { request };
        Convert2OpenAPI__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "Convert2OpenAPI") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IConvert2OpenAPI__Result = Convert2OpenAPI__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "Convert2OpenAPI failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public BatchCreateAPI(request: BatchCreateAPIRequest.IBatchCreateAPIRequestArgs, context?: Context): Promise<BatchCreateAPIResponse.IBatchCreateAPIResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("BatchCreateAPI", thrift.MessageType.CALL, this.increment_request_id());
        const args: IBatchCreateAPI__ArgsArgs = { request };
        BatchCreateAPI__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "BatchCreateAPI") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IBatchCreateAPI__Result = BatchCreateAPI__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "BatchCreateAPI failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public RevokeAuthToken(request: RevokeAuthTokenRequest.IRevokeAuthTokenRequestArgs, context?: Context): Promise<RevokeAuthTokenResponse.IRevokeAuthTokenResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("RevokeAuthToken", thrift.MessageType.CALL, this.increment_request_id());
        const args: IRevokeAuthToken__ArgsArgs = { request };
        RevokeAuthToken__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "RevokeAuthToken") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IRevokeAuthToken__Result = RevokeAuthToken__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "RevokeAuthToken failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetQueriedOAuthPluginList(request: GetQueriedOAuthPluginListRequest.IGetQueriedOAuthPluginListRequestArgs, context?: Context): Promise<GetQueriedOAuthPluginListResponse.IGetQueriedOAuthPluginListResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetQueriedOAuthPluginList", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetQueriedOAuthPluginList__ArgsArgs = { request };
        GetQueriedOAuthPluginList__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetQueriedOAuthPluginList") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetQueriedOAuthPluginList__Result = GetQueriedOAuthPluginList__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetQueriedOAuthPluginList failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
}
export interface IHandler<Context = any> {
    GetOAuthSchema(request: GetOAuthSchemaRequest.IGetOAuthSchemaRequest, context?: Context): GetOAuthSchemaResponse.IGetOAuthSchemaResponseArgs | Promise<GetOAuthSchemaResponse.IGetOAuthSchemaResponseArgs>;
    GetOAuthSchemaAPI(request: GetOAuthSchemaRequest.IGetOAuthSchemaRequest, context?: Context): GetOAuthSchemaResponse.IGetOAuthSchemaResponseArgs | Promise<GetOAuthSchemaResponse.IGetOAuthSchemaResponseArgs>;
    GetPlaygroundPluginList(request: GetPlaygroundPluginListRequest.IGetPlaygroundPluginListRequest, context?: Context): GetPlaygroundPluginListResponse.IGetPlaygroundPluginListResponseArgs | Promise<GetPlaygroundPluginListResponse.IGetPlaygroundPluginListResponseArgs>;
    RegisterPlugin(request: RegisterPluginRequest.IRegisterPluginRequest, context?: Context): RegisterPluginResponse.IRegisterPluginResponseArgs | Promise<RegisterPluginResponse.IRegisterPluginResponseArgs>;
    RegisterPluginMeta(request: RegisterPluginMetaRequest.IRegisterPluginMetaRequest, context?: Context): RegisterPluginMetaResponse.IRegisterPluginMetaResponseArgs | Promise<RegisterPluginMetaResponse.IRegisterPluginMetaResponseArgs>;
    GetPluginAPIs(request: GetPluginAPIsRequest.IGetPluginAPIsRequest, context?: Context): GetPluginAPIsResponse.IGetPluginAPIsResponseArgs | Promise<GetPluginAPIsResponse.IGetPluginAPIsResponseArgs>;
    GetPluginInfo(request: GetPluginInfoRequest.IGetPluginInfoRequest, context?: Context): GetPluginInfoResponse.IGetPluginInfoResponseArgs | Promise<GetPluginInfoResponse.IGetPluginInfoResponseArgs>;
    GetUpdatedAPIs(request: GetUpdatedAPIsRequest.IGetUpdatedAPIsRequest, context?: Context): GetUpdatedAPIsResponse.IGetUpdatedAPIsResponseArgs | Promise<GetUpdatedAPIsResponse.IGetUpdatedAPIsResponseArgs>;
    GetOAuthStatus(request: GetOAuthStatusRequest.IGetOAuthStatusRequest, context?: Context): GetOAuthStatusResponse.IGetOAuthStatusResponseArgs | Promise<GetOAuthStatusResponse.IGetOAuthStatusResponseArgs>;
    CheckAndLockPluginEdit(request: CheckAndLockPluginEditRequest.ICheckAndLockPluginEditRequest, context?: Context): CheckAndLockPluginEditResponse.ICheckAndLockPluginEditResponseArgs | Promise<CheckAndLockPluginEditResponse.ICheckAndLockPluginEditResponseArgs>;
    UnlockPluginEdit(request: UnlockPluginEditRequest.IUnlockPluginEditRequest, context?: Context): UnlockPluginEditResponse.IUnlockPluginEditResponseArgs | Promise<UnlockPluginEditResponse.IUnlockPluginEditResponseArgs>;
    UpdatePlugin(request: UpdatePluginRequest.IUpdatePluginRequest, context?: Context): UpdatePluginResponse.IUpdatePluginResponseArgs | Promise<UpdatePluginResponse.IUpdatePluginResponseArgs>;
    DeleteAPI(request: DeleteAPIRequest.IDeleteAPIRequest, context?: Context): DeleteAPIResponse.IDeleteAPIResponseArgs | Promise<DeleteAPIResponse.IDeleteAPIResponseArgs>;
    DelPlugin(request: DelPluginRequest.IDelPluginRequest, context?: Context): DelPluginResponse.IDelPluginResponseArgs | Promise<DelPluginResponse.IDelPluginResponseArgs>;
    PublishPlugin(request: PublishPluginRequest.IPublishPluginRequest, context?: Context): PublishPluginResponse.IPublishPluginResponseArgs | Promise<PublishPluginResponse.IPublishPluginResponseArgs>;
    UpdatePluginMeta(request: UpdatePluginMetaRequest.IUpdatePluginMetaRequest, context?: Context): UpdatePluginMetaResponse.IUpdatePluginMetaResponseArgs | Promise<UpdatePluginMetaResponse.IUpdatePluginMetaResponseArgs>;
    GetBotDefaultParams(request: GetBotDefaultParamsRequest.IGetBotDefaultParamsRequest, context?: Context): GetBotDefaultParamsResponse.IGetBotDefaultParamsResponseArgs | Promise<GetBotDefaultParamsResponse.IGetBotDefaultParamsResponseArgs>;
    UpdateBotDefaultParams(request: UpdateBotDefaultParamsRequest.IUpdateBotDefaultParamsRequest, context?: Context): UpdateBotDefaultParamsResponse.IUpdateBotDefaultParamsResponseArgs | Promise<UpdateBotDefaultParamsResponse.IUpdateBotDefaultParamsResponseArgs>;
    CreateAPI(request: CreateAPIRequest.ICreateAPIRequest, context?: Context): CreateAPIResponse.ICreateAPIResponseArgs | Promise<CreateAPIResponse.ICreateAPIResponseArgs>;
    UpdateAPI(request: UpdateAPIRequest.IUpdateAPIRequest, context?: Context): UpdateAPIResponse.IUpdateAPIResponseArgs | Promise<UpdateAPIResponse.IUpdateAPIResponseArgs>;
    GetUserAuthority(request: GetUserAuthorityRequest.IGetUserAuthorityRequest, context?: Context): GetUserAuthorityResponse.IGetUserAuthorityResponseArgs | Promise<GetUserAuthorityResponse.IGetUserAuthorityResponseArgs>;
    DebugAPI(request: DebugAPIRequest.IDebugAPIRequest, context?: Context): DebugAPIResponse.IDebugAPIResponseArgs | Promise<DebugAPIResponse.IDebugAPIResponseArgs>;
    GetPluginNextVersion(request: GetPluginNextVersionRequest.IGetPluginNextVersionRequest, context?: Context): GetPluginNextVersionResponse.IGetPluginNextVersionResponseArgs | Promise<GetPluginNextVersionResponse.IGetPluginNextVersionResponseArgs>;
    GetDevPluginList(request: GetDevPluginListRequest.IGetDevPluginListRequest, context?: Context): GetDevPluginListResponse.IGetDevPluginListResponseArgs | Promise<GetDevPluginListResponse.IGetDevPluginListResponseArgs>;
    Convert2OpenAPI(request: Convert2OpenAPIRequest.IConvert2OpenAPIRequest, context?: Context): Convert2OpenAPIResponse.IConvert2OpenAPIResponseArgs | Promise<Convert2OpenAPIResponse.IConvert2OpenAPIResponseArgs>;
    BatchCreateAPI(request: BatchCreateAPIRequest.IBatchCreateAPIRequest, context?: Context): BatchCreateAPIResponse.IBatchCreateAPIResponseArgs | Promise<BatchCreateAPIResponse.IBatchCreateAPIResponseArgs>;
    RevokeAuthToken(request: RevokeAuthTokenRequest.IRevokeAuthTokenRequest, context?: Context): RevokeAuthTokenResponse.IRevokeAuthTokenResponseArgs | Promise<RevokeAuthTokenResponse.IRevokeAuthTokenResponseArgs>;
    GetQueriedOAuthPluginList(request: GetQueriedOAuthPluginListRequest.IGetQueriedOAuthPluginListRequest, context?: Context): GetQueriedOAuthPluginListResponse.IGetQueriedOAuthPluginListResponseArgs | Promise<GetQueriedOAuthPluginListResponse.IGetQueriedOAuthPluginListResponseArgs>;
}
export class Processor<Context = any> extends thrift.ThriftProcessor<Context, IHandler<Context>> {
    protected readonly _handler: IHandler<Context>;
    public static readonly serviceName: string = serviceName;
    public static readonly annotations: thrift.IThriftAnnotations = annotations;
    public static readonly methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public static readonly methodNames: Array<string> = methodNames;
    public readonly _serviceName: string = serviceName;
    public readonly _annotations: thrift.IThriftAnnotations = annotations;
    public readonly _methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public readonly _methodNames: Array<string> = methodNames;
    constructor(handler: IHandler<Context>) {
        super();
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<Buffer>((resolve, reject): void => {
            const metadata: thrift.IThriftMessage = input.readMessageBegin();
            const fieldName: string = metadata.fieldName;
            const requestId: number = metadata.requestId;
            const methodName: string = "process_" + fieldName;
            switch (methodName) {
                case "process_GetOAuthSchema": {
                    resolve(this.process__get_o_auth_schema(requestId, input, output, context));
                    break;
                }
                case "process_GetOAuthSchemaAPI": {
                    resolve(this.process__get_o_auth_schema_a_p_i(requestId, input, output, context));
                    break;
                }
                case "process_GetPlaygroundPluginList": {
                    resolve(this.process__get_playground_plugin_list(requestId, input, output, context));
                    break;
                }
                case "process_RegisterPlugin": {
                    resolve(this.process__register_plugin(requestId, input, output, context));
                    break;
                }
                case "process_RegisterPluginMeta": {
                    resolve(this.process__register_plugin_meta(requestId, input, output, context));
                    break;
                }
                case "process_GetPluginAPIs": {
                    resolve(this.process__get_plugin_a_p_is(requestId, input, output, context));
                    break;
                }
                case "process_GetPluginInfo": {
                    resolve(this.process__get_plugin_info(requestId, input, output, context));
                    break;
                }
                case "process_GetUpdatedAPIs": {
                    resolve(this.process__get_updated_a_p_is(requestId, input, output, context));
                    break;
                }
                case "process_GetOAuthStatus": {
                    resolve(this.process__get_o_auth_status(requestId, input, output, context));
                    break;
                }
                case "process_CheckAndLockPluginEdit": {
                    resolve(this.process__check_and_lock_plugin_edit(requestId, input, output, context));
                    break;
                }
                case "process_UnlockPluginEdit": {
                    resolve(this.process__unlock_plugin_edit(requestId, input, output, context));
                    break;
                }
                case "process_UpdatePlugin": {
                    resolve(this.process__update_plugin(requestId, input, output, context));
                    break;
                }
                case "process_DeleteAPI": {
                    resolve(this.process__delete_a_p_i(requestId, input, output, context));
                    break;
                }
                case "process_DelPlugin": {
                    resolve(this.process__del_plugin(requestId, input, output, context));
                    break;
                }
                case "process_PublishPlugin": {
                    resolve(this.process__publish_plugin(requestId, input, output, context));
                    break;
                }
                case "process_UpdatePluginMeta": {
                    resolve(this.process__update_plugin_meta(requestId, input, output, context));
                    break;
                }
                case "process_GetBotDefaultParams": {
                    resolve(this.process__get_bot_default_params(requestId, input, output, context));
                    break;
                }
                case "process_UpdateBotDefaultParams": {
                    resolve(this.process__update_bot_default_params(requestId, input, output, context));
                    break;
                }
                case "process_CreateAPI": {
                    resolve(this.process__create_a_p_i(requestId, input, output, context));
                    break;
                }
                case "process_UpdateAPI": {
                    resolve(this.process__update_a_p_i(requestId, input, output, context));
                    break;
                }
                case "process_GetUserAuthority": {
                    resolve(this.process__get_user_authority(requestId, input, output, context));
                    break;
                }
                case "process_DebugAPI": {
                    resolve(this.process__debug_a_p_i(requestId, input, output, context));
                    break;
                }
                case "process_GetPluginNextVersion": {
                    resolve(this.process__get_plugin_next_version(requestId, input, output, context));
                    break;
                }
                case "process_GetDevPluginList": {
                    resolve(this.process__get_dev_plugin_list(requestId, input, output, context));
                    break;
                }
                case "process_Convert2OpenAPI": {
                    resolve(this.process__convert2_open_a_p_i(requestId, input, output, context));
                    break;
                }
                case "process_BatchCreateAPI": {
                    resolve(this.process__batch_create_a_p_i(requestId, input, output, context));
                    break;
                }
                case "process_RevokeAuthToken": {
                    resolve(this.process__revoke_auth_token(requestId, input, output, context));
                    break;
                }
                case "process_GetQueriedOAuthPluginList": {
                    resolve(this.process__get_queried_o_auth_plugin_list(requestId, input, output, context));
                    break;
                }
                default: {
                    input.skip(thrift.TType.STRUCT);
                    input.readMessageEnd();
                    const errMessage = "Unknown function " + fieldName;
                    const err = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                    output.writeMessageBegin(fieldName, thrift.MessageType.EXCEPTION, requestId);
                    thrift.TApplicationExceptionCodec.encode(err, output);
                    output.writeMessageEnd();
                    resolve(output.flush());
                    break;
                }
            }
        });
    }
    public process_GetOAuthSchema(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetOAuthSchemaResponse.IGetOAuthSchemaResponseArgs>((resolve, reject): void => {
            try {
                const args: IGetOAuthSchema__Args = GetOAuthSchema__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetOAuthSchema(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetOAuthSchemaResponse.IGetOAuthSchemaResponseArgs): Buffer => {
            const result: IGetOAuthSchema__ResultArgs = { success: data };
            output.writeMessageBegin("GetOAuthSchema", thrift.MessageType.REPLY, requestId);
            GetOAuthSchema__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetOAuthSchema", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetOAuthSchemaAPI(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetOAuthSchemaResponse.IGetOAuthSchemaResponseArgs>((resolve, reject): void => {
            try {
                const args: IGetOAuthSchemaAPI__Args = GetOAuthSchemaAPI__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetOAuthSchemaAPI(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetOAuthSchemaResponse.IGetOAuthSchemaResponseArgs): Buffer => {
            const result: IGetOAuthSchemaAPI__ResultArgs = { success: data };
            output.writeMessageBegin("GetOAuthSchemaAPI", thrift.MessageType.REPLY, requestId);
            GetOAuthSchemaAPI__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetOAuthSchemaAPI", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetPlaygroundPluginList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetPlaygroundPluginListResponse.IGetPlaygroundPluginListResponseArgs>((resolve, reject): void => {
            try {
                const args: IGetPlaygroundPluginList__Args = GetPlaygroundPluginList__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetPlaygroundPluginList(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetPlaygroundPluginListResponse.IGetPlaygroundPluginListResponseArgs): Buffer => {
            const result: IGetPlaygroundPluginList__ResultArgs = { success: data };
            output.writeMessageBegin("GetPlaygroundPluginList", thrift.MessageType.REPLY, requestId);
            GetPlaygroundPluginList__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetPlaygroundPluginList", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_RegisterPlugin(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<RegisterPluginResponse.IRegisterPluginResponseArgs>((resolve, reject): void => {
            try {
                const args: IRegisterPlugin__Args = RegisterPlugin__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.RegisterPlugin(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: RegisterPluginResponse.IRegisterPluginResponseArgs): Buffer => {
            const result: IRegisterPlugin__ResultArgs = { success: data };
            output.writeMessageBegin("RegisterPlugin", thrift.MessageType.REPLY, requestId);
            RegisterPlugin__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("RegisterPlugin", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_RegisterPluginMeta(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<RegisterPluginMetaResponse.IRegisterPluginMetaResponseArgs>((resolve, reject): void => {
            try {
                const args: IRegisterPluginMeta__Args = RegisterPluginMeta__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.RegisterPluginMeta(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: RegisterPluginMetaResponse.IRegisterPluginMetaResponseArgs): Buffer => {
            const result: IRegisterPluginMeta__ResultArgs = { success: data };
            output.writeMessageBegin("RegisterPluginMeta", thrift.MessageType.REPLY, requestId);
            RegisterPluginMeta__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("RegisterPluginMeta", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetPluginAPIs(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetPluginAPIsResponse.IGetPluginAPIsResponseArgs>((resolve, reject): void => {
            try {
                const args: IGetPluginAPIs__Args = GetPluginAPIs__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetPluginAPIs(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetPluginAPIsResponse.IGetPluginAPIsResponseArgs): Buffer => {
            const result: IGetPluginAPIs__ResultArgs = { success: data };
            output.writeMessageBegin("GetPluginAPIs", thrift.MessageType.REPLY, requestId);
            GetPluginAPIs__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetPluginAPIs", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetPluginInfo(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetPluginInfoResponse.IGetPluginInfoResponseArgs>((resolve, reject): void => {
            try {
                const args: IGetPluginInfo__Args = GetPluginInfo__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetPluginInfo(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetPluginInfoResponse.IGetPluginInfoResponseArgs): Buffer => {
            const result: IGetPluginInfo__ResultArgs = { success: data };
            output.writeMessageBegin("GetPluginInfo", thrift.MessageType.REPLY, requestId);
            GetPluginInfo__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetPluginInfo", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetUpdatedAPIs(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetUpdatedAPIsResponse.IGetUpdatedAPIsResponseArgs>((resolve, reject): void => {
            try {
                const args: IGetUpdatedAPIs__Args = GetUpdatedAPIs__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetUpdatedAPIs(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetUpdatedAPIsResponse.IGetUpdatedAPIsResponseArgs): Buffer => {
            const result: IGetUpdatedAPIs__ResultArgs = { success: data };
            output.writeMessageBegin("GetUpdatedAPIs", thrift.MessageType.REPLY, requestId);
            GetUpdatedAPIs__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetUpdatedAPIs", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetOAuthStatus(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetOAuthStatusResponse.IGetOAuthStatusResponseArgs>((resolve, reject): void => {
            try {
                const args: IGetOAuthStatus__Args = GetOAuthStatus__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetOAuthStatus(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetOAuthStatusResponse.IGetOAuthStatusResponseArgs): Buffer => {
            const result: IGetOAuthStatus__ResultArgs = { success: data };
            output.writeMessageBegin("GetOAuthStatus", thrift.MessageType.REPLY, requestId);
            GetOAuthStatus__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetOAuthStatus", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_CheckAndLockPluginEdit(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<CheckAndLockPluginEditResponse.ICheckAndLockPluginEditResponseArgs>((resolve, reject): void => {
            try {
                const args: ICheckAndLockPluginEdit__Args = CheckAndLockPluginEdit__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.CheckAndLockPluginEdit(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: CheckAndLockPluginEditResponse.ICheckAndLockPluginEditResponseArgs): Buffer => {
            const result: ICheckAndLockPluginEdit__ResultArgs = { success: data };
            output.writeMessageBegin("CheckAndLockPluginEdit", thrift.MessageType.REPLY, requestId);
            CheckAndLockPluginEdit__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("CheckAndLockPluginEdit", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_UnlockPluginEdit(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<UnlockPluginEditResponse.IUnlockPluginEditResponseArgs>((resolve, reject): void => {
            try {
                const args: IUnlockPluginEdit__Args = UnlockPluginEdit__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.UnlockPluginEdit(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: UnlockPluginEditResponse.IUnlockPluginEditResponseArgs): Buffer => {
            const result: IUnlockPluginEdit__ResultArgs = { success: data };
            output.writeMessageBegin("UnlockPluginEdit", thrift.MessageType.REPLY, requestId);
            UnlockPluginEdit__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("UnlockPluginEdit", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_UpdatePlugin(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<UpdatePluginResponse.IUpdatePluginResponseArgs>((resolve, reject): void => {
            try {
                const args: IUpdatePlugin__Args = UpdatePlugin__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.UpdatePlugin(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: UpdatePluginResponse.IUpdatePluginResponseArgs): Buffer => {
            const result: IUpdatePlugin__ResultArgs = { success: data };
            output.writeMessageBegin("UpdatePlugin", thrift.MessageType.REPLY, requestId);
            UpdatePlugin__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("UpdatePlugin", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_DeleteAPI(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<DeleteAPIResponse.IDeleteAPIResponseArgs>((resolve, reject): void => {
            try {
                const args: IDeleteAPI__Args = DeleteAPI__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.DeleteAPI(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DeleteAPIResponse.IDeleteAPIResponseArgs): Buffer => {
            const result: IDeleteAPI__ResultArgs = { success: data };
            output.writeMessageBegin("DeleteAPI", thrift.MessageType.REPLY, requestId);
            DeleteAPI__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("DeleteAPI", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_DelPlugin(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<DelPluginResponse.IDelPluginResponseArgs>((resolve, reject): void => {
            try {
                const args: IDelPlugin__Args = DelPlugin__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.DelPlugin(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DelPluginResponse.IDelPluginResponseArgs): Buffer => {
            const result: IDelPlugin__ResultArgs = { success: data };
            output.writeMessageBegin("DelPlugin", thrift.MessageType.REPLY, requestId);
            DelPlugin__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("DelPlugin", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_PublishPlugin(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<PublishPluginResponse.IPublishPluginResponseArgs>((resolve, reject): void => {
            try {
                const args: IPublishPlugin__Args = PublishPlugin__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.PublishPlugin(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: PublishPluginResponse.IPublishPluginResponseArgs): Buffer => {
            const result: IPublishPlugin__ResultArgs = { success: data };
            output.writeMessageBegin("PublishPlugin", thrift.MessageType.REPLY, requestId);
            PublishPlugin__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("PublishPlugin", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_UpdatePluginMeta(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<UpdatePluginMetaResponse.IUpdatePluginMetaResponseArgs>((resolve, reject): void => {
            try {
                const args: IUpdatePluginMeta__Args = UpdatePluginMeta__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.UpdatePluginMeta(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: UpdatePluginMetaResponse.IUpdatePluginMetaResponseArgs): Buffer => {
            const result: IUpdatePluginMeta__ResultArgs = { success: data };
            output.writeMessageBegin("UpdatePluginMeta", thrift.MessageType.REPLY, requestId);
            UpdatePluginMeta__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("UpdatePluginMeta", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetBotDefaultParams(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetBotDefaultParamsResponse.IGetBotDefaultParamsResponseArgs>((resolve, reject): void => {
            try {
                const args: IGetBotDefaultParams__Args = GetBotDefaultParams__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetBotDefaultParams(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetBotDefaultParamsResponse.IGetBotDefaultParamsResponseArgs): Buffer => {
            const result: IGetBotDefaultParams__ResultArgs = { success: data };
            output.writeMessageBegin("GetBotDefaultParams", thrift.MessageType.REPLY, requestId);
            GetBotDefaultParams__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetBotDefaultParams", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_UpdateBotDefaultParams(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<UpdateBotDefaultParamsResponse.IUpdateBotDefaultParamsResponseArgs>((resolve, reject): void => {
            try {
                const args: IUpdateBotDefaultParams__Args = UpdateBotDefaultParams__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.UpdateBotDefaultParams(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: UpdateBotDefaultParamsResponse.IUpdateBotDefaultParamsResponseArgs): Buffer => {
            const result: IUpdateBotDefaultParams__ResultArgs = { success: data };
            output.writeMessageBegin("UpdateBotDefaultParams", thrift.MessageType.REPLY, requestId);
            UpdateBotDefaultParams__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("UpdateBotDefaultParams", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_CreateAPI(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<CreateAPIResponse.ICreateAPIResponseArgs>((resolve, reject): void => {
            try {
                const args: ICreateAPI__Args = CreateAPI__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.CreateAPI(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: CreateAPIResponse.ICreateAPIResponseArgs): Buffer => {
            const result: ICreateAPI__ResultArgs = { success: data };
            output.writeMessageBegin("CreateAPI", thrift.MessageType.REPLY, requestId);
            CreateAPI__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("CreateAPI", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_UpdateAPI(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<UpdateAPIResponse.IUpdateAPIResponseArgs>((resolve, reject): void => {
            try {
                const args: IUpdateAPI__Args = UpdateAPI__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.UpdateAPI(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: UpdateAPIResponse.IUpdateAPIResponseArgs): Buffer => {
            const result: IUpdateAPI__ResultArgs = { success: data };
            output.writeMessageBegin("UpdateAPI", thrift.MessageType.REPLY, requestId);
            UpdateAPI__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("UpdateAPI", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetUserAuthority(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetUserAuthorityResponse.IGetUserAuthorityResponseArgs>((resolve, reject): void => {
            try {
                const args: IGetUserAuthority__Args = GetUserAuthority__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetUserAuthority(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetUserAuthorityResponse.IGetUserAuthorityResponseArgs): Buffer => {
            const result: IGetUserAuthority__ResultArgs = { success: data };
            output.writeMessageBegin("GetUserAuthority", thrift.MessageType.REPLY, requestId);
            GetUserAuthority__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetUserAuthority", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_DebugAPI(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<DebugAPIResponse.IDebugAPIResponseArgs>((resolve, reject): void => {
            try {
                const args: IDebugAPI__Args = DebugAPI__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.DebugAPI(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DebugAPIResponse.IDebugAPIResponseArgs): Buffer => {
            const result: IDebugAPI__ResultArgs = { success: data };
            output.writeMessageBegin("DebugAPI", thrift.MessageType.REPLY, requestId);
            DebugAPI__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("DebugAPI", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetPluginNextVersion(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetPluginNextVersionResponse.IGetPluginNextVersionResponseArgs>((resolve, reject): void => {
            try {
                const args: IGetPluginNextVersion__Args = GetPluginNextVersion__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetPluginNextVersion(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetPluginNextVersionResponse.IGetPluginNextVersionResponseArgs): Buffer => {
            const result: IGetPluginNextVersion__ResultArgs = { success: data };
            output.writeMessageBegin("GetPluginNextVersion", thrift.MessageType.REPLY, requestId);
            GetPluginNextVersion__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetPluginNextVersion", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetDevPluginList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetDevPluginListResponse.IGetDevPluginListResponseArgs>((resolve, reject): void => {
            try {
                const args: IGetDevPluginList__Args = GetDevPluginList__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetDevPluginList(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetDevPluginListResponse.IGetDevPluginListResponseArgs): Buffer => {
            const result: IGetDevPluginList__ResultArgs = { success: data };
            output.writeMessageBegin("GetDevPluginList", thrift.MessageType.REPLY, requestId);
            GetDevPluginList__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetDevPluginList", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_Convert2OpenAPI(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<Convert2OpenAPIResponse.IConvert2OpenAPIResponseArgs>((resolve, reject): void => {
            try {
                const args: IConvert2OpenAPI__Args = Convert2OpenAPI__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.Convert2OpenAPI(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Convert2OpenAPIResponse.IConvert2OpenAPIResponseArgs): Buffer => {
            const result: IConvert2OpenAPI__ResultArgs = { success: data };
            output.writeMessageBegin("Convert2OpenAPI", thrift.MessageType.REPLY, requestId);
            Convert2OpenAPI__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("Convert2OpenAPI", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_BatchCreateAPI(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<BatchCreateAPIResponse.IBatchCreateAPIResponseArgs>((resolve, reject): void => {
            try {
                const args: IBatchCreateAPI__Args = BatchCreateAPI__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.BatchCreateAPI(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: BatchCreateAPIResponse.IBatchCreateAPIResponseArgs): Buffer => {
            const result: IBatchCreateAPI__ResultArgs = { success: data };
            output.writeMessageBegin("BatchCreateAPI", thrift.MessageType.REPLY, requestId);
            BatchCreateAPI__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("BatchCreateAPI", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_RevokeAuthToken(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<RevokeAuthTokenResponse.IRevokeAuthTokenResponseArgs>((resolve, reject): void => {
            try {
                const args: IRevokeAuthToken__Args = RevokeAuthToken__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.RevokeAuthToken(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: RevokeAuthTokenResponse.IRevokeAuthTokenResponseArgs): Buffer => {
            const result: IRevokeAuthToken__ResultArgs = { success: data };
            output.writeMessageBegin("RevokeAuthToken", thrift.MessageType.REPLY, requestId);
            RevokeAuthToken__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("RevokeAuthToken", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetQueriedOAuthPluginList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetQueriedOAuthPluginListResponse.IGetQueriedOAuthPluginListResponseArgs>((resolve, reject): void => {
            try {
                const args: IGetQueriedOAuthPluginList__Args = GetQueriedOAuthPluginList__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetQueriedOAuthPluginList(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetQueriedOAuthPluginListResponse.IGetQueriedOAuthPluginListResponseArgs): Buffer => {
            const result: IGetQueriedOAuthPluginList__ResultArgs = { success: data };
            output.writeMessageBegin("GetQueriedOAuthPluginList", thrift.MessageType.REPLY, requestId);
            GetQueriedOAuthPluginList__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetQueriedOAuthPluginList", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
}
