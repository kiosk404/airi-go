/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "@creditkarma/thrift-server-core";
import * as OauthAuthorizationCodeReq from "./OauthAuthorizationCodeReq";
import * as OauthAuthorizationCodeResp from "./OauthAuthorizationCodeResp";
import * as GetBotOnlineInfoReq from "./GetBotOnlineInfoReq";
import * as GetBotOnlineInfoResp from "./GetBotOnlineInfoResp";
import * as OpenGetBotInfoRequest from "./OpenGetBotInfoRequest";
import * as OpenGetBotInfoResponse from "./OpenGetBotInfoResponse";
import * as ImpersonateAiriUserRequest from "./ImpersonateAiriUserRequest";
import * as ImpersonateAiriUserResponse from "./ImpersonateAiriUserResponse";
import * as UploadFileOpenRequest from "./UploadFileOpenRequest";
import * as UploadFileOpenResponse from "./UploadFileOpenResponse";
export const serviceName: string = "BotOpenApiService";
export const annotations: thrift.IThriftAnnotations = {};
export const methodAnnotations: thrift.IMethodAnnotations = {
    OauthAuthorizationCode: {
        annotations: {
            'api.get': "/api/oauth/authorization_code",
            'api.category': "oauth",
            'api.gen_path': "oauth"
        },
        fieldAnnotations: {}
    },
    GetBotOnlineInfo: {
        annotations: {
            'api.get': "/v1/bot/get_online_info",
            'api.category': "bot",
            'api.tag': "openapi",
            'api.gen_path': "personal_api"
        },
        fieldAnnotations: {}
    },
    OpenGetBotInfo: {
        annotations: {
            'api.get': "/v1/bots/:bot_id",
            'api.category': "bot",
            'api.tag': "openapi",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    },
    ImpersonateAiriUser: {
        annotations: {
            'api.post': "/api/permission_api/airi_web_app/impersonate_airi_user"
        },
        fieldAnnotations: {}
    },
    UploadFileOpen: {
        annotations: {
            'api.post': "/v1/files/upload",
            'api.category': "file",
            'api.tag': "openapi",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    }
};
export const methodNames: Array<string> = ["OauthAuthorizationCode", "GetBotOnlineInfo", "OpenGetBotInfo", "ImpersonateAiriUser", "UploadFileOpen"];
export const methodParameters: {
    [methodName: string]: number;
} = {
    OauthAuthorizationCode: 2,
    GetBotOnlineInfo: 2,
    OpenGetBotInfo: 2,
    ImpersonateAiriUser: 2,
    UploadFileOpen: 2
};
export interface IOauthAuthorizationCode__Args {
    request: OauthAuthorizationCodeReq.IOauthAuthorizationCodeReq;
}
export interface IOauthAuthorizationCode__ArgsArgs {
    request: OauthAuthorizationCodeReq.IOauthAuthorizationCodeReqArgs;
}
export const OauthAuthorizationCode__ArgsCodec: thrift.IStructCodec<IOauthAuthorizationCode__ArgsArgs, IOauthAuthorizationCode__Args> = {
    encode(args: IOauthAuthorizationCode__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("OauthAuthorizationCode__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            OauthAuthorizationCodeReq.OauthAuthorizationCodeReqCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IOauthAuthorizationCode__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_1: OauthAuthorizationCodeReq.IOauthAuthorizationCodeReq = OauthAuthorizationCodeReq.OauthAuthorizationCodeReqCodec.decode(input);
                        _args.request = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read OauthAuthorizationCode__Args from input");
        }
    }
};
export class OauthAuthorizationCode__Args extends thrift.StructLike implements IOauthAuthorizationCode__Args {
    public request: OauthAuthorizationCodeReq.IOauthAuthorizationCodeReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IOauthAuthorizationCode__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_2: OauthAuthorizationCodeReq.IOauthAuthorizationCodeReq = new OauthAuthorizationCodeReq.OauthAuthorizationCodeReq(args.request);
            this.request = value_2;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): OauthAuthorizationCode__Args {
        return new OauthAuthorizationCode__Args(OauthAuthorizationCode__ArgsCodec.decode(input));
    }
    public static write(args: IOauthAuthorizationCode__ArgsArgs, output: thrift.TProtocol): void {
        return OauthAuthorizationCode__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return OauthAuthorizationCode__ArgsCodec.encode(this, output);
    }
}
export interface IGetBotOnlineInfo__Args {
    request: GetBotOnlineInfoReq.IGetBotOnlineInfoReq;
}
export interface IGetBotOnlineInfo__ArgsArgs {
    request: GetBotOnlineInfoReq.IGetBotOnlineInfoReqArgs;
}
export const GetBotOnlineInfo__ArgsCodec: thrift.IStructCodec<IGetBotOnlineInfo__ArgsArgs, IGetBotOnlineInfo__Args> = {
    encode(args: IGetBotOnlineInfo__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("GetBotOnlineInfo__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            GetBotOnlineInfoReq.GetBotOnlineInfoReqCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetBotOnlineInfo__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_3: GetBotOnlineInfoReq.IGetBotOnlineInfoReq = GetBotOnlineInfoReq.GetBotOnlineInfoReqCodec.decode(input);
                        _args.request = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetBotOnlineInfo__Args from input");
        }
    }
};
export class GetBotOnlineInfo__Args extends thrift.StructLike implements IGetBotOnlineInfo__Args {
    public request: GetBotOnlineInfoReq.IGetBotOnlineInfoReq;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetBotOnlineInfo__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_4: GetBotOnlineInfoReq.IGetBotOnlineInfoReq = new GetBotOnlineInfoReq.GetBotOnlineInfoReq(args.request);
            this.request = value_4;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): GetBotOnlineInfo__Args {
        return new GetBotOnlineInfo__Args(GetBotOnlineInfo__ArgsCodec.decode(input));
    }
    public static write(args: IGetBotOnlineInfo__ArgsArgs, output: thrift.TProtocol): void {
        return GetBotOnlineInfo__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetBotOnlineInfo__ArgsCodec.encode(this, output);
    }
}
export interface IOpenGetBotInfo__Args {
    request: OpenGetBotInfoRequest.IOpenGetBotInfoRequest;
}
export interface IOpenGetBotInfo__ArgsArgs {
    request: OpenGetBotInfoRequest.IOpenGetBotInfoRequestArgs;
}
export const OpenGetBotInfo__ArgsCodec: thrift.IStructCodec<IOpenGetBotInfo__ArgsArgs, IOpenGetBotInfo__Args> = {
    encode(args: IOpenGetBotInfo__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("OpenGetBotInfo__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            OpenGetBotInfoRequest.OpenGetBotInfoRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IOpenGetBotInfo__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_5: OpenGetBotInfoRequest.IOpenGetBotInfoRequest = OpenGetBotInfoRequest.OpenGetBotInfoRequestCodec.decode(input);
                        _args.request = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read OpenGetBotInfo__Args from input");
        }
    }
};
export class OpenGetBotInfo__Args extends thrift.StructLike implements IOpenGetBotInfo__Args {
    public request: OpenGetBotInfoRequest.IOpenGetBotInfoRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IOpenGetBotInfo__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_6: OpenGetBotInfoRequest.IOpenGetBotInfoRequest = new OpenGetBotInfoRequest.OpenGetBotInfoRequest(args.request);
            this.request = value_6;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): OpenGetBotInfo__Args {
        return new OpenGetBotInfo__Args(OpenGetBotInfo__ArgsCodec.decode(input));
    }
    public static write(args: IOpenGetBotInfo__ArgsArgs, output: thrift.TProtocol): void {
        return OpenGetBotInfo__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return OpenGetBotInfo__ArgsCodec.encode(this, output);
    }
}
export interface IImpersonateAiriUser__Args {
    request: ImpersonateAiriUserRequest.IImpersonateAiriUserRequest;
}
export interface IImpersonateAiriUser__ArgsArgs {
    request: ImpersonateAiriUserRequest.IImpersonateAiriUserRequestArgs;
}
export const ImpersonateAiriUser__ArgsCodec: thrift.IStructCodec<IImpersonateAiriUser__ArgsArgs, IImpersonateAiriUser__Args> = {
    encode(args: IImpersonateAiriUser__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("ImpersonateAiriUser__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            ImpersonateAiriUserRequest.ImpersonateAiriUserRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IImpersonateAiriUser__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_7: ImpersonateAiriUserRequest.IImpersonateAiriUserRequest = ImpersonateAiriUserRequest.ImpersonateAiriUserRequestCodec.decode(input);
                        _args.request = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ImpersonateAiriUser__Args from input");
        }
    }
};
export class ImpersonateAiriUser__Args extends thrift.StructLike implements IImpersonateAiriUser__Args {
    public request: ImpersonateAiriUserRequest.IImpersonateAiriUserRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IImpersonateAiriUser__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_8: ImpersonateAiriUserRequest.IImpersonateAiriUserRequest = new ImpersonateAiriUserRequest.ImpersonateAiriUserRequest(args.request);
            this.request = value_8;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): ImpersonateAiriUser__Args {
        return new ImpersonateAiriUser__Args(ImpersonateAiriUser__ArgsCodec.decode(input));
    }
    public static write(args: IImpersonateAiriUser__ArgsArgs, output: thrift.TProtocol): void {
        return ImpersonateAiriUser__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ImpersonateAiriUser__ArgsCodec.encode(this, output);
    }
}
export interface IUploadFileOpen__Args {
    request: UploadFileOpenRequest.IUploadFileOpenRequest;
}
export interface IUploadFileOpen__ArgsArgs {
    request: UploadFileOpenRequest.IUploadFileOpenRequestArgs;
}
export const UploadFileOpen__ArgsCodec: thrift.IStructCodec<IUploadFileOpen__ArgsArgs, IUploadFileOpen__Args> = {
    encode(args: IUploadFileOpen__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("UploadFileOpen__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            UploadFileOpenRequest.UploadFileOpenRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUploadFileOpen__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_9: UploadFileOpenRequest.IUploadFileOpenRequest = UploadFileOpenRequest.UploadFileOpenRequestCodec.decode(input);
                        _args.request = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UploadFileOpen__Args from input");
        }
    }
};
export class UploadFileOpen__Args extends thrift.StructLike implements IUploadFileOpen__Args {
    public request: UploadFileOpenRequest.IUploadFileOpenRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUploadFileOpen__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_10: UploadFileOpenRequest.IUploadFileOpenRequest = new UploadFileOpenRequest.UploadFileOpenRequest(args.request);
            this.request = value_10;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): UploadFileOpen__Args {
        return new UploadFileOpen__Args(UploadFileOpen__ArgsCodec.decode(input));
    }
    public static write(args: IUploadFileOpen__ArgsArgs, output: thrift.TProtocol): void {
        return UploadFileOpen__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UploadFileOpen__ArgsCodec.encode(this, output);
    }
}
export interface IOauthAuthorizationCode__Result {
    success?: OauthAuthorizationCodeResp.IOauthAuthorizationCodeResp;
}
export interface IOauthAuthorizationCode__ResultArgs {
    success?: OauthAuthorizationCodeResp.IOauthAuthorizationCodeRespArgs;
}
export const OauthAuthorizationCode__ResultCodec: thrift.IStructCodec<IOauthAuthorizationCode__ResultArgs, IOauthAuthorizationCode__Result> = {
    encode(args: IOauthAuthorizationCode__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("OauthAuthorizationCode__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            OauthAuthorizationCodeResp.OauthAuthorizationCodeRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IOauthAuthorizationCode__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_11: OauthAuthorizationCodeResp.IOauthAuthorizationCodeResp = OauthAuthorizationCodeResp.OauthAuthorizationCodeRespCodec.decode(input);
                        _args.success = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class OauthAuthorizationCode__Result extends thrift.StructLike implements IOauthAuthorizationCode__Result {
    public success?: OauthAuthorizationCodeResp.IOauthAuthorizationCodeResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IOauthAuthorizationCode__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_12: OauthAuthorizationCodeResp.IOauthAuthorizationCodeResp = new OauthAuthorizationCodeResp.OauthAuthorizationCodeResp(args.success);
            this.success = value_12;
        }
    }
    public static read(input: thrift.TProtocol): OauthAuthorizationCode__Result {
        return new OauthAuthorizationCode__Result(OauthAuthorizationCode__ResultCodec.decode(input));
    }
    public static write(args: IOauthAuthorizationCode__ResultArgs, output: thrift.TProtocol): void {
        return OauthAuthorizationCode__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return OauthAuthorizationCode__ResultCodec.encode(this, output);
    }
}
export interface IGetBotOnlineInfo__Result {
    success?: GetBotOnlineInfoResp.IGetBotOnlineInfoResp;
}
export interface IGetBotOnlineInfo__ResultArgs {
    success?: GetBotOnlineInfoResp.IGetBotOnlineInfoRespArgs;
}
export const GetBotOnlineInfo__ResultCodec: thrift.IStructCodec<IGetBotOnlineInfo__ResultArgs, IGetBotOnlineInfo__Result> = {
    encode(args: IGetBotOnlineInfo__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("GetBotOnlineInfo__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            GetBotOnlineInfoResp.GetBotOnlineInfoRespCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IGetBotOnlineInfo__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_13: GetBotOnlineInfoResp.IGetBotOnlineInfoResp = GetBotOnlineInfoResp.GetBotOnlineInfoRespCodec.decode(input);
                        _args.success = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class GetBotOnlineInfo__Result extends thrift.StructLike implements IGetBotOnlineInfo__Result {
    public success?: GetBotOnlineInfoResp.IGetBotOnlineInfoResp;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IGetBotOnlineInfo__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_14: GetBotOnlineInfoResp.IGetBotOnlineInfoResp = new GetBotOnlineInfoResp.GetBotOnlineInfoResp(args.success);
            this.success = value_14;
        }
    }
    public static read(input: thrift.TProtocol): GetBotOnlineInfo__Result {
        return new GetBotOnlineInfo__Result(GetBotOnlineInfo__ResultCodec.decode(input));
    }
    public static write(args: IGetBotOnlineInfo__ResultArgs, output: thrift.TProtocol): void {
        return GetBotOnlineInfo__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return GetBotOnlineInfo__ResultCodec.encode(this, output);
    }
}
export interface IOpenGetBotInfo__Result {
    success?: OpenGetBotInfoResponse.IOpenGetBotInfoResponse;
}
export interface IOpenGetBotInfo__ResultArgs {
    success?: OpenGetBotInfoResponse.IOpenGetBotInfoResponseArgs;
}
export const OpenGetBotInfo__ResultCodec: thrift.IStructCodec<IOpenGetBotInfo__ResultArgs, IOpenGetBotInfo__Result> = {
    encode(args: IOpenGetBotInfo__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("OpenGetBotInfo__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            OpenGetBotInfoResponse.OpenGetBotInfoResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IOpenGetBotInfo__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_15: OpenGetBotInfoResponse.IOpenGetBotInfoResponse = OpenGetBotInfoResponse.OpenGetBotInfoResponseCodec.decode(input);
                        _args.success = value_15;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class OpenGetBotInfo__Result extends thrift.StructLike implements IOpenGetBotInfo__Result {
    public success?: OpenGetBotInfoResponse.IOpenGetBotInfoResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IOpenGetBotInfo__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_16: OpenGetBotInfoResponse.IOpenGetBotInfoResponse = new OpenGetBotInfoResponse.OpenGetBotInfoResponse(args.success);
            this.success = value_16;
        }
    }
    public static read(input: thrift.TProtocol): OpenGetBotInfo__Result {
        return new OpenGetBotInfo__Result(OpenGetBotInfo__ResultCodec.decode(input));
    }
    public static write(args: IOpenGetBotInfo__ResultArgs, output: thrift.TProtocol): void {
        return OpenGetBotInfo__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return OpenGetBotInfo__ResultCodec.encode(this, output);
    }
}
export interface IImpersonateAiriUser__Result {
    success?: ImpersonateAiriUserResponse.IImpersonateAiriUserResponse;
}
export interface IImpersonateAiriUser__ResultArgs {
    success?: ImpersonateAiriUserResponse.IImpersonateAiriUserResponseArgs;
}
export const ImpersonateAiriUser__ResultCodec: thrift.IStructCodec<IImpersonateAiriUser__ResultArgs, IImpersonateAiriUser__Result> = {
    encode(args: IImpersonateAiriUser__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("ImpersonateAiriUser__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            ImpersonateAiriUserResponse.ImpersonateAiriUserResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IImpersonateAiriUser__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_17: ImpersonateAiriUserResponse.IImpersonateAiriUserResponse = ImpersonateAiriUserResponse.ImpersonateAiriUserResponseCodec.decode(input);
                        _args.success = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class ImpersonateAiriUser__Result extends thrift.StructLike implements IImpersonateAiriUser__Result {
    public success?: ImpersonateAiriUserResponse.IImpersonateAiriUserResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IImpersonateAiriUser__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_18: ImpersonateAiriUserResponse.IImpersonateAiriUserResponse = new ImpersonateAiriUserResponse.ImpersonateAiriUserResponse(args.success);
            this.success = value_18;
        }
    }
    public static read(input: thrift.TProtocol): ImpersonateAiriUser__Result {
        return new ImpersonateAiriUser__Result(ImpersonateAiriUser__ResultCodec.decode(input));
    }
    public static write(args: IImpersonateAiriUser__ResultArgs, output: thrift.TProtocol): void {
        return ImpersonateAiriUser__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ImpersonateAiriUser__ResultCodec.encode(this, output);
    }
}
export interface IUploadFileOpen__Result {
    success?: UploadFileOpenResponse.IUploadFileOpenResponse;
}
export interface IUploadFileOpen__ResultArgs {
    success?: UploadFileOpenResponse.IUploadFileOpenResponseArgs;
}
export const UploadFileOpen__ResultCodec: thrift.IStructCodec<IUploadFileOpen__ResultArgs, IUploadFileOpen__Result> = {
    encode(args: IUploadFileOpen__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("UploadFileOpen__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            UploadFileOpenResponse.UploadFileOpenResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUploadFileOpen__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_19: UploadFileOpenResponse.IUploadFileOpenResponse = UploadFileOpenResponse.UploadFileOpenResponseCodec.decode(input);
                        _args.success = value_19;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class UploadFileOpen__Result extends thrift.StructLike implements IUploadFileOpen__Result {
    public success?: UploadFileOpenResponse.IUploadFileOpenResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUploadFileOpen__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_20: UploadFileOpenResponse.IUploadFileOpenResponse = new UploadFileOpenResponse.UploadFileOpenResponse(args.success);
            this.success = value_20;
        }
    }
    public static read(input: thrift.TProtocol): UploadFileOpen__Result {
        return new UploadFileOpen__Result(UploadFileOpen__ResultCodec.decode(input));
    }
    public static write(args: IUploadFileOpen__ResultArgs, output: thrift.TProtocol): void {
        return UploadFileOpen__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UploadFileOpen__ResultCodec.encode(this, output);
    }
}
export class Client<Context = any> extends thrift.ThriftClient<Context> {
    public static readonly serviceName: string = serviceName;
    public static readonly annotations: thrift.IThriftAnnotations = annotations;
    public static readonly methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public static readonly methodNames: Array<string> = methodNames;
    public readonly _serviceName: string = serviceName;
    public readonly _annotations: thrift.IThriftAnnotations = annotations;
    public readonly _methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public readonly _methodNames: Array<string> = methodNames;
    public readonly _methodParameters?: {
        [methodName: string]: number;
    } = methodParameters;
    public OauthAuthorizationCode(request: OauthAuthorizationCodeReq.IOauthAuthorizationCodeReqArgs, context?: Context): Promise<OauthAuthorizationCodeResp.IOauthAuthorizationCodeResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("OauthAuthorizationCode", thrift.MessageType.CALL, this.increment_request_id());
        const args: IOauthAuthorizationCode__ArgsArgs = { request };
        OauthAuthorizationCode__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "OauthAuthorizationCode") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IOauthAuthorizationCode__Result = OauthAuthorizationCode__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "OauthAuthorizationCode failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public GetBotOnlineInfo(request: GetBotOnlineInfoReq.IGetBotOnlineInfoReqArgs, context?: Context): Promise<GetBotOnlineInfoResp.IGetBotOnlineInfoResp> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("GetBotOnlineInfo", thrift.MessageType.CALL, this.increment_request_id());
        const args: IGetBotOnlineInfo__ArgsArgs = { request };
        GetBotOnlineInfo__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "GetBotOnlineInfo") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IGetBotOnlineInfo__Result = GetBotOnlineInfo__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "GetBotOnlineInfo failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public OpenGetBotInfo(request: OpenGetBotInfoRequest.IOpenGetBotInfoRequestArgs, context?: Context): Promise<OpenGetBotInfoResponse.IOpenGetBotInfoResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("OpenGetBotInfo", thrift.MessageType.CALL, this.increment_request_id());
        const args: IOpenGetBotInfo__ArgsArgs = { request };
        OpenGetBotInfo__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "OpenGetBotInfo") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IOpenGetBotInfo__Result = OpenGetBotInfo__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "OpenGetBotInfo failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public ImpersonateAiriUser(request: ImpersonateAiriUserRequest.IImpersonateAiriUserRequestArgs, context?: Context): Promise<ImpersonateAiriUserResponse.IImpersonateAiriUserResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("ImpersonateAiriUser", thrift.MessageType.CALL, this.increment_request_id());
        const args: IImpersonateAiriUser__ArgsArgs = { request };
        ImpersonateAiriUser__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "ImpersonateAiriUser") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IImpersonateAiriUser__Result = ImpersonateAiriUser__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "ImpersonateAiriUser failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public UploadFileOpen(request: UploadFileOpenRequest.IUploadFileOpenRequestArgs, context?: Context): Promise<UploadFileOpenResponse.IUploadFileOpenResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("UploadFileOpen", thrift.MessageType.CALL, this.increment_request_id());
        const args: IUploadFileOpen__ArgsArgs = { request };
        UploadFileOpen__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "UploadFileOpen") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IUploadFileOpen__Result = UploadFileOpen__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "UploadFileOpen failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
}
export interface IHandler<Context = any> {
    OauthAuthorizationCode(request: OauthAuthorizationCodeReq.IOauthAuthorizationCodeReq, context?: Context): OauthAuthorizationCodeResp.IOauthAuthorizationCodeRespArgs | Promise<OauthAuthorizationCodeResp.IOauthAuthorizationCodeRespArgs>;
    GetBotOnlineInfo(request: GetBotOnlineInfoReq.IGetBotOnlineInfoReq, context?: Context): GetBotOnlineInfoResp.IGetBotOnlineInfoRespArgs | Promise<GetBotOnlineInfoResp.IGetBotOnlineInfoRespArgs>;
    OpenGetBotInfo(request: OpenGetBotInfoRequest.IOpenGetBotInfoRequest, context?: Context): OpenGetBotInfoResponse.IOpenGetBotInfoResponseArgs | Promise<OpenGetBotInfoResponse.IOpenGetBotInfoResponseArgs>;
    ImpersonateAiriUser(request: ImpersonateAiriUserRequest.IImpersonateAiriUserRequest, context?: Context): ImpersonateAiriUserResponse.IImpersonateAiriUserResponseArgs | Promise<ImpersonateAiriUserResponse.IImpersonateAiriUserResponseArgs>;
    UploadFileOpen(request: UploadFileOpenRequest.IUploadFileOpenRequest, context?: Context): UploadFileOpenResponse.IUploadFileOpenResponseArgs | Promise<UploadFileOpenResponse.IUploadFileOpenResponseArgs>;
}
export class Processor<Context = any> extends thrift.ThriftProcessor<Context, IHandler<Context>> {
    protected readonly _handler: IHandler<Context>;
    public static readonly serviceName: string = serviceName;
    public static readonly annotations: thrift.IThriftAnnotations = annotations;
    public static readonly methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public static readonly methodNames: Array<string> = methodNames;
    public readonly _serviceName: string = serviceName;
    public readonly _annotations: thrift.IThriftAnnotations = annotations;
    public readonly _methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public readonly _methodNames: Array<string> = methodNames;
    constructor(handler: IHandler<Context>) {
        super();
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<Buffer>((resolve, reject): void => {
            const metadata: thrift.IThriftMessage = input.readMessageBegin();
            const fieldName: string = metadata.fieldName;
            const requestId: number = metadata.requestId;
            const methodName: string = "process_" + fieldName;
            switch (methodName) {
                case "process_OauthAuthorizationCode": {
                    resolve(this.process__oauth_authorization_code(requestId, input, output, context));
                    break;
                }
                case "process_GetBotOnlineInfo": {
                    resolve(this.process__get_bot_online_info(requestId, input, output, context));
                    break;
                }
                case "process_OpenGetBotInfo": {
                    resolve(this.process__open_get_bot_info(requestId, input, output, context));
                    break;
                }
                case "process_ImpersonateAiriUser": {
                    resolve(this.process__impersonate_airi_user(requestId, input, output, context));
                    break;
                }
                case "process_UploadFileOpen": {
                    resolve(this.process__upload_file_open(requestId, input, output, context));
                    break;
                }
                default: {
                    input.skip(thrift.TType.STRUCT);
                    input.readMessageEnd();
                    const errMessage = "Unknown function " + fieldName;
                    const err = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                    output.writeMessageBegin(fieldName, thrift.MessageType.EXCEPTION, requestId);
                    thrift.TApplicationExceptionCodec.encode(err, output);
                    output.writeMessageEnd();
                    resolve(output.flush());
                    break;
                }
            }
        });
    }
    public process_OauthAuthorizationCode(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<OauthAuthorizationCodeResp.IOauthAuthorizationCodeRespArgs>((resolve, reject): void => {
            try {
                const args: IOauthAuthorizationCode__Args = OauthAuthorizationCode__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.OauthAuthorizationCode(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: OauthAuthorizationCodeResp.IOauthAuthorizationCodeRespArgs): Buffer => {
            const result: IOauthAuthorizationCode__ResultArgs = { success: data };
            output.writeMessageBegin("OauthAuthorizationCode", thrift.MessageType.REPLY, requestId);
            OauthAuthorizationCode__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("OauthAuthorizationCode", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_GetBotOnlineInfo(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<GetBotOnlineInfoResp.IGetBotOnlineInfoRespArgs>((resolve, reject): void => {
            try {
                const args: IGetBotOnlineInfo__Args = GetBotOnlineInfo__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.GetBotOnlineInfo(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: GetBotOnlineInfoResp.IGetBotOnlineInfoRespArgs): Buffer => {
            const result: IGetBotOnlineInfo__ResultArgs = { success: data };
            output.writeMessageBegin("GetBotOnlineInfo", thrift.MessageType.REPLY, requestId);
            GetBotOnlineInfo__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetBotOnlineInfo", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_OpenGetBotInfo(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<OpenGetBotInfoResponse.IOpenGetBotInfoResponseArgs>((resolve, reject): void => {
            try {
                const args: IOpenGetBotInfo__Args = OpenGetBotInfo__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.OpenGetBotInfo(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: OpenGetBotInfoResponse.IOpenGetBotInfoResponseArgs): Buffer => {
            const result: IOpenGetBotInfo__ResultArgs = { success: data };
            output.writeMessageBegin("OpenGetBotInfo", thrift.MessageType.REPLY, requestId);
            OpenGetBotInfo__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("OpenGetBotInfo", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_ImpersonateAiriUser(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<ImpersonateAiriUserResponse.IImpersonateAiriUserResponseArgs>((resolve, reject): void => {
            try {
                const args: IImpersonateAiriUser__Args = ImpersonateAiriUser__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.ImpersonateAiriUser(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ImpersonateAiriUserResponse.IImpersonateAiriUserResponseArgs): Buffer => {
            const result: IImpersonateAiriUser__ResultArgs = { success: data };
            output.writeMessageBegin("ImpersonateAiriUser", thrift.MessageType.REPLY, requestId);
            ImpersonateAiriUser__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("ImpersonateAiriUser", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_UploadFileOpen(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<UploadFileOpenResponse.IUploadFileOpenResponseArgs>((resolve, reject): void => {
            try {
                const args: IUploadFileOpen__Args = UploadFileOpen__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.UploadFileOpen(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: UploadFileOpenResponse.IUploadFileOpenResponseArgs): Buffer => {
            const result: IUploadFileOpen__ResultArgs = { success: data };
            output.writeMessageBegin("UploadFileOpen", thrift.MessageType.REPLY, requestId);
            UploadFileOpen__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("UploadFileOpen", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
}
