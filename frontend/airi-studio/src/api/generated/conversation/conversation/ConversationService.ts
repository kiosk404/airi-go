/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "@creditkarma/thrift-server-core";
import * as __ROOT_NAMESPACE__ from "./";
export const serviceName: string = "ConversationService";
export const annotations: thrift.IThriftAnnotations = {};
export const methodAnnotations: thrift.IMethodAnnotations = {
    ClearConversationCtx: {
        annotations: {
            'api.post': "/api/conversation/create_section",
            'api.category': "conversation",
            'api.gen_path': "conversation"
        },
        fieldAnnotations: {}
    },
    ClearConversationHistory: {
        annotations: {
            'api.post': "/api/conversation/clear_message",
            'api.category': "conversation",
            'api.gen_path': "conversation"
        },
        fieldAnnotations: {}
    },
    CreateConversation: {
        annotations: {
            'api.post': "/v1/conversation/create",
            'api.category': "conversation",
            'api.gen_path': "conversation"
        },
        fieldAnnotations: {}
    },
    ClearConversationApi: {
        annotations: {
            'api.post': "/v1/conversations/:conversation_id/clear",
            'api.category': "conversation",
            'api.tag': "openapi",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    },
    ListConversationsApi: {
        annotations: {
            'api.get': "/v1/conversations",
            'api.category': "conversation",
            'api.tag': "openapi",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    },
    UpdateConversationApi: {
        annotations: {
            'api.put': "/v1/conversations/:conversation_id",
            'api.category': "conversation",
            'api.tag': "openapi",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    },
    DeleteConversationApi: {
        annotations: {
            'api.delete': "/v1/conversations/:conversation_id",
            'api.category': "conversation",
            'api.tag': "openapi",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    }
};
export const methodNames: Array<string> = ["ClearConversationCtx", "ClearConversationHistory", "CreateConversation", "ClearConversationApi", "ListConversationsApi", "UpdateConversationApi", "DeleteConversationApi"];
export const methodParameters: {
    [methodName: string]: number;
} = {
    ClearConversationCtx: 2,
    ClearConversationHistory: 2,
    CreateConversation: 2,
    ClearConversationApi: 2,
    ListConversationsApi: 2,
    UpdateConversationApi: 2,
    DeleteConversationApi: 2
};
export interface IClearConversationCtx__Args {
    request: __ROOT_NAMESPACE__.IClearConversationCtxRequest;
}
export interface IClearConversationCtx__ArgsArgs {
    request: __ROOT_NAMESPACE__.IClearConversationCtxRequestArgs;
}
export const ClearConversationCtx__ArgsCodec: thrift.IStructCodec<IClearConversationCtx__ArgsArgs, IClearConversationCtx__Args> = {
    encode(args: IClearConversationCtx__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("ClearConversationCtx__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            __ROOT_NAMESPACE__.ClearConversationCtxRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IClearConversationCtx__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_1: __ROOT_NAMESPACE__.IClearConversationCtxRequest = __ROOT_NAMESPACE__.ClearConversationCtxRequestCodec.decode(input);
                        _args.request = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ClearConversationCtx__Args from input");
        }
    }
};
export class ClearConversationCtx__Args extends thrift.StructLike implements IClearConversationCtx__Args {
    public request: __ROOT_NAMESPACE__.IClearConversationCtxRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IClearConversationCtx__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_2: __ROOT_NAMESPACE__.IClearConversationCtxRequest = new __ROOT_NAMESPACE__.ClearConversationCtxRequest(args.request);
            this.request = value_2;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): ClearConversationCtx__Args {
        return new ClearConversationCtx__Args(ClearConversationCtx__ArgsCodec.decode(input));
    }
    public static write(args: IClearConversationCtx__ArgsArgs, output: thrift.TProtocol): void {
        return ClearConversationCtx__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ClearConversationCtx__ArgsCodec.encode(this, output);
    }
}
export interface IClearConversationHistory__Args {
    request: __ROOT_NAMESPACE__.IClearConversationHistoryRequest;
}
export interface IClearConversationHistory__ArgsArgs {
    request: __ROOT_NAMESPACE__.IClearConversationHistoryRequestArgs;
}
export const ClearConversationHistory__ArgsCodec: thrift.IStructCodec<IClearConversationHistory__ArgsArgs, IClearConversationHistory__Args> = {
    encode(args: IClearConversationHistory__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("ClearConversationHistory__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            __ROOT_NAMESPACE__.ClearConversationHistoryRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IClearConversationHistory__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_3: __ROOT_NAMESPACE__.IClearConversationHistoryRequest = __ROOT_NAMESPACE__.ClearConversationHistoryRequestCodec.decode(input);
                        _args.request = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ClearConversationHistory__Args from input");
        }
    }
};
export class ClearConversationHistory__Args extends thrift.StructLike implements IClearConversationHistory__Args {
    public request: __ROOT_NAMESPACE__.IClearConversationHistoryRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IClearConversationHistory__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_4: __ROOT_NAMESPACE__.IClearConversationHistoryRequest = new __ROOT_NAMESPACE__.ClearConversationHistoryRequest(args.request);
            this.request = value_4;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): ClearConversationHistory__Args {
        return new ClearConversationHistory__Args(ClearConversationHistory__ArgsCodec.decode(input));
    }
    public static write(args: IClearConversationHistory__ArgsArgs, output: thrift.TProtocol): void {
        return ClearConversationHistory__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ClearConversationHistory__ArgsCodec.encode(this, output);
    }
}
export interface ICreateConversation__Args {
    request: __ROOT_NAMESPACE__.ICreateConversationRequest;
}
export interface ICreateConversation__ArgsArgs {
    request: __ROOT_NAMESPACE__.ICreateConversationRequestArgs;
}
export const CreateConversation__ArgsCodec: thrift.IStructCodec<ICreateConversation__ArgsArgs, ICreateConversation__Args> = {
    encode(args: ICreateConversation__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("CreateConversation__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            __ROOT_NAMESPACE__.CreateConversationRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICreateConversation__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_5: __ROOT_NAMESPACE__.ICreateConversationRequest = __ROOT_NAMESPACE__.CreateConversationRequestCodec.decode(input);
                        _args.request = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateConversation__Args from input");
        }
    }
};
export class CreateConversation__Args extends thrift.StructLike implements ICreateConversation__Args {
    public request: __ROOT_NAMESPACE__.ICreateConversationRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ICreateConversation__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_6: __ROOT_NAMESPACE__.ICreateConversationRequest = new __ROOT_NAMESPACE__.CreateConversationRequest(args.request);
            this.request = value_6;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): CreateConversation__Args {
        return new CreateConversation__Args(CreateConversation__ArgsCodec.decode(input));
    }
    public static write(args: ICreateConversation__ArgsArgs, output: thrift.TProtocol): void {
        return CreateConversation__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CreateConversation__ArgsCodec.encode(this, output);
    }
}
export interface IClearConversationApi__Args {
    req: __ROOT_NAMESPACE__.IClearConversationApiRequest;
}
export interface IClearConversationApi__ArgsArgs {
    req: __ROOT_NAMESPACE__.IClearConversationApiRequestArgs;
}
export const ClearConversationApi__ArgsCodec: thrift.IStructCodec<IClearConversationApi__ArgsArgs, IClearConversationApi__Args> = {
    encode(args: IClearConversationApi__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("ClearConversationApi__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            __ROOT_NAMESPACE__.ClearConversationApiRequestCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IClearConversationApi__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_7: __ROOT_NAMESPACE__.IClearConversationApiRequest = __ROOT_NAMESPACE__.ClearConversationApiRequestCodec.decode(input);
                        _args.req = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ClearConversationApi__Args from input");
        }
    }
};
export class ClearConversationApi__Args extends thrift.StructLike implements IClearConversationApi__Args {
    public req: __ROOT_NAMESPACE__.IClearConversationApiRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IClearConversationApi__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_8: __ROOT_NAMESPACE__.IClearConversationApiRequest = new __ROOT_NAMESPACE__.ClearConversationApiRequest(args.req);
            this.req = value_8;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): ClearConversationApi__Args {
        return new ClearConversationApi__Args(ClearConversationApi__ArgsCodec.decode(input));
    }
    public static write(args: IClearConversationApi__ArgsArgs, output: thrift.TProtocol): void {
        return ClearConversationApi__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ClearConversationApi__ArgsCodec.encode(this, output);
    }
}
export interface IListConversationsApi__Args {
    request: __ROOT_NAMESPACE__.IListConversationsApiRequest;
}
export interface IListConversationsApi__ArgsArgs {
    request: __ROOT_NAMESPACE__.IListConversationsApiRequestArgs;
}
export const ListConversationsApi__ArgsCodec: thrift.IStructCodec<IListConversationsApi__ArgsArgs, IListConversationsApi__Args> = {
    encode(args: IListConversationsApi__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("ListConversationsApi__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            __ROOT_NAMESPACE__.ListConversationsApiRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IListConversationsApi__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_9: __ROOT_NAMESPACE__.IListConversationsApiRequest = __ROOT_NAMESPACE__.ListConversationsApiRequestCodec.decode(input);
                        _args.request = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ListConversationsApi__Args from input");
        }
    }
};
export class ListConversationsApi__Args extends thrift.StructLike implements IListConversationsApi__Args {
    public request: __ROOT_NAMESPACE__.IListConversationsApiRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IListConversationsApi__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_10: __ROOT_NAMESPACE__.IListConversationsApiRequest = new __ROOT_NAMESPACE__.ListConversationsApiRequest(args.request);
            this.request = value_10;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): ListConversationsApi__Args {
        return new ListConversationsApi__Args(ListConversationsApi__ArgsCodec.decode(input));
    }
    public static write(args: IListConversationsApi__ArgsArgs, output: thrift.TProtocol): void {
        return ListConversationsApi__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ListConversationsApi__ArgsCodec.encode(this, output);
    }
}
export interface IUpdateConversationApi__Args {
    request: __ROOT_NAMESPACE__.IUpdateConversationApiRequest;
}
export interface IUpdateConversationApi__ArgsArgs {
    request: __ROOT_NAMESPACE__.IUpdateConversationApiRequestArgs;
}
export const UpdateConversationApi__ArgsCodec: thrift.IStructCodec<IUpdateConversationApi__ArgsArgs, IUpdateConversationApi__Args> = {
    encode(args: IUpdateConversationApi__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("UpdateConversationApi__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            __ROOT_NAMESPACE__.UpdateConversationApiRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateConversationApi__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_11: __ROOT_NAMESPACE__.IUpdateConversationApiRequest = __ROOT_NAMESPACE__.UpdateConversationApiRequestCodec.decode(input);
                        _args.request = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateConversationApi__Args from input");
        }
    }
};
export class UpdateConversationApi__Args extends thrift.StructLike implements IUpdateConversationApi__Args {
    public request: __ROOT_NAMESPACE__.IUpdateConversationApiRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateConversationApi__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_12: __ROOT_NAMESPACE__.IUpdateConversationApiRequest = new __ROOT_NAMESPACE__.UpdateConversationApiRequest(args.request);
            this.request = value_12;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): UpdateConversationApi__Args {
        return new UpdateConversationApi__Args(UpdateConversationApi__ArgsCodec.decode(input));
    }
    public static write(args: IUpdateConversationApi__ArgsArgs, output: thrift.TProtocol): void {
        return UpdateConversationApi__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateConversationApi__ArgsCodec.encode(this, output);
    }
}
export interface IDeleteConversationApi__Args {
    req: __ROOT_NAMESPACE__.IDeleteConversationApiRequest;
}
export interface IDeleteConversationApi__ArgsArgs {
    req: __ROOT_NAMESPACE__.IDeleteConversationApiRequestArgs;
}
export const DeleteConversationApi__ArgsCodec: thrift.IStructCodec<IDeleteConversationApi__ArgsArgs, IDeleteConversationApi__Args> = {
    encode(args: IDeleteConversationApi__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("DeleteConversationApi__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            __ROOT_NAMESPACE__.DeleteConversationApiRequestCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDeleteConversationApi__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_13: __ROOT_NAMESPACE__.IDeleteConversationApiRequest = __ROOT_NAMESPACE__.DeleteConversationApiRequestCodec.decode(input);
                        _args.req = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteConversationApi__Args from input");
        }
    }
};
export class DeleteConversationApi__Args extends thrift.StructLike implements IDeleteConversationApi__Args {
    public req: __ROOT_NAMESPACE__.IDeleteConversationApiRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDeleteConversationApi__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_14: __ROOT_NAMESPACE__.IDeleteConversationApiRequest = new __ROOT_NAMESPACE__.DeleteConversationApiRequest(args.req);
            this.req = value_14;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): DeleteConversationApi__Args {
        return new DeleteConversationApi__Args(DeleteConversationApi__ArgsCodec.decode(input));
    }
    public static write(args: IDeleteConversationApi__ArgsArgs, output: thrift.TProtocol): void {
        return DeleteConversationApi__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DeleteConversationApi__ArgsCodec.encode(this, output);
    }
}
export interface IClearConversationCtx__Result {
    success?: __ROOT_NAMESPACE__.IClearConversationCtxResponse;
}
export interface IClearConversationCtx__ResultArgs {
    success?: __ROOT_NAMESPACE__.IClearConversationCtxResponseArgs;
}
export const ClearConversationCtx__ResultCodec: thrift.IStructCodec<IClearConversationCtx__ResultArgs, IClearConversationCtx__Result> = {
    encode(args: IClearConversationCtx__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("ClearConversationCtx__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            __ROOT_NAMESPACE__.ClearConversationCtxResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IClearConversationCtx__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_15: __ROOT_NAMESPACE__.IClearConversationCtxResponse = __ROOT_NAMESPACE__.ClearConversationCtxResponseCodec.decode(input);
                        _args.success = value_15;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class ClearConversationCtx__Result extends thrift.StructLike implements IClearConversationCtx__Result {
    public success?: __ROOT_NAMESPACE__.IClearConversationCtxResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IClearConversationCtx__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_16: __ROOT_NAMESPACE__.IClearConversationCtxResponse = new __ROOT_NAMESPACE__.ClearConversationCtxResponse(args.success);
            this.success = value_16;
        }
    }
    public static read(input: thrift.TProtocol): ClearConversationCtx__Result {
        return new ClearConversationCtx__Result(ClearConversationCtx__ResultCodec.decode(input));
    }
    public static write(args: IClearConversationCtx__ResultArgs, output: thrift.TProtocol): void {
        return ClearConversationCtx__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ClearConversationCtx__ResultCodec.encode(this, output);
    }
}
export interface IClearConversationHistory__Result {
    success?: __ROOT_NAMESPACE__.IClearConversationHistoryResponse;
}
export interface IClearConversationHistory__ResultArgs {
    success?: __ROOT_NAMESPACE__.IClearConversationHistoryResponseArgs;
}
export const ClearConversationHistory__ResultCodec: thrift.IStructCodec<IClearConversationHistory__ResultArgs, IClearConversationHistory__Result> = {
    encode(args: IClearConversationHistory__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("ClearConversationHistory__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            __ROOT_NAMESPACE__.ClearConversationHistoryResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IClearConversationHistory__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_17: __ROOT_NAMESPACE__.IClearConversationHistoryResponse = __ROOT_NAMESPACE__.ClearConversationHistoryResponseCodec.decode(input);
                        _args.success = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class ClearConversationHistory__Result extends thrift.StructLike implements IClearConversationHistory__Result {
    public success?: __ROOT_NAMESPACE__.IClearConversationHistoryResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IClearConversationHistory__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_18: __ROOT_NAMESPACE__.IClearConversationHistoryResponse = new __ROOT_NAMESPACE__.ClearConversationHistoryResponse(args.success);
            this.success = value_18;
        }
    }
    public static read(input: thrift.TProtocol): ClearConversationHistory__Result {
        return new ClearConversationHistory__Result(ClearConversationHistory__ResultCodec.decode(input));
    }
    public static write(args: IClearConversationHistory__ResultArgs, output: thrift.TProtocol): void {
        return ClearConversationHistory__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ClearConversationHistory__ResultCodec.encode(this, output);
    }
}
export interface ICreateConversation__Result {
    success?: __ROOT_NAMESPACE__.ICreateConversationResponse;
}
export interface ICreateConversation__ResultArgs {
    success?: __ROOT_NAMESPACE__.ICreateConversationResponseArgs;
}
export const CreateConversation__ResultCodec: thrift.IStructCodec<ICreateConversation__ResultArgs, ICreateConversation__Result> = {
    encode(args: ICreateConversation__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("CreateConversation__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            __ROOT_NAMESPACE__.CreateConversationResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ICreateConversation__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_19: __ROOT_NAMESPACE__.ICreateConversationResponse = __ROOT_NAMESPACE__.CreateConversationResponseCodec.decode(input);
                        _args.success = value_19;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class CreateConversation__Result extends thrift.StructLike implements ICreateConversation__Result {
    public success?: __ROOT_NAMESPACE__.ICreateConversationResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ICreateConversation__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_20: __ROOT_NAMESPACE__.ICreateConversationResponse = new __ROOT_NAMESPACE__.CreateConversationResponse(args.success);
            this.success = value_20;
        }
    }
    public static read(input: thrift.TProtocol): CreateConversation__Result {
        return new CreateConversation__Result(CreateConversation__ResultCodec.decode(input));
    }
    public static write(args: ICreateConversation__ResultArgs, output: thrift.TProtocol): void {
        return CreateConversation__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return CreateConversation__ResultCodec.encode(this, output);
    }
}
export interface IClearConversationApi__Result {
    success?: __ROOT_NAMESPACE__.IClearConversationApiResponse;
}
export interface IClearConversationApi__ResultArgs {
    success?: __ROOT_NAMESPACE__.IClearConversationApiResponseArgs;
}
export const ClearConversationApi__ResultCodec: thrift.IStructCodec<IClearConversationApi__ResultArgs, IClearConversationApi__Result> = {
    encode(args: IClearConversationApi__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("ClearConversationApi__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            __ROOT_NAMESPACE__.ClearConversationApiResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IClearConversationApi__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_21: __ROOT_NAMESPACE__.IClearConversationApiResponse = __ROOT_NAMESPACE__.ClearConversationApiResponseCodec.decode(input);
                        _args.success = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class ClearConversationApi__Result extends thrift.StructLike implements IClearConversationApi__Result {
    public success?: __ROOT_NAMESPACE__.IClearConversationApiResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IClearConversationApi__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_22: __ROOT_NAMESPACE__.IClearConversationApiResponse = new __ROOT_NAMESPACE__.ClearConversationApiResponse(args.success);
            this.success = value_22;
        }
    }
    public static read(input: thrift.TProtocol): ClearConversationApi__Result {
        return new ClearConversationApi__Result(ClearConversationApi__ResultCodec.decode(input));
    }
    public static write(args: IClearConversationApi__ResultArgs, output: thrift.TProtocol): void {
        return ClearConversationApi__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ClearConversationApi__ResultCodec.encode(this, output);
    }
}
export interface IListConversationsApi__Result {
    success?: __ROOT_NAMESPACE__.IListConversationsApiResponse;
}
export interface IListConversationsApi__ResultArgs {
    success?: __ROOT_NAMESPACE__.IListConversationsApiResponseArgs;
}
export const ListConversationsApi__ResultCodec: thrift.IStructCodec<IListConversationsApi__ResultArgs, IListConversationsApi__Result> = {
    encode(args: IListConversationsApi__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("ListConversationsApi__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            __ROOT_NAMESPACE__.ListConversationsApiResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IListConversationsApi__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_23: __ROOT_NAMESPACE__.IListConversationsApiResponse = __ROOT_NAMESPACE__.ListConversationsApiResponseCodec.decode(input);
                        _args.success = value_23;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class ListConversationsApi__Result extends thrift.StructLike implements IListConversationsApi__Result {
    public success?: __ROOT_NAMESPACE__.IListConversationsApiResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IListConversationsApi__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_24: __ROOT_NAMESPACE__.IListConversationsApiResponse = new __ROOT_NAMESPACE__.ListConversationsApiResponse(args.success);
            this.success = value_24;
        }
    }
    public static read(input: thrift.TProtocol): ListConversationsApi__Result {
        return new ListConversationsApi__Result(ListConversationsApi__ResultCodec.decode(input));
    }
    public static write(args: IListConversationsApi__ResultArgs, output: thrift.TProtocol): void {
        return ListConversationsApi__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ListConversationsApi__ResultCodec.encode(this, output);
    }
}
export interface IUpdateConversationApi__Result {
    success?: __ROOT_NAMESPACE__.IUpdateConversationApiResponse;
}
export interface IUpdateConversationApi__ResultArgs {
    success?: __ROOT_NAMESPACE__.IUpdateConversationApiResponseArgs;
}
export const UpdateConversationApi__ResultCodec: thrift.IStructCodec<IUpdateConversationApi__ResultArgs, IUpdateConversationApi__Result> = {
    encode(args: IUpdateConversationApi__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("UpdateConversationApi__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            __ROOT_NAMESPACE__.UpdateConversationApiResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IUpdateConversationApi__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_25: __ROOT_NAMESPACE__.IUpdateConversationApiResponse = __ROOT_NAMESPACE__.UpdateConversationApiResponseCodec.decode(input);
                        _args.success = value_25;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class UpdateConversationApi__Result extends thrift.StructLike implements IUpdateConversationApi__Result {
    public success?: __ROOT_NAMESPACE__.IUpdateConversationApiResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IUpdateConversationApi__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_26: __ROOT_NAMESPACE__.IUpdateConversationApiResponse = new __ROOT_NAMESPACE__.UpdateConversationApiResponse(args.success);
            this.success = value_26;
        }
    }
    public static read(input: thrift.TProtocol): UpdateConversationApi__Result {
        return new UpdateConversationApi__Result(UpdateConversationApi__ResultCodec.decode(input));
    }
    public static write(args: IUpdateConversationApi__ResultArgs, output: thrift.TProtocol): void {
        return UpdateConversationApi__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return UpdateConversationApi__ResultCodec.encode(this, output);
    }
}
export interface IDeleteConversationApi__Result {
    success?: __ROOT_NAMESPACE__.IDeleteConversationApiResponse;
}
export interface IDeleteConversationApi__ResultArgs {
    success?: __ROOT_NAMESPACE__.IDeleteConversationApiResponseArgs;
}
export const DeleteConversationApi__ResultCodec: thrift.IStructCodec<IDeleteConversationApi__ResultArgs, IDeleteConversationApi__Result> = {
    encode(args: IDeleteConversationApi__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("DeleteConversationApi__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            __ROOT_NAMESPACE__.DeleteConversationApiResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IDeleteConversationApi__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_27: __ROOT_NAMESPACE__.IDeleteConversationApiResponse = __ROOT_NAMESPACE__.DeleteConversationApiResponseCodec.decode(input);
                        _args.success = value_27;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class DeleteConversationApi__Result extends thrift.StructLike implements IDeleteConversationApi__Result {
    public success?: __ROOT_NAMESPACE__.IDeleteConversationApiResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IDeleteConversationApi__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_28: __ROOT_NAMESPACE__.IDeleteConversationApiResponse = new __ROOT_NAMESPACE__.DeleteConversationApiResponse(args.success);
            this.success = value_28;
        }
    }
    public static read(input: thrift.TProtocol): DeleteConversationApi__Result {
        return new DeleteConversationApi__Result(DeleteConversationApi__ResultCodec.decode(input));
    }
    public static write(args: IDeleteConversationApi__ResultArgs, output: thrift.TProtocol): void {
        return DeleteConversationApi__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return DeleteConversationApi__ResultCodec.encode(this, output);
    }
}
export class Client<Context = any> extends thrift.ThriftClient<Context> {
    public static readonly serviceName: string = serviceName;
    public static readonly annotations: thrift.IThriftAnnotations = annotations;
    public static readonly methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public static readonly methodNames: Array<string> = methodNames;
    public readonly _serviceName: string = serviceName;
    public readonly _annotations: thrift.IThriftAnnotations = annotations;
    public readonly _methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public readonly _methodNames: Array<string> = methodNames;
    public readonly _methodParameters?: {
        [methodName: string]: number;
    } = methodParameters;
    public ClearConversationCtx(request: __ROOT_NAMESPACE__.IClearConversationCtxRequestArgs, context?: Context): Promise<__ROOT_NAMESPACE__.IClearConversationCtxResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("ClearConversationCtx", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IClearConversationCtx__ArgsArgs = { request };
        ClearConversationCtx__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "ClearConversationCtx") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IClearConversationCtx__Result = ClearConversationCtx__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "ClearConversationCtx failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public ClearConversationHistory(request: __ROOT_NAMESPACE__.IClearConversationHistoryRequestArgs, context?: Context): Promise<__ROOT_NAMESPACE__.IClearConversationHistoryResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("ClearConversationHistory", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IClearConversationHistory__ArgsArgs = { request };
        ClearConversationHistory__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "ClearConversationHistory") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IClearConversationHistory__Result = ClearConversationHistory__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "ClearConversationHistory failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public CreateConversation(request: __ROOT_NAMESPACE__.ICreateConversationRequestArgs, context?: Context): Promise<__ROOT_NAMESPACE__.ICreateConversationResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("CreateConversation", thrift.MessageType.CALL, this.incrementRequestId());
        const args: ICreateConversation__ArgsArgs = { request };
        CreateConversation__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "CreateConversation") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: ICreateConversation__Result = CreateConversation__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "CreateConversation failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public ClearConversationApi(req: __ROOT_NAMESPACE__.IClearConversationApiRequestArgs, context?: Context): Promise<__ROOT_NAMESPACE__.IClearConversationApiResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("ClearConversationApi", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IClearConversationApi__ArgsArgs = { req };
        ClearConversationApi__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "ClearConversationApi") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IClearConversationApi__Result = ClearConversationApi__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "ClearConversationApi failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public ListConversationsApi(request: __ROOT_NAMESPACE__.IListConversationsApiRequestArgs, context?: Context): Promise<__ROOT_NAMESPACE__.IListConversationsApiResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("ListConversationsApi", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IListConversationsApi__ArgsArgs = { request };
        ListConversationsApi__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "ListConversationsApi") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IListConversationsApi__Result = ListConversationsApi__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "ListConversationsApi failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public UpdateConversationApi(request: __ROOT_NAMESPACE__.IUpdateConversationApiRequestArgs, context?: Context): Promise<__ROOT_NAMESPACE__.IUpdateConversationApiResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("UpdateConversationApi", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IUpdateConversationApi__ArgsArgs = { request };
        UpdateConversationApi__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "UpdateConversationApi") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IUpdateConversationApi__Result = UpdateConversationApi__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "UpdateConversationApi failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public DeleteConversationApi(req: __ROOT_NAMESPACE__.IDeleteConversationApiRequestArgs, context?: Context): Promise<__ROOT_NAMESPACE__.IDeleteConversationApiResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("DeleteConversationApi", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IDeleteConversationApi__ArgsArgs = { req };
        DeleteConversationApi__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "DeleteConversationApi") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IDeleteConversationApi__Result = DeleteConversationApi__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "DeleteConversationApi failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
}
export interface IHandler<Context = any> {
    ClearConversationCtx(request: __ROOT_NAMESPACE__.IClearConversationCtxRequest, context?: Context): __ROOT_NAMESPACE__.IClearConversationCtxResponseArgs | Promise<__ROOT_NAMESPACE__.IClearConversationCtxResponseArgs>;
    ClearConversationHistory(request: __ROOT_NAMESPACE__.IClearConversationHistoryRequest, context?: Context): __ROOT_NAMESPACE__.IClearConversationHistoryResponseArgs | Promise<__ROOT_NAMESPACE__.IClearConversationHistoryResponseArgs>;
    CreateConversation(request: __ROOT_NAMESPACE__.ICreateConversationRequest, context?: Context): __ROOT_NAMESPACE__.ICreateConversationResponseArgs | Promise<__ROOT_NAMESPACE__.ICreateConversationResponseArgs>;
    ClearConversationApi(req: __ROOT_NAMESPACE__.IClearConversationApiRequest, context?: Context): __ROOT_NAMESPACE__.IClearConversationApiResponseArgs | Promise<__ROOT_NAMESPACE__.IClearConversationApiResponseArgs>;
    ListConversationsApi(request: __ROOT_NAMESPACE__.IListConversationsApiRequest, context?: Context): __ROOT_NAMESPACE__.IListConversationsApiResponseArgs | Promise<__ROOT_NAMESPACE__.IListConversationsApiResponseArgs>;
    UpdateConversationApi(request: __ROOT_NAMESPACE__.IUpdateConversationApiRequest, context?: Context): __ROOT_NAMESPACE__.IUpdateConversationApiResponseArgs | Promise<__ROOT_NAMESPACE__.IUpdateConversationApiResponseArgs>;
    DeleteConversationApi(req: __ROOT_NAMESPACE__.IDeleteConversationApiRequest, context?: Context): __ROOT_NAMESPACE__.IDeleteConversationApiResponseArgs | Promise<__ROOT_NAMESPACE__.IDeleteConversationApiResponseArgs>;
}
export class Processor<Context = any> extends thrift.ThriftProcessor<Context, IHandler<Context>> {
    protected readonly _handler: IHandler<Context>;
    public static readonly serviceName: string = serviceName;
    public static readonly annotations: thrift.IThriftAnnotations = annotations;
    public static readonly methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public static readonly methodNames: Array<string> = methodNames;
    public readonly _serviceName: string = serviceName;
    public readonly _annotations: thrift.IThriftAnnotations = annotations;
    public readonly _methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public readonly _methodNames: Array<string> = methodNames;
    constructor(handler: IHandler<Context>) {
        super();
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<Buffer>((resolve): void => {
            const metadata: thrift.IThriftMessage = input.readMessageBegin();
            const fieldName: string = metadata.fieldName;
            const requestId: number = metadata.requestId;
            const methodName: string = "process_" + fieldName;
            switch (methodName) {
                case "process_ClearConversationCtx": {
                    resolve(this.process_ClearConversationCtx(requestId, input, output, context));
                    break;
                }
                case "process_ClearConversationHistory": {
                    resolve(this.process_ClearConversationHistory(requestId, input, output, context));
                    break;
                }
                case "process_CreateConversation": {
                    resolve(this.process_CreateConversation(requestId, input, output, context));
                    break;
                }
                case "process_ClearConversationApi": {
                    resolve(this.process_ClearConversationApi(requestId, input, output, context));
                    break;
                }
                case "process_ListConversationsApi": {
                    resolve(this.process_ListConversationsApi(requestId, input, output, context));
                    break;
                }
                case "process_UpdateConversationApi": {
                    resolve(this.process_UpdateConversationApi(requestId, input, output, context));
                    break;
                }
                case "process_DeleteConversationApi": {
                    resolve(this.process_DeleteConversationApi(requestId, input, output, context));
                    break;
                }
                default: {
                    input.skip(thrift.TType.STRUCT);
                    input.readMessageEnd();
                    const errMessage = "Unknown function " + fieldName;
                    const err = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                    output.writeMessageBegin(fieldName, thrift.MessageType.EXCEPTION, requestId);
                    thrift.TApplicationExceptionCodec.encode(err, output);
                    output.writeMessageEnd();
                    resolve(output.flush());
                    break;
                }
            }
        });
    }
    public process_ClearConversationCtx(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<__ROOT_NAMESPACE__.IClearConversationCtxResponseArgs>((resolve, reject): void => {
            try {
                const args: IClearConversationCtx__Args = ClearConversationCtx__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.ClearConversationCtx(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: __ROOT_NAMESPACE__.IClearConversationCtxResponseArgs): Buffer => {
            const result: IClearConversationCtx__ResultArgs = { success: data };
            output.writeMessageBegin("ClearConversationCtx", thrift.MessageType.REPLY, requestId);
            ClearConversationCtx__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("ClearConversationCtx", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_ClearConversationHistory(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<__ROOT_NAMESPACE__.IClearConversationHistoryResponseArgs>((resolve, reject): void => {
            try {
                const args: IClearConversationHistory__Args = ClearConversationHistory__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.ClearConversationHistory(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: __ROOT_NAMESPACE__.IClearConversationHistoryResponseArgs): Buffer => {
            const result: IClearConversationHistory__ResultArgs = { success: data };
            output.writeMessageBegin("ClearConversationHistory", thrift.MessageType.REPLY, requestId);
            ClearConversationHistory__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("ClearConversationHistory", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_CreateConversation(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<__ROOT_NAMESPACE__.ICreateConversationResponseArgs>((resolve, reject): void => {
            try {
                const args: ICreateConversation__Args = CreateConversation__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.CreateConversation(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: __ROOT_NAMESPACE__.ICreateConversationResponseArgs): Buffer => {
            const result: ICreateConversation__ResultArgs = { success: data };
            output.writeMessageBegin("CreateConversation", thrift.MessageType.REPLY, requestId);
            CreateConversation__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("CreateConversation", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_ClearConversationApi(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<__ROOT_NAMESPACE__.IClearConversationApiResponseArgs>((resolve, reject): void => {
            try {
                const args: IClearConversationApi__Args = ClearConversationApi__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.ClearConversationApi(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: __ROOT_NAMESPACE__.IClearConversationApiResponseArgs): Buffer => {
            const result: IClearConversationApi__ResultArgs = { success: data };
            output.writeMessageBegin("ClearConversationApi", thrift.MessageType.REPLY, requestId);
            ClearConversationApi__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("ClearConversationApi", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_ListConversationsApi(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<__ROOT_NAMESPACE__.IListConversationsApiResponseArgs>((resolve, reject): void => {
            try {
                const args: IListConversationsApi__Args = ListConversationsApi__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.ListConversationsApi(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: __ROOT_NAMESPACE__.IListConversationsApiResponseArgs): Buffer => {
            const result: IListConversationsApi__ResultArgs = { success: data };
            output.writeMessageBegin("ListConversationsApi", thrift.MessageType.REPLY, requestId);
            ListConversationsApi__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("ListConversationsApi", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_UpdateConversationApi(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<__ROOT_NAMESPACE__.IUpdateConversationApiResponseArgs>((resolve, reject): void => {
            try {
                const args: IUpdateConversationApi__Args = UpdateConversationApi__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.UpdateConversationApi(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: __ROOT_NAMESPACE__.IUpdateConversationApiResponseArgs): Buffer => {
            const result: IUpdateConversationApi__ResultArgs = { success: data };
            output.writeMessageBegin("UpdateConversationApi", thrift.MessageType.REPLY, requestId);
            UpdateConversationApi__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("UpdateConversationApi", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_DeleteConversationApi(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<__ROOT_NAMESPACE__.IDeleteConversationApiResponseArgs>((resolve, reject): void => {
            try {
                const args: IDeleteConversationApi__Args = DeleteConversationApi__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.DeleteConversationApi(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: __ROOT_NAMESPACE__.IDeleteConversationApiResponseArgs): Buffer => {
            const result: IDeleteConversationApi__ResultArgs = { success: data };
            output.writeMessageBegin("DeleteConversationApi", thrift.MessageType.REPLY, requestId);
            DeleteConversationApi__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("DeleteConversationApi", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
}
