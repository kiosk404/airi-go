/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "@creditkarma/thrift-server-core";
import * as LibraryResourceListRequest from "./LibraryResourceListRequest";
import * as LibraryResourceListResponse from "./LibraryResourceListResponse";
import * as ProjectResourceListRequest from "./ProjectResourceListRequest";
import * as ProjectResourceListResponse from "./ProjectResourceListResponse";
import * as ResourceCopyDispatchRequest from "./ResourceCopyDispatchRequest";
import * as ResourceCopyDispatchResponse from "./ResourceCopyDispatchResponse";
import * as ResourceCopyDetailRequest from "./ResourceCopyDetailRequest";
import * as ResourceCopyDetailResponse from "./ResourceCopyDetailResponse";
import * as ResourceCopyRetryRequest from "./ResourceCopyRetryRequest";
import * as ResourceCopyRetryResponse from "./ResourceCopyRetryResponse";
import * as ResourceCopyCancelRequest from "./ResourceCopyCancelRequest";
import * as ResourceCopyCancelResponse from "./ResourceCopyCancelResponse";
export const serviceName: string = "ResourceService";
export const annotations: thrift.IThriftAnnotations = {};
export const methodAnnotations: thrift.IMethodAnnotations = {
    LibraryResourceList: {
        annotations: {
            'api.post': "/api/plugin_api/library_resource_list",
            'api.category': "resource",
            'api.gen_path': "resource",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    },
    ProjectResourceList: {
        annotations: {
            'api.post': "/api/plugin_api/project_resource_list",
            'api.category': "resource",
            'api.gen_path': "resource",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    },
    ResourceCopyDispatch: {
        annotations: {
            'api.post': "/api/plugin_api/resource_copy_dispatch",
            'api.category': "resource",
            'api.gen_path': "resource",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    },
    ResourceCopyDetail: {
        annotations: {
            'api.post': "/api/plugin_api/resource_copy_detail",
            'api.category': "resource",
            'api.gen_path': "resource",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    },
    ResourceCopyRetry: {
        annotations: {
            'api.post': "/api/plugin_api/resource_copy_retry",
            'api.category': "resource",
            'api.gen_path': "resource",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    },
    ResourceCopyCancel: {
        annotations: {
            'api.post': "/api/plugin_api/resource_copy_cancel",
            'api.category': "resource",
            'api.gen_path': "resource",
            'agw.preserve_base': "true"
        },
        fieldAnnotations: {}
    }
};
export const methodNames: Array<string> = ["LibraryResourceList", "ProjectResourceList", "ResourceCopyDispatch", "ResourceCopyDetail", "ResourceCopyRetry", "ResourceCopyCancel"];
export const methodParameters: {
    [methodName: string]: number;
} = {
    LibraryResourceList: 2,
    ProjectResourceList: 2,
    ResourceCopyDispatch: 2,
    ResourceCopyDetail: 2,
    ResourceCopyRetry: 2,
    ResourceCopyCancel: 2
};
export interface ILibraryResourceList__Args {
    request: LibraryResourceListRequest.ILibraryResourceListRequest;
}
export interface ILibraryResourceList__ArgsArgs {
    request: LibraryResourceListRequest.ILibraryResourceListRequestArgs;
}
export const LibraryResourceList__ArgsCodec: thrift.IStructCodec<ILibraryResourceList__ArgsArgs, ILibraryResourceList__Args> = {
    encode(args: ILibraryResourceList__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("LibraryResourceList__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            LibraryResourceListRequest.LibraryResourceListRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ILibraryResourceList__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_1: LibraryResourceListRequest.ILibraryResourceListRequest = LibraryResourceListRequest.LibraryResourceListRequestCodec.decode(input);
                        _args.request = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read LibraryResourceList__Args from input");
        }
    }
};
export class LibraryResourceList__Args extends thrift.StructLike implements ILibraryResourceList__Args {
    public request: LibraryResourceListRequest.ILibraryResourceListRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ILibraryResourceList__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_2: LibraryResourceListRequest.ILibraryResourceListRequest = new LibraryResourceListRequest.LibraryResourceListRequest(args.request);
            this.request = value_2;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): LibraryResourceList__Args {
        return new LibraryResourceList__Args(LibraryResourceList__ArgsCodec.decode(input));
    }
    public static write(args: ILibraryResourceList__ArgsArgs, output: thrift.TProtocol): void {
        return LibraryResourceList__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return LibraryResourceList__ArgsCodec.encode(this, output);
    }
}
export interface IProjectResourceList__Args {
    request: ProjectResourceListRequest.IProjectResourceListRequest;
}
export interface IProjectResourceList__ArgsArgs {
    request: ProjectResourceListRequest.IProjectResourceListRequestArgs;
}
export const ProjectResourceList__ArgsCodec: thrift.IStructCodec<IProjectResourceList__ArgsArgs, IProjectResourceList__Args> = {
    encode(args: IProjectResourceList__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            request: args.request
        };
        output.writeStructBegin("ProjectResourceList__Args");
        if (obj.request != null) {
            output.writeFieldBegin("request", thrift.TType.STRUCT, 1);
            ProjectResourceListRequest.ProjectResourceListRequestCodec.encode(obj.request, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IProjectResourceList__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_3: ProjectResourceListRequest.IProjectResourceListRequest = ProjectResourceListRequest.ProjectResourceListRequestCodec.decode(input);
                        _args.request = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.request !== undefined) {
            return {
                request: _args.request
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ProjectResourceList__Args from input");
        }
    }
};
export class ProjectResourceList__Args extends thrift.StructLike implements IProjectResourceList__Args {
    public request: ProjectResourceListRequest.IProjectResourceListRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IProjectResourceList__ArgsArgs) {
        super();
        if (args.request != null) {
            const value_4: ProjectResourceListRequest.IProjectResourceListRequest = new ProjectResourceListRequest.ProjectResourceListRequest(args.request);
            this.request = value_4;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[request] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): ProjectResourceList__Args {
        return new ProjectResourceList__Args(ProjectResourceList__ArgsCodec.decode(input));
    }
    public static write(args: IProjectResourceList__ArgsArgs, output: thrift.TProtocol): void {
        return ProjectResourceList__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ProjectResourceList__ArgsCodec.encode(this, output);
    }
}
export interface IResourceCopyDispatch__Args {
    req: ResourceCopyDispatchRequest.IResourceCopyDispatchRequest;
}
export interface IResourceCopyDispatch__ArgsArgs {
    req: ResourceCopyDispatchRequest.IResourceCopyDispatchRequestArgs;
}
export const ResourceCopyDispatch__ArgsCodec: thrift.IStructCodec<IResourceCopyDispatch__ArgsArgs, IResourceCopyDispatch__Args> = {
    encode(args: IResourceCopyDispatch__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("ResourceCopyDispatch__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            ResourceCopyDispatchRequest.ResourceCopyDispatchRequestCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IResourceCopyDispatch__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_5: ResourceCopyDispatchRequest.IResourceCopyDispatchRequest = ResourceCopyDispatchRequest.ResourceCopyDispatchRequestCodec.decode(input);
                        _args.req = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ResourceCopyDispatch__Args from input");
        }
    }
};
export class ResourceCopyDispatch__Args extends thrift.StructLike implements IResourceCopyDispatch__Args {
    public req: ResourceCopyDispatchRequest.IResourceCopyDispatchRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IResourceCopyDispatch__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_6: ResourceCopyDispatchRequest.IResourceCopyDispatchRequest = new ResourceCopyDispatchRequest.ResourceCopyDispatchRequest(args.req);
            this.req = value_6;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): ResourceCopyDispatch__Args {
        return new ResourceCopyDispatch__Args(ResourceCopyDispatch__ArgsCodec.decode(input));
    }
    public static write(args: IResourceCopyDispatch__ArgsArgs, output: thrift.TProtocol): void {
        return ResourceCopyDispatch__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ResourceCopyDispatch__ArgsCodec.encode(this, output);
    }
}
export interface IResourceCopyDetail__Args {
    req: ResourceCopyDetailRequest.IResourceCopyDetailRequest;
}
export interface IResourceCopyDetail__ArgsArgs {
    req: ResourceCopyDetailRequest.IResourceCopyDetailRequestArgs;
}
export const ResourceCopyDetail__ArgsCodec: thrift.IStructCodec<IResourceCopyDetail__ArgsArgs, IResourceCopyDetail__Args> = {
    encode(args: IResourceCopyDetail__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("ResourceCopyDetail__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            ResourceCopyDetailRequest.ResourceCopyDetailRequestCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IResourceCopyDetail__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_7: ResourceCopyDetailRequest.IResourceCopyDetailRequest = ResourceCopyDetailRequest.ResourceCopyDetailRequestCodec.decode(input);
                        _args.req = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ResourceCopyDetail__Args from input");
        }
    }
};
export class ResourceCopyDetail__Args extends thrift.StructLike implements IResourceCopyDetail__Args {
    public req: ResourceCopyDetailRequest.IResourceCopyDetailRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IResourceCopyDetail__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_8: ResourceCopyDetailRequest.IResourceCopyDetailRequest = new ResourceCopyDetailRequest.ResourceCopyDetailRequest(args.req);
            this.req = value_8;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): ResourceCopyDetail__Args {
        return new ResourceCopyDetail__Args(ResourceCopyDetail__ArgsCodec.decode(input));
    }
    public static write(args: IResourceCopyDetail__ArgsArgs, output: thrift.TProtocol): void {
        return ResourceCopyDetail__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ResourceCopyDetail__ArgsCodec.encode(this, output);
    }
}
export interface IResourceCopyRetry__Args {
    req: ResourceCopyRetryRequest.IResourceCopyRetryRequest;
}
export interface IResourceCopyRetry__ArgsArgs {
    req: ResourceCopyRetryRequest.IResourceCopyRetryRequestArgs;
}
export const ResourceCopyRetry__ArgsCodec: thrift.IStructCodec<IResourceCopyRetry__ArgsArgs, IResourceCopyRetry__Args> = {
    encode(args: IResourceCopyRetry__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("ResourceCopyRetry__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            ResourceCopyRetryRequest.ResourceCopyRetryRequestCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IResourceCopyRetry__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_9: ResourceCopyRetryRequest.IResourceCopyRetryRequest = ResourceCopyRetryRequest.ResourceCopyRetryRequestCodec.decode(input);
                        _args.req = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ResourceCopyRetry__Args from input");
        }
    }
};
export class ResourceCopyRetry__Args extends thrift.StructLike implements IResourceCopyRetry__Args {
    public req: ResourceCopyRetryRequest.IResourceCopyRetryRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IResourceCopyRetry__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_10: ResourceCopyRetryRequest.IResourceCopyRetryRequest = new ResourceCopyRetryRequest.ResourceCopyRetryRequest(args.req);
            this.req = value_10;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): ResourceCopyRetry__Args {
        return new ResourceCopyRetry__Args(ResourceCopyRetry__ArgsCodec.decode(input));
    }
    public static write(args: IResourceCopyRetry__ArgsArgs, output: thrift.TProtocol): void {
        return ResourceCopyRetry__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ResourceCopyRetry__ArgsCodec.encode(this, output);
    }
}
export interface IResourceCopyCancel__Args {
    req: ResourceCopyCancelRequest.IResourceCopyCancelRequest;
}
export interface IResourceCopyCancel__ArgsArgs {
    req: ResourceCopyCancelRequest.IResourceCopyCancelRequestArgs;
}
export const ResourceCopyCancel__ArgsCodec: thrift.IStructCodec<IResourceCopyCancel__ArgsArgs, IResourceCopyCancel__Args> = {
    encode(args: IResourceCopyCancel__ArgsArgs, output: thrift.TProtocol): void {
        const obj: any = {
            req: args.req
        };
        output.writeStructBegin("ResourceCopyCancel__Args");
        if (obj.req != null) {
            output.writeFieldBegin("req", thrift.TType.STRUCT, 1);
            ResourceCopyCancelRequest.ResourceCopyCancelRequestCodec.encode(obj.req, output);
            output.writeFieldEnd();
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IResourceCopyCancel__Args {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_11: ResourceCopyCancelRequest.IResourceCopyCancelRequest = ResourceCopyCancelRequest.ResourceCopyCancelRequestCodec.decode(input);
                        _args.req = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.req !== undefined) {
            return {
                req: _args.req
            };
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ResourceCopyCancel__Args from input");
        }
    }
};
export class ResourceCopyCancel__Args extends thrift.StructLike implements IResourceCopyCancel__Args {
    public req: ResourceCopyCancelRequest.IResourceCopyCancelRequest;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IResourceCopyCancel__ArgsArgs) {
        super();
        if (args.req != null) {
            const value_12: ResourceCopyCancelRequest.IResourceCopyCancelRequest = new ResourceCopyCancelRequest.ResourceCopyCancelRequest(args.req);
            this.req = value_12;
        }
        else {
            throw new thrift.TProtocolException(thrift.TProtocolExceptionType.UNKNOWN, "Required field[req] is unset!");
        }
    }
    public static read(input: thrift.TProtocol): ResourceCopyCancel__Args {
        return new ResourceCopyCancel__Args(ResourceCopyCancel__ArgsCodec.decode(input));
    }
    public static write(args: IResourceCopyCancel__ArgsArgs, output: thrift.TProtocol): void {
        return ResourceCopyCancel__ArgsCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ResourceCopyCancel__ArgsCodec.encode(this, output);
    }
}
export interface ILibraryResourceList__Result {
    success?: LibraryResourceListResponse.ILibraryResourceListResponse;
}
export interface ILibraryResourceList__ResultArgs {
    success?: LibraryResourceListResponse.ILibraryResourceListResponseArgs;
}
export const LibraryResourceList__ResultCodec: thrift.IStructCodec<ILibraryResourceList__ResultArgs, ILibraryResourceList__Result> = {
    encode(args: ILibraryResourceList__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("LibraryResourceList__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            LibraryResourceListResponse.LibraryResourceListResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): ILibraryResourceList__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_13: LibraryResourceListResponse.ILibraryResourceListResponse = LibraryResourceListResponse.LibraryResourceListResponseCodec.decode(input);
                        _args.success = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class LibraryResourceList__Result extends thrift.StructLike implements ILibraryResourceList__Result {
    public success?: LibraryResourceListResponse.ILibraryResourceListResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: ILibraryResourceList__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_14: LibraryResourceListResponse.ILibraryResourceListResponse = new LibraryResourceListResponse.LibraryResourceListResponse(args.success);
            this.success = value_14;
        }
    }
    public static read(input: thrift.TProtocol): LibraryResourceList__Result {
        return new LibraryResourceList__Result(LibraryResourceList__ResultCodec.decode(input));
    }
    public static write(args: ILibraryResourceList__ResultArgs, output: thrift.TProtocol): void {
        return LibraryResourceList__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return LibraryResourceList__ResultCodec.encode(this, output);
    }
}
export interface IProjectResourceList__Result {
    success?: ProjectResourceListResponse.IProjectResourceListResponse;
}
export interface IProjectResourceList__ResultArgs {
    success?: ProjectResourceListResponse.IProjectResourceListResponseArgs;
}
export const ProjectResourceList__ResultCodec: thrift.IStructCodec<IProjectResourceList__ResultArgs, IProjectResourceList__Result> = {
    encode(args: IProjectResourceList__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("ProjectResourceList__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            ProjectResourceListResponse.ProjectResourceListResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IProjectResourceList__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_15: ProjectResourceListResponse.IProjectResourceListResponse = ProjectResourceListResponse.ProjectResourceListResponseCodec.decode(input);
                        _args.success = value_15;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class ProjectResourceList__Result extends thrift.StructLike implements IProjectResourceList__Result {
    public success?: ProjectResourceListResponse.IProjectResourceListResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IProjectResourceList__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_16: ProjectResourceListResponse.IProjectResourceListResponse = new ProjectResourceListResponse.ProjectResourceListResponse(args.success);
            this.success = value_16;
        }
    }
    public static read(input: thrift.TProtocol): ProjectResourceList__Result {
        return new ProjectResourceList__Result(ProjectResourceList__ResultCodec.decode(input));
    }
    public static write(args: IProjectResourceList__ResultArgs, output: thrift.TProtocol): void {
        return ProjectResourceList__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ProjectResourceList__ResultCodec.encode(this, output);
    }
}
export interface IResourceCopyDispatch__Result {
    success?: ResourceCopyDispatchResponse.IResourceCopyDispatchResponse;
}
export interface IResourceCopyDispatch__ResultArgs {
    success?: ResourceCopyDispatchResponse.IResourceCopyDispatchResponseArgs;
}
export const ResourceCopyDispatch__ResultCodec: thrift.IStructCodec<IResourceCopyDispatch__ResultArgs, IResourceCopyDispatch__Result> = {
    encode(args: IResourceCopyDispatch__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("ResourceCopyDispatch__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            ResourceCopyDispatchResponse.ResourceCopyDispatchResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IResourceCopyDispatch__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_17: ResourceCopyDispatchResponse.IResourceCopyDispatchResponse = ResourceCopyDispatchResponse.ResourceCopyDispatchResponseCodec.decode(input);
                        _args.success = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class ResourceCopyDispatch__Result extends thrift.StructLike implements IResourceCopyDispatch__Result {
    public success?: ResourceCopyDispatchResponse.IResourceCopyDispatchResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IResourceCopyDispatch__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_18: ResourceCopyDispatchResponse.IResourceCopyDispatchResponse = new ResourceCopyDispatchResponse.ResourceCopyDispatchResponse(args.success);
            this.success = value_18;
        }
    }
    public static read(input: thrift.TProtocol): ResourceCopyDispatch__Result {
        return new ResourceCopyDispatch__Result(ResourceCopyDispatch__ResultCodec.decode(input));
    }
    public static write(args: IResourceCopyDispatch__ResultArgs, output: thrift.TProtocol): void {
        return ResourceCopyDispatch__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ResourceCopyDispatch__ResultCodec.encode(this, output);
    }
}
export interface IResourceCopyDetail__Result {
    success?: ResourceCopyDetailResponse.IResourceCopyDetailResponse;
}
export interface IResourceCopyDetail__ResultArgs {
    success?: ResourceCopyDetailResponse.IResourceCopyDetailResponseArgs;
}
export const ResourceCopyDetail__ResultCodec: thrift.IStructCodec<IResourceCopyDetail__ResultArgs, IResourceCopyDetail__Result> = {
    encode(args: IResourceCopyDetail__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("ResourceCopyDetail__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            ResourceCopyDetailResponse.ResourceCopyDetailResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IResourceCopyDetail__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_19: ResourceCopyDetailResponse.IResourceCopyDetailResponse = ResourceCopyDetailResponse.ResourceCopyDetailResponseCodec.decode(input);
                        _args.success = value_19;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class ResourceCopyDetail__Result extends thrift.StructLike implements IResourceCopyDetail__Result {
    public success?: ResourceCopyDetailResponse.IResourceCopyDetailResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IResourceCopyDetail__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_20: ResourceCopyDetailResponse.IResourceCopyDetailResponse = new ResourceCopyDetailResponse.ResourceCopyDetailResponse(args.success);
            this.success = value_20;
        }
    }
    public static read(input: thrift.TProtocol): ResourceCopyDetail__Result {
        return new ResourceCopyDetail__Result(ResourceCopyDetail__ResultCodec.decode(input));
    }
    public static write(args: IResourceCopyDetail__ResultArgs, output: thrift.TProtocol): void {
        return ResourceCopyDetail__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ResourceCopyDetail__ResultCodec.encode(this, output);
    }
}
export interface IResourceCopyRetry__Result {
    success?: ResourceCopyRetryResponse.IResourceCopyRetryResponse;
}
export interface IResourceCopyRetry__ResultArgs {
    success?: ResourceCopyRetryResponse.IResourceCopyRetryResponseArgs;
}
export const ResourceCopyRetry__ResultCodec: thrift.IStructCodec<IResourceCopyRetry__ResultArgs, IResourceCopyRetry__Result> = {
    encode(args: IResourceCopyRetry__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("ResourceCopyRetry__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            ResourceCopyRetryResponse.ResourceCopyRetryResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IResourceCopyRetry__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_21: ResourceCopyRetryResponse.IResourceCopyRetryResponse = ResourceCopyRetryResponse.ResourceCopyRetryResponseCodec.decode(input);
                        _args.success = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class ResourceCopyRetry__Result extends thrift.StructLike implements IResourceCopyRetry__Result {
    public success?: ResourceCopyRetryResponse.IResourceCopyRetryResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IResourceCopyRetry__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_22: ResourceCopyRetryResponse.IResourceCopyRetryResponse = new ResourceCopyRetryResponse.ResourceCopyRetryResponse(args.success);
            this.success = value_22;
        }
    }
    public static read(input: thrift.TProtocol): ResourceCopyRetry__Result {
        return new ResourceCopyRetry__Result(ResourceCopyRetry__ResultCodec.decode(input));
    }
    public static write(args: IResourceCopyRetry__ResultArgs, output: thrift.TProtocol): void {
        return ResourceCopyRetry__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ResourceCopyRetry__ResultCodec.encode(this, output);
    }
}
export interface IResourceCopyCancel__Result {
    success?: ResourceCopyCancelResponse.IResourceCopyCancelResponse;
}
export interface IResourceCopyCancel__ResultArgs {
    success?: ResourceCopyCancelResponse.IResourceCopyCancelResponseArgs;
}
export const ResourceCopyCancel__ResultCodec: thrift.IStructCodec<IResourceCopyCancel__ResultArgs, IResourceCopyCancel__Result> = {
    encode(args: IResourceCopyCancel__ResultArgs, output: thrift.TProtocol): void {
        const obj: any = {
            success: args.success
        };
        output.writeStructBegin("ResourceCopyCancel__Result");
        if (obj.success != null) {
            output.writeFieldBegin("success", thrift.TType.STRUCT, 0);
            ResourceCopyCancelResponse.ResourceCopyCancelResponseCodec.encode(obj.success, output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    },
    decode(input: thrift.TProtocol): IResourceCopyCancel__Result {
        let _args: any = {};
        input.readStructBegin();
        while (true) {
            const ret: thrift.IThriftField = input.readFieldBegin();
            const fieldType: thrift.TType = ret.fieldType;
            const fieldId: number = ret.fieldId;
            if (fieldType === thrift.TType.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.TType.STRUCT) {
                        const value_23: ResourceCopyCancelResponse.IResourceCopyCancelResponse = ResourceCopyCancelResponse.ResourceCopyCancelResponseCodec.decode(input);
                        _args.success = value_23;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return {
            success: _args.success
        };
    }
};
export class ResourceCopyCancel__Result extends thrift.StructLike implements IResourceCopyCancel__Result {
    public success?: ResourceCopyCancelResponse.IResourceCopyCancelResponse;
    public readonly _annotations: thrift.IThriftAnnotations = {};
    public readonly _fieldAnnotations: thrift.IFieldAnnotations = {};
    constructor(args: IResourceCopyCancel__ResultArgs = {}) {
        super();
        if (args.success != null) {
            const value_24: ResourceCopyCancelResponse.IResourceCopyCancelResponse = new ResourceCopyCancelResponse.ResourceCopyCancelResponse(args.success);
            this.success = value_24;
        }
    }
    public static read(input: thrift.TProtocol): ResourceCopyCancel__Result {
        return new ResourceCopyCancel__Result(ResourceCopyCancel__ResultCodec.decode(input));
    }
    public static write(args: IResourceCopyCancel__ResultArgs, output: thrift.TProtocol): void {
        return ResourceCopyCancel__ResultCodec.encode(args, output);
    }
    public write(output: thrift.TProtocol): void {
        return ResourceCopyCancel__ResultCodec.encode(this, output);
    }
}
export class Client<Context = any> extends thrift.ThriftClient<Context> {
    public static readonly serviceName: string = serviceName;
    public static readonly annotations: thrift.IThriftAnnotations = annotations;
    public static readonly methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public static readonly methodNames: Array<string> = methodNames;
    public readonly _serviceName: string = serviceName;
    public readonly _annotations: thrift.IThriftAnnotations = annotations;
    public readonly _methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public readonly _methodNames: Array<string> = methodNames;
    public readonly _methodParameters?: {
        [methodName: string]: number;
    } = methodParameters;
    public LibraryResourceList(request: LibraryResourceListRequest.ILibraryResourceListRequestArgs, context?: Context): Promise<LibraryResourceListResponse.ILibraryResourceListResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("LibraryResourceList", thrift.MessageType.CALL, this.incrementRequestId());
        const args: ILibraryResourceList__ArgsArgs = { request };
        LibraryResourceList__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "LibraryResourceList") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: ILibraryResourceList__Result = LibraryResourceList__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "LibraryResourceList failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public ProjectResourceList(request: ProjectResourceListRequest.IProjectResourceListRequestArgs, context?: Context): Promise<ProjectResourceListResponse.IProjectResourceListResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("ProjectResourceList", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IProjectResourceList__ArgsArgs = { request };
        ProjectResourceList__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "ProjectResourceList") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IProjectResourceList__Result = ProjectResourceList__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "ProjectResourceList failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public ResourceCopyDispatch(req: ResourceCopyDispatchRequest.IResourceCopyDispatchRequestArgs, context?: Context): Promise<ResourceCopyDispatchResponse.IResourceCopyDispatchResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("ResourceCopyDispatch", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IResourceCopyDispatch__ArgsArgs = { req };
        ResourceCopyDispatch__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "ResourceCopyDispatch") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IResourceCopyDispatch__Result = ResourceCopyDispatch__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "ResourceCopyDispatch failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public ResourceCopyDetail(req: ResourceCopyDetailRequest.IResourceCopyDetailRequestArgs, context?: Context): Promise<ResourceCopyDetailResponse.IResourceCopyDetailResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("ResourceCopyDetail", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IResourceCopyDetail__ArgsArgs = { req };
        ResourceCopyDetail__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "ResourceCopyDetail") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IResourceCopyDetail__Result = ResourceCopyDetail__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "ResourceCopyDetail failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public ResourceCopyRetry(req: ResourceCopyRetryRequest.IResourceCopyRetryRequestArgs, context?: Context): Promise<ResourceCopyRetryResponse.IResourceCopyRetryResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("ResourceCopyRetry", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IResourceCopyRetry__ArgsArgs = { req };
        ResourceCopyRetry__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "ResourceCopyRetry") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IResourceCopyRetry__Result = ResourceCopyRetry__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "ResourceCopyRetry failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
    public ResourceCopyCancel(req: ResourceCopyCancelRequest.IResourceCopyCancelRequestArgs, context?: Context): Promise<ResourceCopyCancelResponse.IResourceCopyCancelResponse> {
        const writer: thrift.TTransport = new this.transport();
        const output: thrift.TProtocol = new this.protocol(writer);
        output.writeMessageBegin("ResourceCopyCancel", thrift.MessageType.CALL, this.incrementRequestId());
        const args: IResourceCopyCancel__ArgsArgs = { req };
        ResourceCopyCancel__ArgsCodec.encode(args, output);
        output.writeMessageEnd();
        return this.connection.send(writer.flush(), context).then((data: Buffer) => {
            const reader: thrift.TTransport = this.transport.receiver(data);
            const input: thrift.TProtocol = new this.protocol(reader);
            try {
                const { fieldName: fieldName, messageType: messageType }: thrift.IThriftMessage = input.readMessageBegin();
                if (fieldName === "ResourceCopyCancel") {
                    if (messageType === thrift.MessageType.EXCEPTION) {
                        const err: thrift.TApplicationException = thrift.TApplicationExceptionCodec.decode(input);
                        input.readMessageEnd();
                        return Promise.reject(err);
                    }
                    else {
                        const result: IResourceCopyCancel__Result = ResourceCopyCancel__ResultCodec.decode(input);
                        input.readMessageEnd();
                        if (result.success != null) {
                            return Promise.resolve(result.success);
                        }
                        else {
                            return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, "ResourceCopyCancel failed: unknown result"));
                        }
                    }
                }
                else {
                    return Promise.reject(new thrift.TApplicationException(thrift.TApplicationExceptionType.WRONG_METHOD_NAME, "Received a response to an unknown RPC function: " + fieldName));
                }
            }
            catch (err) {
                return Promise.reject(err);
            }
        });
    }
}
export interface IHandler<Context = any> {
    LibraryResourceList(request: LibraryResourceListRequest.ILibraryResourceListRequest, context?: Context): LibraryResourceListResponse.ILibraryResourceListResponseArgs | Promise<LibraryResourceListResponse.ILibraryResourceListResponseArgs>;
    ProjectResourceList(request: ProjectResourceListRequest.IProjectResourceListRequest, context?: Context): ProjectResourceListResponse.IProjectResourceListResponseArgs | Promise<ProjectResourceListResponse.IProjectResourceListResponseArgs>;
    ResourceCopyDispatch(req: ResourceCopyDispatchRequest.IResourceCopyDispatchRequest, context?: Context): ResourceCopyDispatchResponse.IResourceCopyDispatchResponseArgs | Promise<ResourceCopyDispatchResponse.IResourceCopyDispatchResponseArgs>;
    ResourceCopyDetail(req: ResourceCopyDetailRequest.IResourceCopyDetailRequest, context?: Context): ResourceCopyDetailResponse.IResourceCopyDetailResponseArgs | Promise<ResourceCopyDetailResponse.IResourceCopyDetailResponseArgs>;
    ResourceCopyRetry(req: ResourceCopyRetryRequest.IResourceCopyRetryRequest, context?: Context): ResourceCopyRetryResponse.IResourceCopyRetryResponseArgs | Promise<ResourceCopyRetryResponse.IResourceCopyRetryResponseArgs>;
    ResourceCopyCancel(req: ResourceCopyCancelRequest.IResourceCopyCancelRequest, context?: Context): ResourceCopyCancelResponse.IResourceCopyCancelResponseArgs | Promise<ResourceCopyCancelResponse.IResourceCopyCancelResponseArgs>;
}
export class Processor<Context = any> extends thrift.ThriftProcessor<Context, IHandler<Context>> {
    protected readonly _handler: IHandler<Context>;
    public static readonly serviceName: string = serviceName;
    public static readonly annotations: thrift.IThriftAnnotations = annotations;
    public static readonly methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public static readonly methodNames: Array<string> = methodNames;
    public readonly _serviceName: string = serviceName;
    public readonly _annotations: thrift.IThriftAnnotations = annotations;
    public readonly _methodAnnotations: thrift.IMethodAnnotations = methodAnnotations;
    public readonly _methodNames: Array<string> = methodNames;
    constructor(handler: IHandler<Context>) {
        super();
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<Buffer>((resolve, reject): void => {
            const metadata: thrift.IThriftMessage = input.readMessageBegin();
            const fieldName: string = metadata.fieldName;
            const requestId: number = metadata.requestId;
            const methodName: string = "process_" + fieldName;
            switch (methodName) {
                case "process_LibraryResourceList": {
                    resolve(this.process_LibraryResourceList(requestId, input, output, context));
                    break;
                }
                case "process_ProjectResourceList": {
                    resolve(this.process_ProjectResourceList(requestId, input, output, context));
                    break;
                }
                case "process_ResourceCopyDispatch": {
                    resolve(this.process_ResourceCopyDispatch(requestId, input, output, context));
                    break;
                }
                case "process_ResourceCopyDetail": {
                    resolve(this.process_ResourceCopyDetail(requestId, input, output, context));
                    break;
                }
                case "process_ResourceCopyRetry": {
                    resolve(this.process_ResourceCopyRetry(requestId, input, output, context));
                    break;
                }
                case "process_ResourceCopyCancel": {
                    resolve(this.process_ResourceCopyCancel(requestId, input, output, context));
                    break;
                }
                default: {
                    input.skip(thrift.TType.STRUCT);
                    input.readMessageEnd();
                    const errMessage = "Unknown function " + fieldName;
                    const err = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                    output.writeMessageBegin(fieldName, thrift.MessageType.EXCEPTION, requestId);
                    thrift.TApplicationExceptionCodec.encode(err, output);
                    output.writeMessageEnd();
                    resolve(output.flush());
                    break;
                }
            }
        });
    }
    public process_LibraryResourceList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<LibraryResourceListResponse.ILibraryResourceListResponseArgs>((resolve, reject): void => {
            try {
                const args: ILibraryResourceList__Args = LibraryResourceList__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.LibraryResourceList(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: LibraryResourceListResponse.ILibraryResourceListResponseArgs): Buffer => {
            const result: ILibraryResourceList__ResultArgs = { success: data };
            output.writeMessageBegin("LibraryResourceList", thrift.MessageType.REPLY, requestId);
            LibraryResourceList__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("LibraryResourceList", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_ProjectResourceList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<ProjectResourceListResponse.IProjectResourceListResponseArgs>((resolve, reject): void => {
            try {
                const args: IProjectResourceList__Args = ProjectResourceList__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.ProjectResourceList(args.request, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ProjectResourceListResponse.IProjectResourceListResponseArgs): Buffer => {
            const result: IProjectResourceList__ResultArgs = { success: data };
            output.writeMessageBegin("ProjectResourceList", thrift.MessageType.REPLY, requestId);
            ProjectResourceList__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("ProjectResourceList", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_ResourceCopyDispatch(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<ResourceCopyDispatchResponse.IResourceCopyDispatchResponseArgs>((resolve, reject): void => {
            try {
                const args: IResourceCopyDispatch__Args = ResourceCopyDispatch__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.ResourceCopyDispatch(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ResourceCopyDispatchResponse.IResourceCopyDispatchResponseArgs): Buffer => {
            const result: IResourceCopyDispatch__ResultArgs = { success: data };
            output.writeMessageBegin("ResourceCopyDispatch", thrift.MessageType.REPLY, requestId);
            ResourceCopyDispatch__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("ResourceCopyDispatch", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_ResourceCopyDetail(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<ResourceCopyDetailResponse.IResourceCopyDetailResponseArgs>((resolve, reject): void => {
            try {
                const args: IResourceCopyDetail__Args = ResourceCopyDetail__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.ResourceCopyDetail(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ResourceCopyDetailResponse.IResourceCopyDetailResponseArgs): Buffer => {
            const result: IResourceCopyDetail__ResultArgs = { success: data };
            output.writeMessageBegin("ResourceCopyDetail", thrift.MessageType.REPLY, requestId);
            ResourceCopyDetail__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("ResourceCopyDetail", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_ResourceCopyRetry(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<ResourceCopyRetryResponse.IResourceCopyRetryResponseArgs>((resolve, reject): void => {
            try {
                const args: IResourceCopyRetry__Args = ResourceCopyRetry__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.ResourceCopyRetry(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ResourceCopyRetryResponse.IResourceCopyRetryResponseArgs): Buffer => {
            const result: IResourceCopyRetry__ResultArgs = { success: data };
            output.writeMessageBegin("ResourceCopyRetry", thrift.MessageType.REPLY, requestId);
            ResourceCopyRetry__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("ResourceCopyRetry", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
    public process_ResourceCopyCancel(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol, context: Context): Promise<Buffer> {
        return new Promise<ResourceCopyCancelResponse.IResourceCopyCancelResponseArgs>((resolve, reject): void => {
            try {
                const args: IResourceCopyCancel__Args = ResourceCopyCancel__ArgsCodec.decode(input);
                input.readMessageEnd();
                resolve(this._handler.ResourceCopyCancel(args.req, context));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ResourceCopyCancelResponse.IResourceCopyCancelResponseArgs): Buffer => {
            const result: IResourceCopyCancel__ResultArgs = { success: data };
            output.writeMessageBegin("ResourceCopyCancel", thrift.MessageType.REPLY, requestId);
            ResourceCopyCancel__ResultCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        }).catch((err: Error): Buffer => {
            const result: thrift.TApplicationException = new thrift.TApplicationException(thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("ResourceCopyCancel", thrift.MessageType.EXCEPTION, requestId);
            thrift.TApplicationExceptionCodec.encode(result, output);
            output.writeMessageEnd();
            return output.flush();
        });
    }
}
